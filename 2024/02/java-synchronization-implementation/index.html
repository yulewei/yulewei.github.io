<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png">
  <link rel="mask-icon" href="/favicon.png" color="#222">
  <meta name="baidu-site-verification" content="qxFtDn0ziX">
  <meta name="sogou_site_verification" content="Wj1N74IImQ" /> 

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nullwy.me","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="关于 Java 线程同步的实现原理，官方有很多介绍资料[1][2][3][4][5][6]，值得阅读。 基础概念 在并发编程模型中，需要处理的两个最关键的问题就是通信（communication）和同步（synchronization）。通信指线程可用于获得其他线程产生的信息的各种机制。通信机制通常都基于共享内存（shared memory）或消息传递（message passing）。在共享内存">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程同步实现原理深度解析">
<meta property="og:url" content="https://nullwy.me/2024/02/java-synchronization-implementation/index.html">
<meta property="og:site_name" content="nullwy&#39;s blog">
<meta property="og:description" content="关于 Java 线程同步的实现原理，官方有很多介绍资料[1][2][3][4][5][6]，值得阅读。 基础概念 在并发编程模型中，需要处理的两个最关键的问题就是通信（communication）和同步（synchronization）。通信指线程可用于获得其他线程产生的信息的各种机制。通信机制通常都基于共享内存（shared memory）或消息传递（message passing）。在共享内存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/synchronization-mindmap.svg">
<meta property="og:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/java-mark-word.png">
<meta property="og:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/java-mark-word-state-transitions.gif">
<meta property="og:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/java-mark-word-biased-lock.png">
<meta property="og:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/java-mark-word-lightweight-lock.png">
<meta property="og:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/java-mark-word-heavyweight-lock.png">
<meta property="og:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/java-heavyweight-monitor-internals.png">
<meta property="article:published_time" content="2024-02-10T07:58:00.000Z">
<meta property="article:modified_time" content="2024-03-03T16:06:06.509Z">
<meta property="article:author" content="nullwy">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="同步">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nullwy.me/2024/02/java-synchronization-implementation/media/synchronization-mindmap.svg">

<link rel="canonical" href="https://nullwy.me/2024/02/java-synchronization-implementation/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 线程同步实现原理深度解析 | nullwy's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4LE29KVMN"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Y4LE29KVMN');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?928b3d50428cc362a2d2ed846517583e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="nullwy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">nullwy's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2024/02/java-synchronization-implementation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 线程同步实现原理深度解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-10 15:58:00" itemprop="dateCreated datePublished" datetime="2024-02-10T15:58:00+08:00">2024-02-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2024/02/java-synchronization-implementation/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/02/java-synchronization-implementation/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>关于 Java 线程同步的实现原理，官方有很多介绍资料[<sup>1][</sup>2][<sup>3][</sup>4][<sup>5][</sup>6]，值得阅读。</p>
<h1 id="基础概念">基础概念</h1>
<p>在并发编程模型中，需要处理的两个最关键的问题就是<strong>通信</strong>（communication）和<strong>同步</strong>（synchronization）。通信指线程可用于获得其他线程产生的信息的各种机制。通信机制通常都基于<strong>共享内存</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_memory">shared memory</a>）或<strong>消息传递</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Message_passing">message passing</a>）。在共享内存的编程模型中，某些或全部程序变量可以由多个线程访问。如果一对线程之间需要通信，只要一个线程将值写入某个变量，另一线程来读它即可。在消息传递编程模型中，不同线程没有公共的状态。当一对线程之间需要通信时，其中的一个必须执行一次明确的 send 操作，将数据传送给另一个线程。</p>
<p>同步[^1]是控制不同线程之间操作发生的相对顺序的各种机制，用以排除导致不正确结果的交错。消息传递模型中的同步通常是隐式的，消息的发送必须在接收之前。如果某个线程企图接收一个尚未发送的消息，那么它就必须等到发送方赶上来。在共享内存编程模型中，同步通常不是隐式的，除非我们做了某些特殊的事情，否则“接收方”就可能在某个变量被“发送方“修改之前读到其中的“老”值。</p>
<p>并发和同步相关的基础概念，本文不再展开，综述类文章或章节可以阅读，全面介绍性的书籍可以阅读。同步相关的基础概念的思维导图，如下图所示：</p>
<p><img src="media/synchronization-mindmap.svg" alt="同步基础概念思维导图"></p>
<h1 id="线程管理">线程管理</h1>
<p>操作系统线程的实现区分用户空间线程和内核空间线程，两者的映射关系被称为<strong>线程模型</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_%28computing%29#Threading_models">threading model</a>）。目前主流的操作系统的线程模型都是 <code>1:1</code>，即每个用户空间线程都对应单独的内核空间线程。早期部分操作系统还支持<code> M:1</code>、<code>M:N</code> 模型，但因为过于复杂，逐渐被废弃。比如，Solaris 8 之前采用 <code>M:N</code> 线程模型，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Oracle_Solaris">Solaris</a> 8 （2000.02 发布）开始支持新的 <code>1:1</code> 线程模型，Solaris 9（2002.05 发布）默认采用 <code>1:1</code> 模型。类似的，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> 8（2009.11 发布）开始不再支持 <code>M:N</code> 模型，只支持<code>1:1</code> 模型。</p>
<p>在 Java 虚拟机层面，<strong>线程模型</strong>是指 Java 线程与操作系统线程的映射关系。当前，Hotspot 虚拟机实现的线程模型在各个操作系统平台下都采用 <code>1:1</code> 模型[^1]。总体上，Java 线程模型是 <code>1:1:1</code>。</p>
<p>Java 早期版本（JDK 1.1 到 JDK 1.2），Java 线程被称为<strong>绿色线程</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Green_thread">green thread</a>），采用的线程模型是 <code>M:1</code>，即全部 Java 线程底层共享同一个操作系统线程。JDK 1.3 开始（2000.05 发布），绿色线程被废弃，改为 <code>1:1</code> 线程模型。JDK 21 开始（2023.09 发布），Java 平台开始同时支持<strong>虚拟线程</strong>（virtual thread），采用的线程模型是 <code>M:N</code>，参见 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/444">JEP-444</a>。其他编程语言也支持类似的轻量级线程的特性，比如 2009 年诞生的 Go 语言，不支持 <code>1:1</code> 线程模型，在诞生之初内置实现的是轻量级线程 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Go_(programming_language)#Concurrency:_goroutines_and_channels">goroutine</a>，采用的线程模型是 <code>M:N</code>。</p>
<p>Java 创建线程，<code>java.lang.Thread.start()</code> 的实现原理：</p>
<ul>
<li><strong>功能描述</strong>：使该线程开始执行，Java 虚拟机调用该线程的 run 方法。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_StartThread(JNIEnv* env, jobject jthread)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Thread.c#L43">Thread.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L2816">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：构造 <code>JavaThread</code> 对象，然后调用 <code>os::create_thread(..)</code> 函数，构造 <code>OSThread</code> 对象，并创建与操作系统相关的线程。<code>os::create_thread(..)</code> 函数在不同操作系统平台下的实现
<ul>
<li><strong>类 Unix 系统</strong>：调用 POSIX 函数 <code>pthread_create</code>（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">man</a>），创建 <code>pthread</code> 线程，并在线程中运行 <code>java_start</code> 函数，<code>java_start</code> 函数内部会通过 <code>JavaCalls::call_virtual</code> 调用 <code>java.lang.Thread.run()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L865">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk8u/blob/jdk8u402-ga/hotspot/src/os/bsd/vm/os_bsd.cpp#L757">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L1091">os_solaris.cpp</a>）
<ul>
<li>实际上，Solaris 系统下的实现默认是基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Light-weight_process">LWP</a> 线程，而不是 Pthreads 线程，API 与 Pthreads 类似。创建线程调用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E86824_01/html/E54766/thr-create-3c.html">thr_create</a> 函数。</li>
<li>通过 JVM 参数选项 -XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseLWPSynchronization">UseLWPSynchronization</a> 控制，默认开启，若关闭，则改为基于 Pthreads 线程。JDK 15 开始（2020.09 发布），Java 平台删除对 Solaris 系统的支持，参见 <a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8241787">JEP-381</a>。</li>
</ul>
</li>
<li><strong>Windows 系统</strong>：调用函数 <code>_beginthreadex</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170">doc</a>），创建 Windows 线程，并在线程中运行 <code>java_start</code> 函数，<code>java_start</code> 函数内部会通过 <code>JavaCalls::call_virtual</code> 调用 <code>java.lang.Thread.run()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L517">os_windows.cpp</a>）</li>
</ul>
</li>
</ul>
<h1 id="基于-synchronized-线程同步">基于 synchronized 线程同步</h1>
<h2 id="偏向锁、轻量级锁和重量级锁">偏向锁、轻量级锁和重量级锁</h2>
<p>基于 <code>synchronized</code> 关键字的线程同步，HotSpot 虚拟机底层实现基于三种锁定技术，按适用的线程竞争程度由低至高依次为：偏向锁（Biased Lock）、轻量级锁（Lightweight Lock）和重量级锁（Heavyweight Lock）。基于三种锁定技术的线程同步的成本也依次增高。加锁时，先尝试偏向锁，若失败再升级为轻量级锁，最后再升级为重量级锁。</p>
<table>
<thead>
<tr>
<th><strong>锁定技术</strong></th>
<th><strong>官方支持时间</strong></th>
<th><strong>使用场景</strong></th>
<th><strong>相对其他锁定技术的优缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>重量级锁</strong></td>
<td>最早版本的 Java（1995.05）</td>
<td>有竞争</td>
<td>实现 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29">Monitor</a>，在无竞争场景下，性能较差</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>最早版本的 HotSpot（<a target="_blank" rel="noopener" href="https://web.archive.org/web/19991005170608/http://java.sun.com/pr/1999/04/pr990427-01.html">1999.04</a>）</td>
<td>有共享、无竞争</td>
<td>在无竞争场景下，避免创建 Monitor，从而提升性能</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>Java 6 开始支持（2006.12），Java 15 开始废弃（2020.09）</td>
<td>无共享、无竞争</td>
<td>相对轻量级锁，需要更少的 CAS 原子操作，除第一次加偏向锁外，锁重入和解锁都<strong>无需 CAS 原子操作</strong></td>
</tr>
</tbody>
</table>
<p>Java 的 <code>synchronized</code> 关键字的线程同步实现的是<strong>管程</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29">Monitor</a>，或翻译为“监视器”）。管程是 Brinch Hansen 和 Hoare 在 1970 年代初期发明的，1974 年 Brinch Hansen 在 Concurrent Pascal 编程语言上首次实现了管程。之后，Modula（1977）和 Mesa（1980）等编程语言也实现了管程。管程，是一种编程语言级别的高级同步机制，由<strong>互斥锁</strong>（mutual exclusion，缩写为“mutex”）和至少一个<strong>条件变量</strong>（condition variable，有时缩写为“condvar”）组成，<strong>Monitor = Mutex + Condvar</strong>。当条件变量为真时，按是否阻塞发 signal 的线程区分 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29#Blocking_condition_variables">Hoare 风格</a>（阻塞）和 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29#Nonblocking_condition_variables">Mesa 风格</a>（不阻塞）。Hoare 风格较难实现，目前大部分编程语言都是 Mesa 风格，Java 实现的是也是 <strong>Mesa 风格</strong>。Java 的所有对象都可以是 Monitor。另外，原始版本的 Monitor 有多个显式的条件变量，而 Java 实现的 Monitor <strong>只有单个隐式的条件变量</strong>。</p>
<p>早期版本的 Java 实现的管程的<strong>性能较差</strong>。典型的例子是，早期 Java 标准库中的 <code>Hashtable</code>、<code>Vector</code>、<code>StringBuffer</code> 等类存在<strong>过度同步</strong>（over-synchronized）问题，这些类的全部方法都用 <code>synchronized</code> 关键字包裹，即便是在单个线程无竞争的场景下运行，内部也总是执行同步逻辑。于是就有了针对<strong>无竞争（uncontended）场景</strong>下的同步的性能优化，出现了<strong>轻量级锁定</strong>（lightweight locking）技术。</p>
<p>轻量级锁定技术最早源自一篇发表于 1998 年的名为“<strong>瘦锁</strong>”（Thin Lock）的论文<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，作者来自 IBM 研究院，最早在 IBM 版的 JDK 1.1 中实现。相对的，在论文中完整版的 Monitor 实现被称为<strong>胖锁</strong>（Fat Lock）或<strong>膨胀锁</strong>（Inflated Lock）。瘦锁实现只需要维护在对象头中的 24 位的锁字（Lock Word）结构，而 Monitor 实现底层需要维护持有锁的线程、锁重入计数器、锁竞争队列、条件变量等待队列等复杂数据结构，所以被形象地命名为胖锁和瘦锁。原始版的瘦锁的实现可以参阅论文，本文不展开。HotSpot 虚拟机实现的轻量级锁定与瘦锁的核心思想类似，但有实现细节略微区别。HotSpot 实现的轻量级锁<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，多路复用对象头中 <code>Mark Word</code> 字段，并且为了提升性能在<strong>线程栈</strong>上维护<strong>锁记录</strong>（lock record, 或叫 on-stack lock record），所以 HotSpot 实现的轻量级锁也被叫做<strong>栈锁</strong>（Stack Lock）。</p>
<p>轻量级锁定技术优化的是<strong>无竞争（uncontended）场景</strong>，偏向锁定技术进一步优化了<strong>无共享（unshared）场景</strong>。研究发现大多数对象锁在对象生命周期内总是<strong>只有单个线程持有</strong>（即无共享），基于这个观察，2002 年 IBM 研究实验室提出<strong>锁保留</strong>（Lock Reservation）<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>技术的优化。Java 官方最早在 2006 年发布 Java 6 的 HotSpot 中实现偏向锁定技术，默认开启，核心思想类似于锁保留，同时还实现了批量重偏向和撤销<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>。<strong>偏向锁定技术的核心思想是，总是偏向于第一个获得它的线程，或者说锁总是保留给第一个线程，即便该线程已经释放锁</strong>。相对与轻量级锁定的优点是，<strong>偏向锁定需要更少的 CAS 原子操作，除第一次加偏向锁外，锁重入和解锁都无需 CAS 原子操作</strong>。2020 年 Java 15 发布后，<strong>偏向锁被废弃</strong>。原因是过去看到的性能提升在今天不再那么明显，变化主要包括早期标准库过度同步的类被新的无同步类、并发集合类等替代，以及硬件支持的 CAS 原子操作性能的提升等。另外，偏向锁定在同步子系统中引入了大量复杂的代码，给同步子系统的代码理解和设计变更带来障碍。具体参见 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/374">JEP-374</a>。</p>
<p>HotSpot 虚拟机的对象是否加锁以及底层使用哪种锁定技术通过对象头（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#objectHeader">object header</a>）中的 <strong><a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#markWord">Mark Word</a></strong> 字段区分。在未加锁时，<code>Mark Word</code> 字段用于记录对象的 <code>identity hash code</code> 和垃圾回收的年龄（age）。之所以多路复用 <code>Mark Word</code> 字段的功能，而不是在对象头中添加额外的字段，是为了<strong>避免增加对象的大小</strong>。在 32 位机器上的 <code>Mark Word</code> 格式，如下图所示<sup class="footnote-ref"><a href="#fn3" id="fnref3:2">[3:2]</a></sup>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/oops/markOop.hpp">markOop.hpp</a>）。对象头内共两个字段，除了 <code>Mark Word</code> 外，另外一个字段是 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#klassPointer">Klass Pointer</a>，是指向类元数据的指针。</p>
<p><img src="media/java-mark-word.png" alt="Mark Word 字段的各种状态"></p>
<p><strong>偏向锁（Biased Lock）</strong>，也叫<strong>锁保留（Lock Reservation）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：无共享（unshared）、无竞争（uncontended）</li>
<li><strong>加锁实现</strong>：如果 JVM 开启偏向锁选项，那么新对象创建分配的对象头的 <code>Mark Word</code> 状态是<strong>未偏向、可偏向状态</strong>（unbiased, biasable）或叫<strong>匿名偏向状态</strong>（anonymously biased），最低的三位值为 <code>101</code>，偏向的线程 Thread ID 值为 <code>0</code>。第一次加偏向锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>当前线程 Thread ID</strong> 实现。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>偏向锁定状态</strong>（biased, biasable）。若 CAS 原子操作失败，表明是另外一个线程去尝试获取这个锁，则<strong>撤销偏向锁</strong>（revoke bias）（不考虑批量重偏向的情况）。如果偏向线程不存活或不在同步块中，则先将锁对象设置为<strong>无锁状态</strong>（unlocked, unbiasable）。如果偏向线程还存活且还在同步块中，则将锁对象<strong>升级为轻量级锁</strong>。撤销偏向锁是 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#VMOperations">VM 操作</a>，需要等到 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint">safepoint</a> 的时候由 VM 线程执行。在 safepoint 没有 Java 线程执行字节码。
<ul>
<li><strong>锁重入</strong>：当偏向线程<strong>锁重入</strong>时，只需要检测比较 <code>Mark Word</code> 中的 <strong>Thread ID</strong> 是否相同，若相同则重入成功，<strong>不需要执行 CAS 原子更新操作</strong>。</li>
<li><strong>批量重偏向和撤销</strong>：偏向锁技术，不支持单个对象的重偏向，偏向线程不能从一个线程转移到另一个线程，但支持<strong>批量重偏向</strong>（bulk rebias）。HotSpot 虚拟机基于 epoch 概念实现了<strong>批量重偏向</strong>（bulk rebias）和<strong>批量撤销</strong>（bulk revoke）。</li>
</ul>
</li>
<li><strong>解锁实现</strong>：无需 CAS 原子操作，不需要更新对象头的 <code>Mark Word</code> 字段，<strong>依然偏向第一个获取偏向锁的线程</strong>。需要释放线程栈的<strong>锁记录</strong>，将<strong>锁记录</strong>中的指向持有锁对象的指针设置为 <code>NULL</code> 空。</li>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseBiasedLocking">UseBiasedLocking</a>，是否开启偏向锁，默认开启。</li>
</ul>
<p><strong>轻量级锁（Lightweight Lock）</strong>，也叫<strong>栈锁（Stack Lock）或瘦锁（Thin Lock）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：有共享（shared）、无竞争（uncontended）。即<strong>多个线程交替执行</strong>同步块，当某线程持有锁时没有其他线程尝试获取这个锁。</li>
<li><strong>加锁实现</strong>：从无锁或偏向锁升级到轻量级锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>指向锁记录的指针</strong>。同时，锁记录上需要写入两个字段，第一个字段被称为 <code>Displaced Mark Word</code>，或叫 <code>Displaced Header</code>，包含原始的对象头的 <code>Mark Word</code> 字段（记录 <code>hash</code> 和 <code>age</code> 信息），第二个字段是指向持有锁对象的指针。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>轻量级锁定状态</strong>（lightweight locked）。如果 CAS 原子修改失败，表明锁已经被其他线程占用，需要将轻量级锁膨胀为<strong>重量级锁。</strong>
<ul>
<li><strong>锁重入</strong>：将重入的<strong>锁记录</strong>中的 <code>Displaced Mark Word</code>值设置为 <code>NULL</code>（值为 <code>0</code>）。<code>Displaced Mark Word</code> 值为 <code>NULL</code> 的锁记录的数量，就是锁重入的次数。</li>
</ul>
</li>
<li><strong>解锁实现</strong>：释放<strong>锁记录</strong>，将<strong>锁记录</strong>中的指向持有锁对象的指针设置为 <code>NULL</code> 空。若 <code>Displaced Mark Word</code> 值非 <code>NULL</code>，表明不是锁重入的释放，同时还要通过 CAS 原子操作将<strong>锁记录</strong>中的 <code>Displaced Mark Word</code> 值还原到对象头中的 <code>Mark Word</code> ，即将 <code>Mark Word</code> 还原为<strong>无锁状态</strong>（unlocked, unbiasable）。</li>
</ul>
<p><strong>重量级锁（Heavyweight Lock）</strong>，也叫<strong>重量级管程（Heavyweight Monitor）、膨胀锁（Inflated Lock）或胖锁（Fat Lock）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：有竞争（contended）</li>
<li><strong>升级膨胀</strong>：从轻量级锁升级到重量级锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>指向 Monitor 对象的指针</strong>。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>重量级锁定状态</strong>（heavyweight locked）。</li>
<li><strong>降级收缩</strong>：虚拟机会在 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint">safepoint</a> 点会扫描全部 Monitor，找出全部 idle 状态的 Monitor，并将这些 Monitor 关联的锁对象还原为<strong>无锁状态</strong>（unlocked, unbiasable），即将在 Monitor 中保存的 <code>Displaced Mark Word</code> 还原到对象头中的 <code>Mark Word</code>。idle 状态的 Monitor 的持有锁的线程、锁竞争队列、等待队列等全部字段都为空。</li>
<li><strong>加锁和解锁实现</strong>：管程底层由 <code>ObjectMonitor</code> 类实现，内部维护持有锁的线程、锁重入计数器、锁竞争队列、条件变量等待队列等字段。管程内部的加锁和解锁实现的完整阐述参见下文。</li>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseHeavyMonitors">UseHeavyMonitors</a>，是否只使用重量级锁，默认 false，开启后禁用偏向和轻量锁 。</li>
</ul>
<p><strong>hashcode 与偏向锁定状态的冲突</strong>：偏向锁复用了对象头的 <code>Mark Word</code> 字段，但是与轻量级锁和重量级锁不同，偏向锁没有额外维护 <code>Displaced Mark Word</code>，所以 hashcode 与偏向状态无法共存，当需要计算对象的  <code>identity hash code</code> 时，会撤销偏向锁，并升级为重量级锁。调用 <code>java.lang.Object.hashCode()</code> 或 <code>java.lang.System.identityHashCode(Object)</code> 会触发 <code>identity hash code</code> 的计算，需要读取对象头的 <code>Mark Word</code> 中的 hash 值。如果计算对象的 hashcode 值调用的是被覆盖后的 <code>hashCode()</code> 方法，则不会读取 <code>Mark Word</code> 中的 hash 值，可以继续使用偏向锁。相关实现源码解析（参见 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L601">synchronizer.cpp</a>）：</p>
<ul>
<li>调用 <code>java.lang.Object.hashCode()</code> 或 <code>java.lang.System.identityHashCode(Object)</code> 计算对象的 hashcode，在 JVM 层实现都会先调用 <code>JVM_IHashCode(..)</code> 函数，然后再调用 <code>ObjectSynchronizer::FastHashCode(..)</code> 函数，该函数会返回存储在对象头的 <code>Mark Word</code> 中的 hash 值。如果对象处于偏向锁定状态，会撤销偏向锁，并升级为重量级 Monitor，然后再返回在维护在 Monitor 中的 <code>Displaced Mark Word</code> 字段内的 hash 值。</li>
</ul>
<p>三种锁定技术下的 <code>Mark Word</code> 字段的状态流转，如下图所示[^2]：</p>
<p><img src="media/java-mark-word-state-transitions.gif" alt="Mark Word 字段的状态流转"></p>
<p>三种锁定技术下的 <code>Mark Word</code> 和 <code>Lock Record</code> 字段值，如下图所示[^6]<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：</p>
<p><img src="media/java-mark-word-biased-lock.png" alt="偏向锁的 Mark Word 和 Lock Record"></p>
<p><img src="media/java-mark-word-lightweight-lock.png" alt="轻量级锁的 Mark Word 和 Lock Record"></p>
<p><img src="media/java-mark-word-heavyweight-lock.png" alt="重量级锁的 Mark Word、Lock Record 和 ObjectMonitor"></p>
<p><strong>相关实现源码</strong>：</p>
<ul>
<li>对象头的 <code>Mark Word</code> 字段对应的实现类是 <code>markOopDesc</code> 和 <code>markOop</code> 类，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/oops/markOop.hpp">markOop.hpp</a>
<ul>
<li><code>markOop</code> 类是 <code>markOopDesc</code> 的指针类，定义是 <code>typedef class markOopDesc* markOop;</code></li>
</ul>
</li>
<li>线程栈上锁记录对应的实现类是 <code>BasicObjectLock</code>类，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/basicLock.hpp">basicLock.hpp</a>。
<ul>
<li>在锁记录上维护两个字段。第一个字段，被称为 <code>Displaced Mark Word</code>，或叫 <code>Displaced Header</code>，包含原始的对象头的 <code>Mark Word</code> 字段（记录 <code>hash</code> 和 <code>age</code> 信息），字段定义源码 <code>BasicLock _lock</code>。第二个字段，是指向持有锁对象的指针，字段定义源码 <code>oop _obj</code>。</li>
<li><code>BasicLock</code> 类的 <code>void set_displaced_header(markOop header)</code> 方法，用于修改锁记录的 <code>Mark Word</code> 字段值</li>
</ul>
</li>
<li><strong>synchronized 加锁的实现源码</strong>：
<ul>
<li><strong>字节码指令</strong>：<code>monitorenter</code></li>
<li><strong>JVM 层实现源码入口</strong>：
<ul>
<li><code>TemplateTable::monitorenter()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorenter)</code>。虚拟机实现两种解释器，模板解释器和字节码解释器，默认使用模板解释器，但是字节码解释器代码可读性更高，模板解释器参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3596">templateTable_x86_64.cpp</a>，字节码解释器参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1686">bytecodeInterpreter.cpp</a></li>
<li>实现上，先尝试<strong>偏向锁</strong>，若失败再升级为<strong>轻量级锁</strong>，若加<strong>轻量级锁</strong>失败，再膨胀为<strong>重量级锁</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>synchronized 解锁的实现源码</strong>：
<ul>
<li><strong>字节码指令</strong>：<code>monitorexit</code></li>
<li><strong>JVM 层实现源码入口</strong>：
<ul>
<li><code>TemplateTable::monitorexit()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorexit)</code>。参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3690">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1720">bytecodeInterpreter.cpp</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重量级-Monitor-的实现">重量级 Monitor 的实现</h2>
<p><img src="media/java-heavyweight-monitor-internals.png" alt="Java 重量级 Monitor 的底层实现（默认策略）"></p>
<p>Hotspot 虚拟机的重量级 Monitor 实现的最核心类是 <code>ObjectMonitor</code>，<code>ObjectMonitor</code>类定义的部分核心字段（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.hpp#L77">objectMonitor.hpp</a> 和 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L185">objectMonitor.cpp</a>）：</p>
<ul>
<li><code>header</code>（字段名 <code>_header</code>）：持有锁对象的对象头中的原始 <code>Mark Word</code>，即 <code>Displaced Mark Word</code>。</li>
<li><code>object</code>（字段名 <code>_object</code>）：指向持有锁对象的指针。</li>
<li><code>owner</code>（字段名 <code>_owner</code>）：持有锁的线程。</li>
<li><code>succ</code>（字段名 <code>_succ</code>）：假定继承人线程（heir presumptive），或叫“successor”线程。</li>
<li><code>cxq</code>（字段名 <code>_cxq</code>）：“contention queue”的缩写，锁竞争队列。</li>
<li><code>EntryList</code>（字段名 <code>_EntryList</code>）：锁竞争队列。
<ul>
<li>区分两个锁竞争队列 <code>cxq</code> 和 <code>EntryList</code> 的原因是，为了优化出队列操作的时间。多个线程并发入队到 <code>cxq</code> 队列，而只有持有锁的线程可以在 <code>cxq</code> 队列上执行出队列操作。只有持有锁的线程可以访问和修改 <code>EntryList</code> 队列，在 <code>EntryList</code> 队列上的操作都是无锁的（lock-free）。参见源码注释的解释：
<ul>
<li>“We use two distinct lists to improve the odds of a constant-time dequeue operation after acquisition (in the ::enter() epilog) and to reduce heat on the list ends.” [ref <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L234">objectMonitor.cpp</a>]</li>
</ul>
</li>
</ul>
</li>
<li><code>WaitSet</code>（字段名 <code>_WaitSet</code>）：条件变量的等待（waiting）队列。</li>
<li><code>recursions</code>（字段名 <code>_recursions</code>）：锁重入计数器。</li>
</ul>
<p><strong>Monitor 加锁的 JVM 层实现源码解析</strong>：</p>
<ul>
<li>(1) 调用 <code>TemplateTable::monitorenter()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorenter)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3596">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1686">bytecodeInterpreter.cpp</a>）
<ul>
<li>先尝试<strong>偏向锁</strong>，若失败再升级为<strong>轻量级锁</strong>，若加<strong>轻量级锁</strong>失败，再膨胀为<strong>重量级锁</strong>。</li>
</ul>
</li>
<li>(2) 依次调用 <code>InterpreterRuntime::monitorenter(..)</code>、<code>ObjectSynchronizer::fast_enter(..)</code>、<code>ObjectSynchronizer::slow_enter(..)</code>，再调用 <code>ObjectSynchronizer::inflate(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L166">synchronizer.cpp</a>）
<ul>
<li>在 <code>inflate(..)</code> 函数内部，执行将轻量级锁膨胀为重量级锁的逻辑，函数内部构造 <code>ObjectMonitor</code> 对象并返回。</li>
</ul>
</li>
<li>(3) 调用 <code>ObjectMonitor::enter(..)</code>，再调用 <code>ObjectMonitor::EnterI(..)</code>，执行<strong>重量级锁的加锁逻辑</strong>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L479">objectMonitor.cpp</a>）
<ul>
<li>加锁的互斥操作，通过 CAS 原子操作将 <code>ObjectMonitor</code> 对象的 <code>_owner</code> 字段从 <code>null</code> 修改为当前线程（<code>Self</code>），若失败则<strong>自适应自旋</strong>（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#adaptiveSpinning">adaptive spinning</a>）重试。
<ul>
<li>相关源码：<code>Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL);</code></li>
</ul>
</li>
<li>若自旋竞争锁失败，将线程加到 <code>ObjectMonitor</code> 对象的 <code>cxq</code> <strong>锁竞争队列的队头</strong>，并 <code>ParkEvent::park()</code> 阻塞当前线程。</li>
</ul>
</li>
</ul>
<p><strong>Monitor 解锁的 JVM 层实现源码解析</strong>：</p>
<ul>
<li>(1) 调用 <code>TemplateTable::monitorexit()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorexit)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3690">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1720">bytecodeInterpreter.cpp</a>）</li>
<li>(2) 调用 <code>InterpreterRuntime::monitorexit(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/interpreterRuntime.cpp#L586">interpreterRuntime.cpp</a>）</li>
<li>(3) 调用 <code>ObjectSynchronizer::fast_exit()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L183">synchronizer.cpp</a>）
<ul>
<li>释放<strong>轻量级锁</strong>，通过 CAS 原子操作将<strong>锁记录</strong>中的 <code>Displaced Mark Word</code>值还原到对象头中的 <code>Mark Word</code> ，即将 <code>Mark Word</code> 还原为<strong>无锁状态</strong>。</li>
</ul>
</li>
<li>(4) 调用 <code>ObjectMonitor::exit(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L933">objectMonitor.cpp</a>）
<ul>
<li>释放<strong>重量级锁</strong>，将 <code>ObjectMonitor</code> 对象的 <code>owner</code> 字段设置为 <code>null</code>
<ul>
<li>相关源码：<code>OrderAccess::release_store_ptr (&amp;_owner, NULL);</code></li>
</ul>
</li>
<li><strong>默认的锁竞争队列出队策略是</strong>，唤醒在 <code>EntryList</code> <strong>锁竞争队列</strong>的队头的线程，如果 <code>EntryList</code> 为空，则将 <code>cxq</code> 中的节点全部移到 <code>EntryList</code> 中，然后再去 <code>ParkEvent::unpark()</code> 唤醒 <code>EntryList</code> 的队头的线程。被 <code>ParkEvent::unpark()</code> 唤醒的线程，被称为“successor”或“heir presumptive”（假定继承人）线程，successor 线程会去尝试竞争锁。锁竞争队列出队策略，底层由 <code>Knob_QMode</code> 字段控制，策略依次为：
<ul>
<li><strong>出队策略 0</strong>：若 <code>EntryList</code> 非空，取 <code>EntryList</code> 队头线程并唤醒；若 <code>EntryList</code> 空，先将 <code>cxq</code> 全部移到 <code>EntryList</code>，再取 <code>EntryList</code> 队头线程并唤醒（<strong>默认策略</strong>）</li>
<li><strong>出队策略 1</strong>：若 <code>EntryList</code> 非空，取 <code>EntryList</code> 队头线程并唤醒；若 <code>EntryList</code> 空，先将<strong>反转后的</strong> <code>cxq</code> 全部移到 <code>EntryList</code>，再取 <code>EntryList</code> 队头线程并唤醒</li>
<li><strong>出队策略 2</strong>：直接取 <code>cxq</code> 队头线程并唤醒</li>
<li><strong>出队策略 3</strong>：先将 <code>cxq</code> 全部移到 <code>EntryList</code> 尾部，再取 <code>EntryList</code> 队头线程并唤醒</li>
<li><strong>出队策略 4</strong>：先将 <code>cxq</code> 全部移到 <code>EntryList</code> 头部，再取 <code>EntryList</code> 队头线程并唤醒</li>
</ul>
</li>
</ul>
</li>
<li><strong>重量级锁的降级收缩（deflation）的实现源码</strong>：
<ul>
<li>调用<code>ObjectSynchronizer::deflate_idle_monitors()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L1498">synchronizer.cpp</a>）</li>
<li>降级某个 Monitor 调用 <code>ObjectSynchronizer::deflate_monitor(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L1422">synchronizer.cpp</a>）</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--">wait</a>()、java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-">wait</a>(long timeout) 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L515">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析：</strong>
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::wait(..)</code>（参见源码 synchronizer.cpp）</li>
<li>(2) 调用 <code>ObjectMonitor::wait(..)</code>（参见源码 objectMonitor.cpp）
<ul>
<li>将当前线程加入 <code>WaitSet</code> <strong>条件变量等待队列的队尾</strong>，并 <code>ParkEvent::park()</code> 阻塞自己</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--">notify</a>() 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：唤醒在此对象监视器上等待的单个线程。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorNotify(JNIEnv* env, jobject handle)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L526">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析：</strong>
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::notify(..)</code>（参见源码 synchronizer.cpp）</li>
<li>(2) 调用 <code>ObjectMonitor::notify(..)</code>（参见源码 objectMonitor.cpp）
<ul>
<li>将<code>WaitSet</code> 条件变量等待队列的队头的线程选为<strong>被通知线程</strong>（notifyee），然后根据<strong>移动策略</strong>将被通知线程移到 <code>cxq</code> 或 <code>EntryList</code> 锁竞争队列，默认策略是插入到 <code>cxq</code> 到队头。notifyee 线程的移动策略，底层由 <code>Knob_MoveNotifyee</code> 字段控制，策略依次为：
<ul>
<li><strong>移动策略 0</strong>：将被通知线程加到 <code>EntryList</code> 的队头</li>
<li><strong>移动策略 1</strong>：将被通知线程加到 <code>EntryList</code> 的队尾</li>
<li><strong>移动策略 2</strong>：将被通知线程加到 <code>cxq</code> 的队头（<strong>默认策略</strong>）</li>
<li><strong>移动策略 3</strong>：将被通知线程加到 <code>cxq</code> 的队尾</li>
</ul>
</li>
<li>附注：JDK 1.6 之前的版本，<code>notify</code> 的实现逻辑不是将被通知线程（notifyee）移到锁竞争队列，而是直接唤醒 notifyee 线程。JDK 1.6 优化的原因是，由于 Java 实现的是 Mesa 风格的管程，当前持有锁的线程在调用 <code>notify</code> 后，并不会释放锁，不会阻塞自己，而是继续执行，所以<strong>被唤醒的 notifyee 线程并不能立即获取锁，而总是因为获取锁失败而被阻塞</strong>，唤醒 notifyee 线程是无效的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--">notifyAll</a>() 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：唤醒在此对象监视器上等待的所有线程。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorNotifyAll(JNIEnv* env, jobject handle)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L533">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::notifyall(..)</code>（参见源码 synchronizer.cpp）</li>
<li>(2) 调用 <code>ObjectMonitor::notifyAll(..)</code>（参见源码 objectMonitor.cpp）
<ul>
<li>循环将全部<code>WaitSet</code> 条件变量等待队列的线程移到锁竞争队列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="自适应互斥锁">自适应互斥锁</h2>
<p>线程在竞争互斥锁（mutex）失败后的<strong>等待策略</strong>（waiting policy）分为两种：<strong>自旋</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Busy_waiting">spinning</a>）和<strong>阻塞</strong>（blocking）。</p>
<ul>
<li><strong>自旋</strong>（spinning），或叫<strong>自旋等待</strong>（spin-waiting）或<strong>忙等待</strong>（busy waiting）：线程会循环反复测试是否可以获取锁，会一直在 CPU 上运行。在抢占式调度器的操作系统下（目前<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheduling_%28computing%29#Summary">主流操作系统</a>都是抢占式的），在时间片结束后，调度器会将 CPU 调度给其他线程。线程也可以主动<strong>让出</strong>（yield）CPU，在类 Unix 系统下调用 <code>sched_yield()</code> 函数。一些旧的自旋等待的实现会在循环中调用 <code>sched_yield()</code>，不过在 Linux 下不推荐在自旋循环中调用 <code>sched_yield()</code><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。自旋线程的线程状态一直处于 <code>running</code> 或 <code>runnable</code> 状态（<code>runnable</code> 状态，也被叫做 <code>ready</code> 状态）。</li>
<li><strong>阻塞</strong>（blocking），或叫<strong>睡眠等待</strong>（sleep-waiting）或<strong>基于调度器</strong>（scheduler-based）：线程会主动睡眠（阻塞）自己，请求调度器<strong>取消调度</strong>（deschedule）当前线程，让出 CPU 资源給另外一个线程。线程状态将一直处于 <code>sleeping</code> 状态（也叫 <code>waiting</code> 状态），直到被唤醒，被唤醒后状态为 <code>runnable</code>。</li>
</ul>
<p>阻塞线程相对耗时较大，至少需要执行两次线程上下文切换。自旋会浪费 CPU 资源，所以自旋等待的时间应该尽量短，自旋时间最好小于完成两次上下文切换的耗时。单次请求锁的 CAS 原子操作消耗的 CPU 时钟周期数大概是 15 ~ 30，而单次线程上下文切换的总消耗的 CPU 时钟周期数大概是 10,000 ~ 1,000,000，消耗的 CPU 时钟周期数相差约 100 ~ 10000 倍<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。</p>
<p>自旋和阻塞策略存在各自缺点，所以目前很多操作系统内核的互斥锁实现采用<strong>混合策略</strong>，即“spin-then-block”的等待策略，实现的互斥锁称为<strong>自适应互斥锁</strong>（adaptive mutex）。目前 Solaris、Mac OS X 和 FreeBSD 内核实现的互斥锁，默认都是“adaptive mutex”。另外，pthread 线程库也支持创建<strong>自适应类型的 mutex</strong>。</p>
<p>操作系统内核和 pthread 线程库的自适应互斥锁的历史演进：</p>
<ul>
<li>1992.06，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Oracle_Solaris#Version_history">Solaris</a> 2.0 发布，内核实现的 mutex 默认是“adaptive mutex”<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>。</li>
<li>2000.07，glibc 2.2 版本的 pthread 线程库开始支持创建自适应类型的 mutex，相关类型参数是 <code>PTHREAD_MUTEX_ADAPTIVE_NP</code>（参见 <a target="_blank" rel="noopener" href="https://github.com/bminor/glibc/blob/a88b96f496c0214424db1219d21ce669fbc102a0/linuxthreads/ChangeLog">commit</a>）。不过，默认 mutex 类型是 <code>PTHREAD_MUTEX_NORMAL</code>，等待策略是立即阻塞而不是先自旋。</li>
<li>2007.10，FreeBSD 的 pthread 线程库开始支持自适应类型的 mutex，实现 glibc 的 <code>PTHREAD_MUTEX_ADAPTIVE_NP</code> 类型的 mutex（参见 <a target="_blank" rel="noopener" href="https://github.com/freebsd/freebsd-src/commit/2017a7cdfe8f1a0e38b76e8e8871fe90df07b8f7">commit</a>、<a target="_blank" rel="noopener" href="https://github.com/freebsd/freebsd-src/commit/7416cdabcd0c1dd626ff5b7edfcedf11967ff39f">commit</a>）。FreeBSD 的 pthread 线程库，默认 mutex 类型是 <code>PTHREAD_MUTEX_ERRORCHECK</code>，等待策略是立即阻塞而不是先自旋。</li>
<li>2009.11，FreeBSD 8.0 发布，从 FreeBSD 8.0 开始内核实现的 mutex 默认是“adaptive mutex”，实现类似于 Solaris。</li>
</ul>
<p>Solaris 实现的自适应互斥锁的自旋策略是<sup class="footnote-ref"><a href="#fn8" id="fnref8:1">[8:1]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>：当线程试图去获取一个锁且锁已经被占有时，内核检查当前占有该锁的线程的状态。如果锁的持有者正在某一处理器上运行，申请线程就会旋转；如果锁的持有者当前没有运行，申请线程就会阻塞。Solaris 的自旋次数的配置参数是 <code>LIBTHREAD_ADAPTIVE_SPIN</code>，默认值 1000。FreeBSD 实现的自旋策略与 Solaris 类似（参见 locking <a target="_blank" rel="noopener" href="https://man.freebsd.org/cgi/man.cgi?query=locking&amp;manpath=FreeBSD+10.0-RELEASE">man</a>）。</p>
<p>glibc 的 pthread 实现的自适应互斥锁的自旋策略是<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>：每个自适应 mutex 的自旋次数，基于之前的自旋次数在 0 ~ 100 之间动态调整。最大的自旋次数可配置，配置参数是 <code>glibc.pthread.mutex_spin_count</code>，默认值 100（参见 glibc <a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/manual/html_node/POSIX-Thread-Tunables.html">doc</a>）。</p>
<p>FreeBSD 实现的 pthread 线程库的自适应互斥锁的自旋策略是：先执行固定配置次数的自旋循环，然后执行调用 yield 的自旋循环，最后再睡眠等待。自旋次数的配置参数是 <code>LIBPTHREAD_SPINLOOPS</code>，默认值 2000；调用 yield 的自旋循环，默认不开启，调用 yield 的自旋次数的配置参数是 <code>LIBPTHREAD_YIELDLOOPS</code>，默认值 0（参见 libthr <a target="_blank" rel="noopener" href="https://man.freebsd.org/cgi/man.cgi?query=libthr&amp;manpath=FreeBSD+11.0-RELEASE">man</a>）。</p>
<p>HotSpot 的 Monitor 内部的互斥锁实现的历史演进：</p>
<ul>
<li>2000.05，J2SE 1.3 发布，并同时发布 HotSpot 2.0，从这版本的 HotSpot 开始，Monitor 内部的互斥锁（mutex）实现的锁等待策略是“spin-then-block”，即先自旋重试再阻塞，参见 <a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-4256394">JDK-4256394</a>。自旋策略是<strong>固定自旋</strong>（fixed spinning），按固定配置的次数自旋（默认 10 次）。
<ul>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk6.html?s=UseSpinning">UseSpinning</a>，是否自旋，默认关闭；-XX:<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk6.html?s=PreBlockSpin">PreBlockSpin</a>，阻塞前的自旋次数，默认值 10。Java 6 开始，旧的 -XX:+UseSpinning 和 -XX:PreBlockSpin 等自旋 JVM 参数选项不再有效，Java 7 发布后，相关参数被删除。</li>
</ul>
</li>
<li>2006.12，Java 6 发布，HotSpot 的 Monitor 内部的互斥锁实现的锁等待策略改为“adaptive spin-then-block”，自旋策略改为<strong>自适应自旋</strong>（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#adaptiveSpinning">adaptive spinning</a>），自旋次数在 0 ~ 5000 之间动态调整。每个 Monitor 各自独立维护动态自旋次数，当前的自旋次数根据最近的自旋获得锁的成功/失败率动态调整，如果最近的自旋成功率高，说明当前的自旋也很有可能成功，则尝试更多次数的自旋。若成功率低，则减少自旋次数。最大的自旋次数是 5000。
<ul>
<li>底层实现函数为 <code>ObjectMonitor::TrySpin_VaryDuration(..)</code>，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1905">objectMonitor.cpp</a>。</li>
</ul>
</li>
</ul>
<h2 id="park-unpark-同步原语">park-unpark 同步原语</h2>
<p>Hotspot 的 Monitor 同步子系统的实现，除了用于阻塞和唤醒线程的依赖操作系统平台相关的 <strong>park-unpark 抽象</strong>外，尽量避免使用操作系统原生的同步原语（synchronization primitive）。总体上，Monitor 的实现底层只依赖于 <strong>park-unpark 抽象</strong>和<strong>原子操作</strong>。park-unpark 抽象，由 JVM 的 <code>ParkEvent</code> 和 <code>PlatformEvent</code> 类实现，<code>ParkEvent</code> 是 <code>PlatformEvent</code> 的子类，<code>ParkEvent</code> 与操作系统平台无关，<code>PlatformEvent</code> 与操作系统平台相关。<code>ParkEvent</code> 类的实现，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/park.hpp">park.hpp</a> 和 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/park.cpp">park.cpp</a>。<code>PlatformEvent**</code> 类的实现，概括来说：</p>
<ul>
<li><strong>类 Unix 系统</strong>：基于 pthread 的 mutex 互斥锁和条件变量实现。Linux 系统的线程同步底层基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Futex">futex</a> 系统调用，Solaris 系统的线程同步底层基于 <code>lwp_park</code>、<code>lwp_unpark</code> 系统调用。</li>
<li><strong>Windows 系统</strong>：基于 Windows 的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/sync/event-objects">Event 对象</a>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_%28synchronization_primitive%29">wiki</a>）实现。</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L264">objectMonitor.cpp</a> 代码注释</strong>：</p>
<blockquote>
<p>The monitor synchronization subsystem avoids the use of native synchronization primitives except for the narrow platform-specific park-unpark abstraction. See the comments in os_solaris.cpp regarding the semantics of park-unpark. Put another way, this monitor implementation depends only on atomic operations and park-unpark.</p>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L5938">os_solaris.cpp</a> 代码注释</strong>：</p>
<blockquote>
<p><strong>ObjectMonitor park-unpark infrastructure</strong><br>
We implement Solaris and Linux PlatformEvents with the obvious condvar-mutex-flag triple. Another alternative that works quite well is pipes: Each PlatformEvent consists of a pipe-pair. The thread associated with the PlatformEvent calls park(), which reads from the input end of the pipe. Unpark() writes into the other end of the pipe. The write-side of the pipe must be set NDELAY. Unfortunately pipes consume a large # of handles. Native solaris lwp_park() and lwp_unpark() work nicely, too. Using pipes for the 1st few threads might be workable, however.</p>
</blockquote>
<p><strong>park-unpark 同步原语的具体实现</strong>：</p>
<ul>
<li><strong>阻塞线程</strong>：调用 <code>ParkEvent::park()</code> 或 <code>ParkEvent::park(jlong millis)</code>，实际调用与操作系统相关的父类实现的 <code>os::PlatformEvent::park()</code> 或 <code>os::PlatformEvent::park(jlong millis)</code>
<ul>
<li><strong>类 Unix 系统</strong>：通过调用 POSIX 函数 <code>pthread_cond_wait</code> 或 <code>pthread_cond_timedwait</code>（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html">man</a>） 阻塞线程，等待条件是事件数大于等于 0，在阻塞线程前先调用 <code>pthread_mutex_lock</code> 获取 mutex 互斥锁（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5862">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/bsd/vm/os_bsd.cpp#L4426">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L6092">os_solaris.cpp</a>）</li>
<li><strong>Windows 系统</strong>：通过调用函数 <code>WaitForSingleObject</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">doc</a>）阻塞线程（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L4904">os_windows.cpp</a>）</li>
</ul>
</li>
<li><strong>唤醒线程</strong>：调用 <code>ParkEvent::unpark()</code>，实际调用与操作系统相关的父类实现的 <code>os::PlatformEvent::unpark()</code>
<ul>
<li><strong>类 Unix 系统</strong>：将等待条件的事件数设置为 1，然后通过调用 POSIX 函数 <code>pthread_cond_signal</code> 唤醒线程，在唤醒线程前先调用 <code>pthread_mutex_lock</code> 获取 mutex 互斥锁（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5963">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/bsd/vm/os_bsd.cpp#L4426">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L6136">os_solaris.cpp</a>）</li>
<li><strong>Windows 系统</strong>：通过调用函数 <code>SetEvent</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">doc</a>）唤醒线程（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L4949">os_windows.cpp</a>）</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.cjsdn.net/doc/jdk60/java/util/concurrent/locks/LockSupport.html">http://www.cjsdn.net/doc/jdk60/java/util/concurrent/locks/LockSupport.html</a></p>
<h1 id="基于-AQS-线程同步">基于 AQS 线程同步</h1>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>1998，David F. Bacon, etc: <strong>Thin Locks: Featherweight Synchronization for Java</strong>. PLDI 1998: 258-268，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/pldi/BaconKMS98.html">dblp</a>，<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Thin-locks%3A-featherweight-synchronization-for-Java-Bacon-Konuru/07ab0964c6afca7fec1d1a00df9375de2ae26e1e">semanticscholar</a>：作者来自 IBM 研究院，提出瘦锁（Thin Lock）技术 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>1999，Ole Agesen, etc: <strong>An Efficient Meta-Lock for Implementing Ubiquitous Synchronization</strong>. OOPSLA 1999: 207-222，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/AgesenDGKRW99.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/An-efficient-meta-lock-for-implementing-ubiquitous-Agesen-Detlefs/add4082ea2d5eded2f75a6a3f5b7f622a1f8542a">semanticscholar</a>：作者来自 Sun 公司 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2006，Kenneth B. Russell, David Detlefs: <strong>Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing</strong>. OOPSLA 2006: 263-272：<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/RussellD06.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Eliminating-synchronization-related-atomic-with-and-Russell-Detlefs/356a2d9859520c9161d67828d45e758a24ecce20">semanticscholar</a>、<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf">slides</a>：作者来自 Sun 公司，主要阐述 Java 6 的 HotSpot 虚拟机实现的偏向锁，同时也介绍了轻量级锁的实现 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a> <a href="#fnref3:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2002，Kiyokuni Kawachiya, etc: <strong>Lock Reservation: Java Locks can Mostly do without Atomic Operations</strong>. OOPSLA 2002: 130-141，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/KawachiyaKO02.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/reservation%3A-Java-locks-can-mostly-do-without/884749059cae01a003a4f0d9011df3d4ab7dd166">semanticscholar</a>：作者来自 IBM 研究院，提出锁保留（Lock Reservation）技术 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2014，Marcus Larsson: <strong>Evaluating and improving biased locking in the HotSpot virtual machine</strong>. KTH Master Thesis，<a target="_blank" rel="noopener" href="http://www.diva-portal.org/smash/get/diva2:754541/FULLTEXT01.pdf">pdf</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>2003-05 The right way to yield <a target="_blank" rel="noopener" href="https://lwn.net/Articles/31462/">https://lwn.net/Articles/31462/</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2016-09 Infographics: Operation Costs in CPU Clock Cycles <a target="_blank" rel="noopener" href="http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/">http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Joseph R. Eykholt, etc: <strong>Beyond Multiprocessing: Multithreading the SunOS Kernel</strong>. USENIX Summer 1992，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/usenix/EykholtKBFSSVWW92.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Beyond-Multiprocessing%3A-Multithreading-the-SunOS-Eykholt-Kleiman/c087671a641adbbcb01cb6b59d38a9a43e6da4b5">semanticscholar</a>：介绍 Solaris 2.0 内核的多线程技术 <a href="#fnref8" class="footnote-backref">↩︎</a> <a href="#fnref8:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Solaris 内核结构（Solaris Internals），Richard McDougall &amp; Jim Mauro，第2版2006，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/2161545/">豆瓣</a>：第17章 锁和同步，17.5 互斥锁 <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>What is PTHREAD_MUTEX_ADAPTIVE_NP <a target="_blank" rel="noopener" href="https://stackoverflow.com/q/19863734/689699">https://stackoverflow.com/q/19863734/689699</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>nullwy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://nullwy.me/2024/02/java-synchronization-implementation/" title="Java 线程同步实现原理深度解析">https://nullwy.me/2024/02/java-synchronization-implementation/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
              <a href="/tags/%E5%90%8C%E6%AD%A5/" rel="tag"># 同步</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/java-synchronization-implementation.md/" rel="prev" title="Java 线程同步实现原理解析">
      <i class="fa fa-chevron-left"></i> Java 线程同步实现原理解析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">线程管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-synchronized-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">基于 synchronized 线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%92%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">3.1.</span> <span class="nav-text">偏向锁、轻量级锁和重量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7-Monitor-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.</span> <span class="nav-text">重量级 Monitor 的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.3.</span> <span class="nav-text">自适应互斥锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#park-unpark-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="nav-number">3.4.</span> <span class="nav-text">park-unpark 同步原语</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-AQS-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">4.</span> <span class="nav-text">基于 AQS 线程同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nullwy"
      src="https://static.nullwy.me/avatar.png">
  <p class="site-author-name" itemprop="name">nullwy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yulewei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yulewei" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yulewei@gmail.com" title="E-Mail → mailto:yulewei@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://segmentfault.com/u/nullwy" title="SegmentFault → https:&#x2F;&#x2F;segmentfault.com&#x2F;u&#x2F;nullwy" rel="noopener" target="_blank"><i class="fa fa-globe fa-fw"></i>SegmentFault</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/yulewei/" title="豆瓣 → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yulewei&#x2F;" rel="noopener" target="_blank"><i class="fa fa-globe fa-fw"></i>豆瓣</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/3670612013220988" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;3670612013220988" rel="noopener" target="_blank"><i class="fa fa-globe fa-fw"></i>掘金</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian">
    备案号：<a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备17005717号 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nullwy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">380k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:46</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      总访客量
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    总访问量
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yulewei.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://nullwy.me/2024/02/java-synchronization-implementation/";
    this.page.identifier = "2024/02/java-synchronization-implementation/";
    this.page.title = "Java 线程同步实现原理深度解析";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://yulewei.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
