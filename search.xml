<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>亚马逊网站架构演进</title>
    <url>/2023/11/amazon-architecture-evolution/</url>
    <content><![CDATA[<h1 id="SOA-与微服务">SOA 与微服务</h1>
<p>Amazon，1994 年创立，早期网站是单服务、单数据库的单体架构的系统<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，全部代码由 C++ 编写，编译成单个二进制文件，整个代码仓库被命名为 <a href="https://en.wikipedia.org/wiki/Obidos_(software)">Obidos</a>。Obidos 是底层是一个 Web 页面渲染引擎，是一个框架，业务逻辑基于这个框架开发，Obidos 渲染引擎和业务逻辑共同组成整个代码仓库。随着时间的推移，Obidos 变得越来越复杂，编译 Obidos 整个代码库耗时 12 小时，开发调试效率低下<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>。另外，全部业务逻辑在单个二进制文件中，导致紧耦合，新功能特性无法快速发布上线。1995 年，Amazon 网站的技术架构，如下图所示<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>：</p>
<span id="more"></span>
<img width="600" alt="Amazon 网站技术架构（1995）" title="Amazon 网站技术架构（1995）" src="https://static.nullwy.me/amazon-architecture-1995.png">
<p>到 2000 年，为了应对流量增长，解决网站的可扩展性问题，开始拆分 Obidos，向可扩展的 SOA 架构演进。拆分出的服务有，用户服务（customer service）、订单服务（order service）、商品服务（item service）等，并且每个服务都拥有各自独立的数据库。2005 年 1 月，Amazon 网站开始从 Obidos 引擎迁移到 Gurupa 引擎。Gurupa 是一个 Web 页面渲染引擎，同时也是一个 SOA 框架，Gurupa 被用于集成背后的数百个服务，使用 Perl 的 Mason 模板将各个服务响应的数据渲染成 Web 页面。到 2006 年完成了到 Gurupa 的全部迁移<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。</p>
<p>Amazon 网站技术架构演进过程，如下图所示<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">[2:2]</a></sup>：</p>
<img width="600" alt="Amazon 网站技术架构演进" title="Amazon 网站技术架构演进" src="https://static.nullwy.me/amazon-architecture-evolution.png">
<p>需要注意的是，图中认为从 2006 年开始 Amazon 网站架构从 SOA 演进为微服务，但是事实上，“微服务”这个术语诞生的时间是 2012 年。2006 年的架构实现与之前的 SOA 架构实现的不同点是，开始更细粒度的服务拆分。</p>
<p>本质上来看，微服务架构是一种特殊的 SOA 架构，在“微服务”术语诞生之前，亚马逊的 SOA 架构实现被认为是“SOA done right”（正确实现的 SOA）<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。Netflix 的 SOA 架构实现也在“微服务”术语诞生之前，Netflix 认为自己实现架构的是“fine-grained SOA”（细粒度的 SOA）<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。James Lewis 和 Martin Fowler 等人是“微服务”概念的早期提倡者，他们将亚马逊和 Netflix 的 SOA 架构实现归类为微服务的经典案例<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。所以，SOA 和微服务的关系可以简单理解为，微服务是“fine-grained SOA”或“SOA done right”。</p>
<p>根据 Martin Fowler 的解释<sup class="footnote-ref"><a href="#fn7" id="fnref7:1">[7:1]</a></sup><sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>，SOA 与微服务的关系，如下图所示：</p>
<img width="400" alt="SOA 与微服务的关系" title="SOA 与微服务的关系" src="https://static.nullwy.me/soa-vs-microservices.svg">
<p>在 SOA 架构的具体实践上，根据前亚马逊工程师 Steve Yegge 的 2011 年的文章<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>，在 2002 年左右，亚马逊创始人兼 CEO Jeff Bezos 向全公司发布了一道指令（这个指令被外界称为“API Mandate”），具体内容如下：</p>
<blockquote>
<ol>
<li>从今天起，所有的团队都要以服务接口的方式提供数据和各种功能。</li>
<li>团队之间必须通过接口来通信。</li>
<li>不允许任何其他形式的互操作：不允许直接链接，不允许直接读其他团队的数据，不允许共享内存，不允许任何形式的后门。唯一许可的通信方式就是通过网络调用服务。</li>
<li>至于具体的技术则不做规定。HTTP、Corba、Pubsub、自定义协议都可以。贝索斯不关心这个。</li>
<li>所有的服务接口，必须从一开始就要以可以公开为设计导向，没有例外。这就是说，团队必须在设计的时候就计划好，接口要可以对外面的开发人员开放。没有讨价还价的余地。</li>
<li>不听话的人会被炒鱿鱼。</li>
</ol>
</blockquote>
<h1 id="技术栈演进">技术栈演进</h1>
<p>Amazon 网站的技术栈演进过程<sup class="footnote-ref"><a href="#fn2" id="fnref2:3">[2:3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup><sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>：</p>
<ul>
<li>1995 ~ 2000：单体架构，Unix（Sun）、Obidos、Oracle、C++
<ul>
<li>Obidos 是亚马逊内部 Web 动态页面渲染引擎，编程语言是 C++。</li>
</ul>
</li>
<li>2000 ~ 2006：SOA 架构，Linux、Obidos、Oracle、C++
<ul>
<li>2000 年，将 Sun/Unix 服务器替换为 HP/Linux 服务器<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>。</li>
<li>2000 年，拆分应用服务，向 SOA 架构演进。</li>
<li>2005 年初，开始将 Obidos 框架替换为 Gurupa 框架，Gurupa 是 Web 页面渲染引擎，同时也是 SOA 框架。Web 动态页面的编程语言从 C++ 替换为 Perl/Mason，同时应用服务开始被更细粒度的拆分。</li>
</ul>
</li>
<li>2006 年开始：微服务架构，Linux、Gurupa、Oracle、Perl &amp; Java &amp; C++
<ul>
<li>2019.10，彻底去掉 Oracle 数据库，迁移到 Amazon RDS 和 NoSQL<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>。</li>
</ul>
</li>
</ul>
<p>当前 Amazon 网站的主要技术栈：</p>
<ul>
<li><strong>应用服务</strong><sup class="footnote-ref"><a href="#fn4" id="fnref4:2">[4:2]</a></sup><sup class="footnote-ref"><a href="#fn11" id="fnref11:1">[11:1]</a></sup>：
<ul>
<li><strong>展示层</strong>：Perl/Mason<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup></li>
<li><strong>业务逻辑层</strong>：Java（主要）、C++ 等</li>
<li><strong>RPC框架</strong>：Gurupa 框架（自研闭源）
<ul>
<li>2006 年更早之前使用 <a href="https://en.wikipedia.org/wiki/Obidos_%28software%29">Obidos</a> 框架</li>
</ul>
</li>
<li><strong>消息队列MQ</strong>：<a href="https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service">Amazon SQS</a></li>
</ul>
</li>
<li><strong>数据存储</strong><sup class="footnote-ref"><a href="#fn13" id="fnref13:1">[13:1]</a></sup>：
<ul>
<li><strong>关系数据库</strong>：Amazon RDS for PostgreSQL<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>、Amazon Aurora (PostgreSQL)
<ul>
<li>2019 年 10 月彻底去掉 Oracle 数据库，迁移到 Amazon RDS 和 NoSQL。</li>
</ul>
</li>
<li><strong>键值存储</strong>：<a href="https://en.wikipedia.org/wiki/Amazon_DynamoDB">Amazon DynamoDB</a></li>
<li><strong>缓存</strong>：Amazon ElastiCache for Redis<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup></li>
<li><strong>Blob文件存储</strong>：<a href="https://en.wikipedia.org/wiki/Amazon_S3">Amazon S3</a></li>
</ul>
</li>
</ul>
<h1 id="AWS-的诞生">AWS 的诞生</h1>
<p>Amazon 网站架构演进的过程，伴随着 AWS 云服务的诞生，促使 AWS 云服务诞生的因素主要有<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>：</p>
<ul>
<li><strong>技术价值</strong>：Amazon 网站在向可扩展架构演进的过程中，其基础设施团队开始善于运营像计算、存储和数据库这样的基础设施，团队已经变得能非常熟练地运营可靠的、可扩展的、具有成本效益的数据中心，这些专业能力推动了亚马逊电商平台的发展。将维护可靠、可扩展的基础设施专业能力通过服务的方式对外交付，能有效节省第三方企业或初创公司的成本，当时亚马逊预计基础设施的成本可能会从 70% 降低至 30% 或更低<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>。</li>
<li><strong>原始动机</strong>：Amazon 网站的流量有很强的季节性，每年 11 月和 12 月（尤其是在<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E8%89%B2%E6%98%9F%E6%9C%9F%E4%BA%94_(%E8%B4%AD%E7%89%A9)">感恩节</a>和圣诞节前后）流量都会飙升。为了应对购物季，不得不扩容，增加服务器资源。在购物季结束后，服务器资源被大量闲置。零售电商的利润很薄，却要面对数据中心基础设施不断扩展所带来的成本压力。所以，很多人（包括部分亚马逊员工）<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup><sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>认为推出 AWS 产品的一个重要原因是为了出租 SOA 网站在销售淡季时的过剩服务器容量。不过，出租过剩容量的故事是一个神话，因为不可能在每年购物季时把开发商从服务器里踢出去，而且实际上在推出 EC2 云服务后的 2 个月内，AWS 就已经烧掉了过剩的 Amazon 网站容量<sup class="footnote-ref"><a href="#fn19" id="fnref19:1">[19:1]</a></sup>。</li>
<li><strong>商业理念</strong>：<a href="https://en.wikipedia.org/wiki/Jeff_Bezos">Jeff Bezos</a>，将亚马逊定位为一家技术公司，而不仅仅是一家在线零售商，所以在亚马逊的核心业务之外进行很多投资尝试，AWS 产品就是其中之一<sup class="footnote-ref"><a href="#fn17" id="fnref17:1">[17:1]</a></sup>。</li>
</ul>
<p>于是，在 2003 年亚马逊团队内部逐渐开始形成销售基础设施服务的设想。2003 年 9 月<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>，<a href="https://en.wikipedia.org/wiki/Andy_Jassy">Andy Jassy</a> 写了 6 页纸的关于 AWS 的愿景文档（vision document）并提交给管理团队，愿景文档中提议了设想的 AWS 业务，并概述了 AWS 提供的初始的基础设施服务集，首批提供的服务包括存储、计算和数据库等。同年，Jassy 组建了由 57 人组成的 AWS 团队，AWS 团队的 CEO 由 Jassy 担任（Jassy 担任 AWS CEO 一直到 2021 年，2021 年 7 月开始任职亚马逊 CEO）。<strong>三年之后，2006 年 3 月 AWS 对外发布 S3 云存储，8 月对外发布 EC2 弹性云计算服务器，S3 和 EC2 是行业内最早的云服务产品</strong>。S3 发布的刚开始几个月，并没有引起太大的关注。EC2 发布后，大量开发商开始飞速涌入。在没有其他类似云服务产品最初几年，几乎每一家创业公司都在亚马逊的服务器上构建自己的系统。能吸引大量开发商的原因主要是，按需使用和收费的商业模式，以及亚马逊故意压力利润的价格策略<sup class="footnote-ref"><a href="#fn17" id="fnref17:2">[17:2]</a></sup>。</p>
<h1 id="迁移到-AWS">迁移到 AWS</h1>
<p>2011 年 11 月，Amazon 网站全部都迁移到了 AWS 云服务器上<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>。迁移到 AWS 上最大的动机是能利用  AWS 云服务器的弹性伸缩能力，从而节省成本。如果没有弹性伸缩能力，在淡季时，总体上服务器资源容量的利用率是 61%，无法有效利用的容量是 39%，到购物季的 11 月，无法有效利用的容量高到 76%。引入弹性伸缩技术后，可以按网站的实际流量负载情况，供应恰当的容量，避免资源浪费。Amazon 网站在淡季和购物季时的静态伸缩与弹性伸缩，如下图所示<sup class="footnote-ref"><a href="#fn23" id="fnref23:1">[23:1]</a></sup><sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>。</p>
<img width="600" alt="Amazon 网站的典型的周流量分布" title="Amazon 网站的典型的周流量分布" src="https://static.nullwy.me/amazon-typical-weekly-traffic.png">
<img width="600" alt="Amazon 网站的静态伸缩" title="Amazon 网站的静态伸缩" src="https://static.nullwy.me/amazon-november-traffic-static-scaling.png">
<img width="600" alt="Amazon 网站的弹性伸缩" title="Amazon 网站的弹性伸缩" src="https://static.nullwy.me/amazon-november-traffic-elastic-scaling.png">
<p>类似的，阿里淘宝、天猫电商系统，为了应对双 11 大促，2015 年开始采用混合云弹性架构，即专有云+公共云，当本地保有云无法支撑时，就快速在公有云上扩容，当流量过去后，再还资源给公有云。2019 年双 11，阿里电商的全部核心应用迁移到公共云，到 2021 年双 11，阿里电商系统实现了 100% 上公共云<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>2006-05 ACM Queue Interview: A Conversation with Amazon CTO Werner Vogels <a href="https://queue.acm.org/detail.cfm?id=1142065">https://queue.acm.org/detail.cfm?id=1142065</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>2021-02 Amazon’s architecture evolution and AWS strategy (AWS re:Invent 2020) <a href="https://www.youtube.com/watch?v=HtWKZSLLYTE">https://www.youtube.com/watch?v=HtWKZSLLYTE</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a> <a href="#fnref2:3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2022-11 Reliable scalability: How Amazon scales in the cloud (AWS re:Invent 2022) <a href="https://www.youtube.com/watch?v=_AhfV5LZmvo">https://www.youtube.com/watch?v=_AhfV5LZmvo</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2011-04 Charlie Cheever: How did Google, Amazon, and the like initially develop and code their websites, databases, etc.? <a href="https://qr.ae/pKKyB0">https://qr.ae/pKKyB0</a> <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a> <a href="#fnref4:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2007-06 SOA done right: the Amazon strategy <a href="https://www.zdnet.com/article/soa-done-right-the-amazon-strategy/">https://www.zdnet.com/article/soa-done-right-the-amazon-strategy/</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>2011-05 How the cloud helps Netflix (interview Adrian Cockcroft) <a href="http://radar.oreilly.com/2011/05/netflix-cloud.html">http://radar.oreilly.com/2011/05/netflix-cloud.html</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2014-03 James Lewis &amp; Martin Fowler: Microservices <a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a> <a href="#fnref7" class="footnote-backref">↩︎</a> <a href="#fnref7:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>2014-11 Microservices • Martin Fowler • GOTO 2014 <a href="https://youtu.be/wgdBVIX9ifA?t=880">https://youtu.be/wgdBVIX9ifA?t=880</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>2011-10 Steve's Google Platform rant <a href="https://gist.github.com/chitchcock/1281611">https://gist.github.com/chitchcock/1281611</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>2016-09 亚马逊如何变成 SOA（面向服务的架构）？（摘录自Steve Yegg的《程序员的呐喊》） <a href="https://www.ruanyifeng.com/blog/2016/09/how_amazon_take_soa.html">https://www.ruanyifeng.com/blog/2016/09/how_amazon_take_soa.html</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>What programming languages are used at Amazon? <a href="https://qr.ae/pKFwnw">https://qr.ae/pKFwnw</a> <a href="#fnref11" class="footnote-backref">↩︎</a> <a href="#fnref11:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>2001-10 How Linux saved Amazon millions <a href="https://web.archive.org/web/0/http://news.com.com/2100-1001-275155.html">https://web.archive.org/web/0/http://news.com.com/2100-1001-275155.html</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>2019-10 Migration Complete – Amazon’s Consumer Business Just Turned off its Final Oracle Database <a href="https://aws.Amazon/blogs/aws/migration-complete-amazons-consumer-business-just-turned-off-its-final-oracle-database/?nc1=h_ls">https://aws.Amazon/blogs/aws/migration-complete-amazons-consumer-business-just-turned-off-its-final-oracle-database/?nc1=h_ls</a> <a href="#fnref13" class="footnote-backref">↩︎</a> <a href="#fnref13:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>2016-04 Is Amazon still using Perl Mason to render its content? <a href="https://qr.ae/pKFwFm">https://qr.ae/pKFwFm</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Amazon RDS for PostgreSQL customers <a href="https://aws.Amazon/rds/postgresql/customers/?nc1=h_ls">https://aws.Amazon/rds/postgresql/customers/?nc1=h_ls</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Amazon ElastiCache for Redis customers <a href="https://aws.Amazon/elasticache/redis/customers/?nc1=h_ls">https://aws.Amazon/elasticache/redis/customers/?nc1=h_ls</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>一网打尽：贝佐斯与亚马逊时代，Brad Stone，2013，<a href="https://book.douban.com/subject/25766700/">豆瓣</a>：第7章 一家技术公司，而非零售商 <a href="#fnref17" class="footnote-backref">↩︎</a> <a href="#fnref17:1" class="footnote-backref">↩︎</a> <a href="#fnref17:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2016-07 AWS CEO Andy Jassy: How AWS came to be <a href="https://techcrunch.com/2016/07/02/andy-jassys-brief-history-of-the-genesis-of-aws/">https://techcrunch.com/2016/07/02/andy-jassys-brief-history-of-the-genesis-of-aws/</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>2011-01 Amazon CTO Werner Vogels: How and why did Amazon get into the cloud computing business? <a href="https://qr.ae/pKscWd">https://qr.ae/pKscWd</a> <a href="#fnref19" class="footnote-backref">↩︎</a> <a href="#fnref19:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>2016-07 前亚马逊员工在 Reddit 上对文章“How AWS came to be”的评论 <a href="https://www.reddit.com/r/programming/comments/4qxthq/comment/d4wrnk7/">https://www.reddit.com/r/programming/comments/4qxthq/comment/d4wrnk7/</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>2021-01 前亚马逊员工 Dan Rose：全球最大云厂商AWS是如何诞生的？ <a href="https://mp.weixin.qq.com/s/C7Mqeh1hyT6k5BQOzpWL9w">https://mp.weixin.qq.com/s/C7Mqeh1hyT6k5BQOzpWL9w</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>2013-11 Andy Jassy's Book Review of &quot;The Everything Store&quot; <a href="https://www.Amazon/review/R1Q4CQQV1ALSN0/">https://www.Amazon/review/R1Q4CQQV1ALSN0/</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>2011-07 2011 AWS Tour Australia, Closing Keynote: How Amazon migrated to AWS, by Jon Jenkins <a href="https://www.slideshare.net/AmazonWebServices/2011-aws-tour-australia-closing-keynote-how-amazoncom-migrated-to-aws-by-jon-jenkins">https://www.slideshare.net/AmazonWebServices/2011-aws-tour-australia-closing-keynote-how-amazoncom-migrated-to-aws-by-jon-jenkins</a> <a href="#fnref23" class="footnote-backref">↩︎</a> <a href="#fnref23:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>2017-03 AWS: Elasticity and Management <a href="https://www.slideshare.net/AmazonWebServices/elasticity-and-management">https://www.slideshare.net/AmazonWebServices/elasticity-and-management</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>2021-11 2021天猫双11：首个100%的云上双11，体验如丝般顺滑 <a href="https://www.sohu.com/a/500431383_114930">https://www.sohu.com/a/500431383_114930</a> <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>可扩展性</tag>
        <tag>技术栈</tag>
        <tag>微服务</tag>
        <tag>SOA</tag>
        <tag>分布式</tag>
        <tag>可伸缩性</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库书籍资料整理</title>
    <url>/2016/11/database-books/</url>
    <content><![CDATA[<p>本文整理一些经典的数据库教材以及MySQL相关书籍。</p>
<span id="more"></span>
<p><a href="http://en.wikipedia.org/wiki/Database">http://en.wikipedia.org/wiki/Database</a><br>
<a href="http://en.wikipedia.org/wiki/Template:Databases">http://en.wikipedia.org/wiki/Template:Databases</a><br>
<a href="http://en.wikipedia.org/wiki/Template:SQL">http://en.wikipedia.org/wiki/Template:SQL</a></p>
<p>Ask HN: Help me find a good databases textbook <a href="https://news.ycombinator.com/item?id=377669">https://news.ycombinator.com/item?id=377669</a><br>
Database Internals - Where to Begin? <a href="http://stackoverflow.com/q/770273">http://stackoverflow.com/q/770273</a><br>
Ask HN: good book or resources to get my SQL skills to the next level <a href="https://news.ycombinator.com/item?id=1370721">https://news.ycombinator.com/item?id=1370721</a><br>
Ask HN: Is there a K&amp;R for SQL? <a href="https://news.ycombinator.com/item?id=5087439">https://news.ycombinator.com/item?id=5087439</a><br>
Tips for getting started with SQL? <a href="http://stackoverflow.com/q/110124">http://stackoverflow.com/q/110124</a></p>
<h1 id="教材原理类书籍">教材原理类书籍</h1>
<ol>
<li>1986-2010，Silberschatz，《<strong>数据库系统概念</strong>》（Database System Concepts, 1st 1986, <a href="http://www.amazon.com/Database-System-Concepts-Abraham-Silberschatz/dp/0073523321">6th</a> 2010），<a href="http://codex.cs.yale.edu/avi/db-book/">home</a>，<a href="http://book.douban.com/subject/10548379/">豆瓣</a>：对数据库<strong>理论、概念</strong>有很清晰地介绍</li>
<li>1996、1999、2002，<a href="http://en.wikipedia.org/wiki/Raghu_Ramakrishnan">Ramakrishnan</a> &amp; <a href="http://en.wikipedia.org/wiki/Johannes_Gehrke">Gehrke</a>，《<strong>数据库管理系统：原理与设计</strong> Cow Book》（Database Management Systems, <a href="http://www.amazon.com/Database-Management-Systems-3rd-Edition/dp/0072465638">3rd</a> 2002），<a href="http://pages.cs.wisc.edu/%7Edbbook/">home</a>，<a href="http://book.douban.com/subject/1155934/">豆瓣</a>：第1作者2006年-2012年为Yahoo首席科学家，2012年跳槽到微软，该书为伯克利CS186、MIT、CMU教材</li>
<li>2006、2010，Elmasri &amp; Navathe，《<strong>数据库系统基础</strong>》（Fundamentals of Database Systems, 6th <a href="http://www.amazon.com/Fundamentals-Database-Systems-6th-Edition/dp/0136086209">2010</a>），<a href="http://www.ituring.com.cn/book/556">图灵2007</a>，第6版<a href="http://book.douban.com/subject/6938465/">豆瓣</a></li>
<li>2005，<a href="http://en.wikipedia.org/wiki/Joseph_M._Hellerstein">Hellerstein</a> &amp; <a href="http://en.wikipedia.org/wiki/Michael_Stonebraker">Stonebraker</a>，&quot;<strong>Readings in Database Systems</strong>&quot;, 3th 1998, 4th 2005，<a href="http://mitpress.mit.edu/books/readings-database-systems">MITpress</a>，<a href="http://redbook.cs.berkeley.edu/">home</a>：被称为“Red Book”，经典论文收录集，第1作者是<strong>Berkeley</strong> Database Group的leader，第2作者是Ingres之父，Hellerstein的博士导师之一</li>
<li>1975-2003，<a href="http://en.wikipedia.org/wiki/Christopher_J._Date">C. J. Date</a><br>
，《<strong>数据库系统导论</strong>》（An Introduction to Database Systems, 2nd 1977, 8th<br>
<a href="http://www.amazon.com/Introduction-Database-Systems-8th-Edition/dp/0321197844">2003</a>），<a href="http://book.douban.com/subject/2179813/">豆瓣</a>：作者曾在IBM工作，该书是<strong>最早</strong>的数据库教材</li>
<li>1999、2008，<a href="http://en.wikipedia.org/wiki/H%C3%A9ctor_Garc%C3%ADa-Molina">Garcia-Molina</a> &amp; <a href="http://en.wikipedia.org/wiki/Jeffrey_Ullman">Ullman</a> &amp; <a href="http://en.wikipedia.org/wiki/Jennifer_Widom">Widom</a>，《数据库系统全书 DSCB》（Database Systems: The Complete Book, 2nd 2008），<a href="http://infolab.stanford.edu/%7Eullman/dscb.html">home</a>，<a href="http://book.douban.com/subject/1137262/">豆瓣</a>：内容偏向介绍数据库的底层实现原理，三位作者来自Stanford，并且均获得Codd奖，获奖年份依次为1999年、2006年、2007年</li>
<li>1992，<a href="http://en.wikipedia.org/wiki/Jim_Gray_%28computer_scientist%29">Jim Gray</a>，《<strong>事务处理：概念与技术</strong>》（Transaction Processing: Concepts and Techniques, <a href="http://amzn.com/1558601902">amazon</a>）：介绍事务经典之作，不过略微过时。作者1998年图灵奖，1993年第2届Codd奖得主</li>
<li>1997、2009，<a href="http://en.wikipedia.org/wiki/Phil_Bernstein">Bernstein</a> &amp; Newcomer，《<strong>事务处理原理</strong>》（Principles of Transaction Processing, <a href="http://www.amazon.com/Principles-Transaction-Processing-Kaufmann-Management/dp/1558606238">2nd</a> 2009），<a href="http://book.douban.com/subject/5412835/">豆瓣</a>：目前最新、全面的书籍。作者来自Microsoft研究院，1994年第3届Codd奖得主</li>
<li>1999、2011，<a href="https://cs.uwaterloo.ca/%7Etozsu/">M. Tamer Ozsu</a>，《<strong>分布式数据库系统原理</strong>》（Principles of Distributed Database Systems, <a href="http://www.amazon.com/Principles-Distributed-Database-Systems-Tamer/dp/1441988335">3rd</a> 2011），<a href="http://book.douban.com/subject/1099408/">豆瓣</a></li>
</ol>
<h1 id="SQL相关书籍">SQL相关书籍</h1>
<ol>
<li>2010，《SQL反模式》（SQL Antipatterns），<a href="http://book.douban.com/subject/6800774/">豆瓣</a></li>
<li>2009，《SQL学习指南》（Learning SQL），<a href="http://book.douban.com/subject/4872454/">豆瓣</a></li>
<li>1999-2008，《<strong>SQL技术手册</strong>》（SQL in a Nutshell, 2nd 2004, <a href="http://www.amazon.com/SQL-Nutshell-In-OReilly/dp/B00CVDS62S">3rd</a> 2008），<a href="http://book.douban.com/subject/4115916/">豆瓣</a>：根据SQL2003 ANSI标准，同时涵盖MySQL、Oracle、PostgreSQL及SQL Server</li>
<li>1995-2010，<a href="http://en.wikipedia.org/wiki/Joe_Celko">Joe Celko</a>，《<strong>SQL权威指南</strong>》（Joe Celko's SQL for Smarties: Advanced SQL Programming, <a href="http://amzn.com/1558603239">1st</a> 1995, <a href="http://amzn.com/0123820227">4th</a> 2010），<a href="http://www.ituring.com.cn/book/969">图灵2012</a>，<a href="http://book.douban.com/subject/20395440/">豆瓣</a>：全书652页，作者曾担任ANSl SQL标准委员会成员达10年之久，参与了SQL-89和SQL-92标准的制定</li>
<li>2005，<a href="http://en.wikipedia.org/wiki/Joe_Celko">Joe Celko</a>，《SQL编程风格》（Joe Celko's SQL Programming Style, <a href="http://amzn.com/0120887975">amazon</a>）<a href="http://www.ituring.com.cn/book/434">，图灵2008</a>，<a href="http://book.douban.com/subject/3208673/">豆瓣</a></li>
<li>1996、2002，<a href="http://en.wikipedia.org/wiki/Joe_Celko">Joe Celko</a>，《SQL解惑》（Joe Celko's SQL Puzzles and Answers, <a href="http://amzn.com/0123735963">2nd</a> 2002），<a href="http://www.ituring.com.cn/book/489">图灵2008</a></li>
<li>2005，Ben Forta，《MySQL必知必会》（MySQL Crash Course），<a href="http://www.forta.com/books/0672327120/">home</a>，<a href="http://book.douban.com/subject/3354490/">豆瓣</a></li>
</ol>
<h1 id="MySQL书籍">MySQL书籍</h1>
<p><a href="http://en.wikipedia.org/wiki/Template:MySQL">http://en.wikipedia.org/wiki/Template:MySQL</a><br>
<a href="https://github.com/shlomi-noach/awesome-mysql">https://github.com/shlomi-noach/awesome-mysql</a><br>
<a href="http://en.wikipedia.org/wiki/Database_engine">http://en.wikipedia.org/wiki/Database_engine</a><br>
2014-01 Any recommended MySQL books for more advanced stuff? (self.mysql) <a href="http://redd.it/292u19">http://redd.it/292u19</a><br>
What resources exist for Database performance-tuning? <a href="http://stackoverflow.com/q/761204">http://stackoverflow.com/q/761204</a><br>
2010-12 12 Best MySQL Database Books for Your Library <a href="http://www.thegeekstuff.com/2010/12/12-best-mysql-books/">http://www.thegeekstuff.com/2010/12/12-best-mysql-books/</a></p>
<h2 id="MySQL管理">MySQL管理</h2>
<ol>
<li>2008、2013，《深入浅出MySQL数据库：开发优化与管理维护》，<a href="http://book.douban.com/subject/25817684/">豆瓣</a>：作者来自网易DBA小组</li>
<li>2005、2008，《MySQL核心技术手册》（MySQL in a Nutshell, <a href="http://www.amazon.com/MYSQL-Nutshell-In-OReilly/dp/B00CVDWK70">2nd</a> 2008），<a href="http://book.douban.com/subject/4116793/">豆瓣</a>：作者MySQL公司知识库编辑</li>
<li>1999-2013，<a href="http://www.oreilly.com/pub/au/330">Paul DuBois</a>，《MySQL技术内幕》（MySQL: Developer's Library, <a href="http://www.amazon.com/MySQL-Developers-Library-Paul-DuBois/dp/0735712123">2nd</a> 2003, <a href="http://amzn.com/0321833872">5th</a> 2013），第4版2008<a href="http://book.douban.com/subject/6524185/">豆瓣</a>，第5版<a href="http://book.douban.com/subject/26436525/">豆瓣</a>：全书886页，作者是“MySQL参考手册”（MySQL Reference Manual）的主要贡献者之一，其他书“MySQL Cookbook”（<a href="http://book.douban.com/subject/3045359/">豆瓣</a>）</li>
<li>2002、2007、2014，<a href="http://www.oreilly.com/pub/au/330">Paul DuBois</a>，《MySQL Cookbook 中文版》，<a href="http://amzn.com/1449374026">3rd</a> 2014，第2版<a href="http://book.douban.com/subject/3045359/">豆瓣</a>：全书948页</li>
</ol>
<h2 id="MySQL调优">MySQL调优</h2>
<ol>
<li>2011，《<strong>Effective MySQL之SQL语句最优化</strong>》（Effective MySQL Optimizing SQL Statements, <a href="http://www.amazon.com/Effective-MySQL-Optimizing-Statements-Oracle/dp/0071782796">amazon</a>），<a href="http://book.douban.com/subject/20438822/">豆瓣</a></li>
<li>2009，简朝阳，《<strong>MySQL性能调优与架构设计</strong>》，<a href="http://book.douban.com/subject/3729677/">豆瓣</a>：作者目前就职于阿里巴巴</li>
<li>2012，Sevta Smirnova，《MySQL排错指南》（MySQL Troubleshooting），<a href="http://book.douban.com/subject/26591051/">豆瓣</a>：Oracle公司MySQL部门bug分析支持团队的首席技术支持工程师</li>
<li>2014，李海翔，《<strong>数据库查询优化器的艺术</strong>》，<a href="http://book.douban.com/subject/25815707/">豆瓣</a>：作者现任职于Oracle公司MySQL全球开发团队，从事查询优化技术的研究和MySQL查询优化器的开发工作</li>
<li>2014，贺春旸，《Mysql管理之道：性能调优、高可用与监控》，<a href="http://book.douban.com/subject/25801248/">豆瓣</a></li>
<li>2004、2008、2012，<a href="http://en.wikipedia.org/wiki/Baron_Schwartz">Schwartz</a> &amp; <a href="http://www.mysqlperformanceblog.com/author/admin/">Zaitsev</a> &amp; Tkachenko，《<strong>高性能MySQL：优化，备份，复制</strong>》（High Performance MySQL, <a href="http://amzn.com/1449314287">3rd</a> 2012），<a href="http://www.highperfmysql.com/">home</a>，<a href="http://book.douban.com/subject/23008813/">豆瓣</a>：深入MySQL类top1书籍，第2作者和第3作者来自MySQL AB公司高性能开发组，2006年创办Percona公司</li>
<li>2010，Charles Bell &amp; Kindahl &amp; Thalmann，《<strong>高可用MySQL：构建健壮的数据中心</strong>》（MySQL High Availability, <a href="http://amzn.com/0596807309">amazon</a>），<a href="http://book.douban.com/subject/6847455/">豆瓣</a>，第2版<a href="http://book.douban.com/subject/26630834/">豆瓣</a>：3位作者全部来自MySQL复制和备份小组，是复制、备份方面的开发人员及专家</li>
</ol>
<h2 id="MySQL源码架构">MySQL源码架构</h2>
<ol>
<li>2010、2013，<a href="http://www.innomysql.net/about">姜承尧</a>，《MySQL技术内幕：InnoDB》，第2版<a href="http://book.douban.com/subject/24708143/">豆瓣</a>：2011至今，网易杭州研究院，数据库技术组 技术经理</li>
<li>2007、2012，<a href="https://www.apress.com/index.php/author/author/view/id/3873">Charles Bell</a>，《<strong>深入理解MySQL</strong>》（Expert MySQL, <a href="http://www.amazon.com/Expert-MySQL-Experts-Voice-Source/dp/1590597419">2nd</a> 2012），<a href="http://www.ituring.com.cn/book/224">图灵2009</a>，<a href="http://book.douban.com/subject/4188364/">豆瓣</a>：全书466页，MySQL源代码分析，作者是MySQL核心开发人员</li>
<li>2007，<a href="http://www.oreilly.com/pub/au/2761">Sasha Pachev</a>，《<strong>深入理解MySQL核心技术</strong>》（Understanding MySQL Internals, <a href="http://www.amazon.com/Understanding-MySQL-Internals-Sasha-Pachev/dp/0596009577">amazon</a>），<a href="http://book.douban.com/subject/4022870/">豆瓣</a>：全书246页，纯粹的MySQL源代码分析，作者是前MysQL开发团队成员</li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>书籍</tag>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastic Stack 日志分析平台搭建笔记</title>
    <url>/2019/01/elastic-stack/</url>
    <content><![CDATA[<p>Elastic Stack（旧称 ELK Stack）是最受欢迎的开源日志平台 [ <a href="https://www.elastic.co/cn/solutions/logging">ref</a> ]。Elastic Stack 由 Elasticsearch、Logstash、Kibana 和 Beats 四个组件组成：</p>
<ul>
<li><a href="https://www.elastic.co/cn/products/beats">Beats</a>，是轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据。</li>
<li><a href="https://www.elastic.co/cn/products/logstash">Logstash</a>，集中、转换和存储数据，是动态数据收集管道，拥有可扩展的插件生态系统，能够与 Elasticsearch 产生强大的协同作用。</li>
<li><a href="https://www.elastic.co/cn/products/elasticsearch">Elasticsearch</a>，搜索、分析和存储您的数据，是基于 JSON 的分布式搜索和分析引擎，专为实现水平扩展、高可靠性和管理便捷性而设计。</li>
<li><a href="https://www.elastic.co/cn/products/kibana">Kibana</a>，实现数据可视化，导览 Elastic Stack。能够以图表的形式呈现数据，并且具有可扩展的用户界面，供您全方位配置和管理 Elastic Stack。</li>
</ul>
<span id="more"></span>
<p>Elastic Stack 是逐步发展而来的，一开始只有 Elasticsearch，专注做搜索引擎，2013 年 1 月 Kibana 及其作者 Rashid Khan <a href="https://www.elastic.co/blog/welcome-drew-rashid">加入</a> Elasticsearch 公司，同年 8 月 Logstash 及作者 Jordan Sissel 也<a href="https://www.elastic.co/blog/welcome-jordan-logstash">加入</a>，原本的非官方的 ELK Stack，正式成为官方用语。2015 年 3 月，旧金山举行的第 1 届 Elastic{ON} 大会上，Elasticsearch 公司改名为 Elastic。两个月后，Packetbeat 项目也<a href="https://www.elastic.co/blog/welcome-packetbeat-tudor-monica">加入</a> Elastic，Packetbeat 和 Filebeat（之前叫做 <a href="https://github.com/elastic/logstash-forwarder">Logstash-forwarder</a>，由 Logstash 作者 Jordan Sissel 开发）项目被整合改造为 Beats。加上 Beats 以后，官方不知道如何将 “B” 和 E-L-K 组合在一起（用过 ELKB 或 BELK），ELK Stack 于是改名为 Elastic Stack，并在 2016 年 10 月正式发布 Elastic Stack 5.0 [ <a href="https://www.elastic.co/cn/about/history-of-elasticsearch">ref1</a>, <a href="https://www.elastic.co/elk-stack">ref2</a>, <a href="https://www.elastic.co/cn/blog/elastic-stack-5-0-0-released">ref3</a> ]。</p>
<h1 id="使用-Logstash">使用 Logstash</h1>
<p>Logstash（<a href="https://www.elastic.co/cn/products/logstash">home</a>, <a href="https://github.com/elastic/logstash">github</a>）最初是来自 Dreamhost 运维工程师 Jordan Sissel 的开源项目，是管理事件和日志的工具，能够用于采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中（比如 Elasticsearch）。Logstash 使用 JRuby 开发，2011 年 5 月发布 1.0 版本。2013 年 8 月 Jordan Sissel 带着 Logstash 加入 Elasticsearch 公司，Logstash 成为 Elastic Stack 一员。</p>
<p>在 Ubuntu 下<a href="https://www.elastic.co/guide/en/logstash/6.5/installing-logstash.html">安装</a>、<a href="https://www.elastic.co/guide/en/logstash/6.5/running-logstash.html">启动</a> Logstash 可以使用下面命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install logstash                <span class="comment"># 安装 logstash</span></span><br><span class="line">$ sudo systemctl start logstash.service        <span class="comment"># 系统服务方式启动 logstash</span></span><br><span class="line">$ /usr/share/logstash/bin/logstash --version   <span class="comment"># 查看 logstash 版本</span></span><br><span class="line">logstash 6.5.4</span><br><span class="line">$ sudo vim /etc/logstash/logstash.yml          <span class="comment"># 查看默认 logstash.yml</span></span><br><span class="line">$ sudo vim /etc/logstash/logstash-sample.conf  <span class="comment"># 查看示例 logstash-sample.conf</span></span><br></pre></td></tr></table></figure>
<p>安装完成后，二进制文件在 <code>/usr/share/logstash/bin</code> 目录下，配置文件位于 <code>/etc/logstash</code> 目录，日志输出位于 <code>/var/log/logstash</code> 目录，其他详细的目录位置的分布情况，可以阅读<a href="https://www.elastic.co/guide/en/logstash/6.5/dir-layout.html">官方文档</a>。</p>
<h2 id="最简单的示例">最简单的示例</h2>
<p>Logstash 管道（pipeline）由 <code>input</code>、<code>filter</code> 和 <code>output</code> 三个元素组成，其中 <code>input</code> 和 <code>output</code> 必须设置，而 <code>filter</code> 可选。<code>input</code> 插件从数据源中消费数据，<code>filter</code> 插件按指定方式修改数据，<code>output</code> 插件将数据写入特定目标中 [ <a href="https://www.elastic.co/guide/en/logstash/6.5/first-event.html">doc</a> ]。</p>
<img width="600" alt="Logstash 管道" title="Logstash 管道" src="https://static.nullwy.me/basic_logstash_pipeline.png">
<p>现在来试试 Logstash 下 Hello Wolrd 级别的示例，运行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/share/logstash/bin/logstash -e <span class="string">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>-e</code> 选项能够使 Logstash 直接在<a href="https://www.elastic.co/guide/en/logstash/6.5/running-logstash-command-line.html">命令行</a>中设置管道配置。示例中 <code>input</code> 插件为 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-inputs-stdin.html">stdin</a> （标准输入），<code>output</code> 插件是 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-outputs-stdout.html">stdout</a> （标准输出）。若在控制台输入 <code>hello world</code>，相应的控制台将输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2019</span><span class="number">-01</span><span class="number">-12</span>T05<span class="punctuation">:</span><span class="number">52</span><span class="punctuation">:</span><span class="number">56.291</span>Z<span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，输出内容编码格式默认为 <code>rubydebug</code>，使用 Ruby 的 &quot;<a href="https://github.com/awesome-print/awesome_print">awesome_print</a>&quot; 库打印。另外，响应输出 <code>@timestamp</code> 字段的值为 <code>2019-01-12T05:52:56.291Z</code>，这是 <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> 时间格式，时区是 0（zero），和北京时间相差 8 个小时。</p>
<p>输出内容编码格式，可以通过 <code>codec</code> 指令指定。除了默认的 <code>rubydebug</code> 外，官方还支持其他 20 多种编码格式，参见 <a href="https://www.elastic.co/guide/en/logstash/6.5/codec-plugins.html">doc</a>。若把编码格式改为 <code>json</code>，即 <code>stdout &#123; codec =&gt; json &#125;</code>，输出结果将变成：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;hello world&quot;</span><span class="punctuation">,</span><span class="attr">&quot;@version&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;2019-01-12T05:52:56.291Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;host&quot;</span><span class="punctuation">:</span><span class="string">&quot;ubuntu109&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>管道配置也可以保存到文件中，以 <code>*.conf</code> 作为文件后缀，比如保存为 <code>test-stdin-stdout.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  stdin &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 logstash 时，<code>-f</code> 选项用于指定管道配置文件的路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/share/logstash/bin/logstash -f ~/test-stdin-stdout.conf</span><br></pre></td></tr></table></figure>
<p>默认情况下，在启动 logstash 后，若再修改管道配置文件，新的修改需要重启 logstash 才能加载生效。在开发调试时，不太方便。解决这个问题，可以使用 <code>-r</code> 命令行<a href="https://www.elastic.co/guide/en/logstash/6.5/running-logstash-command-line.html">选项</a>。开启这个选项后，只要确定配置文件已经发生变更，便会自动重新加载配置文件。</p>
<h2 id="file-输入插件">file 输入插件</h2>
<p>上文日志是控制台输入的，但真实情况日志在日志文件中，要想使用 Logstash 读取日志文件，官方提供了 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-inputs-file.html">file</a> 输入插件。管道配置文件示例 <code>test-file-stdout.conf</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">   path =&gt; [&quot;/home/yulewei/test.log&quot;]</span><br><span class="line">   sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">   start_position =&gt; &quot;beginning&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 Logstash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/share/logstash/bin/logstash -r -f ~/test-file-stdout.conf</span><br></pre></td></tr></table></figure>
<p>配置文件中的 <code>path</code> 指令用于指定日志文件的路径。<code>start_position</code> 指令设置 Logstash 启动时读取日志文件的位置，可以设置为 <code>beginning</code> 或者 <code>end</code>，默认是 <code>end</code>，即文件末尾。</p>
<p>为了跟踪每个输入文件中已处理了哪些数据，Logstash 文件输入插件会使用名为 sincedb 的文件来记录现有位置。由于我们的配置用于开发，所以我们希望能够重复读取文件，并进而希望禁用 sincedb 文件。在 Linux 系统上，将 <code>sincedb_path</code> 指令设置为 “/dev/null” 即可禁用。若没有禁用，默认保存的 sincedb 文件将在 <code>/usr/share/logstash/data/plugins/inputs/file/</code> 目录下。</p>
<h2 id="grok-过滤插件">grok 过滤插件</h2>
<p>上文的例子，做的核心事情就是把日志行转换到 <code>message</code> 字段，并附加某些元数据，如 <code>@timestamp</code>。如果要想解析自己的日志，把非结构化日志转换结构换日志，有两个过滤器特别常用：<a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-filters-dissect.html">dissect</a> 会根据分界符来解析日志，而 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-filters-grok.html">grok</a> 则会根据正则表达式匹配来运行。</p>
<p>如果数据结构定义非常完善，dissect 过滤插件的运行效果非常好，而且运行速度非常快捷高效。同时，其也更加容易上手，对于不熟悉正则表达式的用户而言，更是如此。通常而言，grok 的功能更加强大，而且可以处理各种各样的数据。然而，正则表达式匹配会耗费更多资源，而且速度也会慢一些，如果未能正确进行优化的话，尤为如此。</p>
<p>现在先来看下 grok 过滤插件。grok 模式的基本语法是 <code>%&#123;SYNTAX:SEMANTIC&#125;</code>，<code>SYNTAX</code> 是用于匹配数据的模式（或正则表达式）名称，<code>SEMANTIC</code> 是标识符或字段名称。Logstash 提供了超过 120 种默认的 grok 模式，全部预定义的模式可以在 <a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns">github</a> 上找到。典型的预定义模式（非完整列表）[ <a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/v4.1.2/patterns/grok-patterns">github</a> ]：</p>
<ul>
<li>WORD - 匹配单个词汇的模式</li>
<li>NUMBER - 匹配整数或浮点数（正值或负值均可）的模式</li>
<li>POSINT - 匹配正整数的模式</li>
<li>EMAILADDRESS - 邮箱地址</li>
<li>IP - 匹配 IPv4 或 IPv6 IP 地址的模式</li>
<li>URI - URI 地址</li>
<li>TIMESTAMP_ISO8601 - <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> 格式的时间</li>
<li>NOTSPACE - 匹配非空格的任何内容的格式</li>
<li>SPACE - 匹配任何数量的连续空格的模式</li>
<li>DATA - 匹配任何数据类型的限定数量的模式</li>
<li>GREEDYDATA - 匹配剩余所有数据的格式</li>
</ul>
<p>比如，<code>3.44</code> 可以使用 <code>NUMBER</code> 模式进行匹配，<code>192.168.2.104</code> 可以使用 <code>IP</code> 模式。<code>%&#123;NUMBER:num&#125; %&#123;IP:client&#125;</code> 模式，将会用 <code>NUMBER</code> 模式把 <code>3.44</code> 识别为 <code>num</code> 字段，用 <code>IP</code> 模式把 <code>192.168.2.104</code> 识别为 <code>client</code> 字段。默认情况识别获得的字段值是字符串类型，grok 插件支持把类型转换为 <code>int</code> 或 <code>float</code>。要想把 <code>3.44</code> 转换为浮点数，可以使用 <code>%&#123;NUMBER:num:float&#125;</code>。</p>
<p>假设有如下日志内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Will, yulewei@gmail.com, 42, 1024, 3.14</span><br></pre></td></tr></table></figure>
<p>grok 匹配表达式可以写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;WORD:name&#125;, %&#123;EMAILADDRESS:email&#125;, %&#123;NUMBER:num1&#125;, %&#123;NUMBER:num2:int&#125;, %&#123;NUMBER:pi:float&#125;</span><br></pre></td></tr></table></figure>
<p>即，在这一行日志中依次提取出，<code>name</code>、<code>email</code>、<code>num1</code>、<code>num2</code> 和 <code>pi</code> 字段。完整的 <code>filter</code> 过滤器配置的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;WORD:name&#125;, %&#123;EMAILADDRESS:email&#125;, %&#123;NUMBER:num1&#125;, %&#123;NUMBER:num2:int&#125;, %&#123;NUMBER:pi:float&#125;&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 logstash：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/share/logstash/bin/logstash -r -f ~/test-file-grok-stdout.conf</span><br></pre></td></tr></table></figure>
<p>控制台将输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;Will, yulewei@gmail.com, 42, 1024, 3.14&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;num1&quot;</span> =&gt; <span class="string">&quot;42&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;pi&quot;</span> =&gt; <span class="number">3.14</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2019</span><span class="number">-01</span><span class="number">-12</span>T08<span class="punctuation">:</span><span class="number">12</span><span class="punctuation">:</span><span class="number">49.581</span>Z<span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;path&quot;</span> =&gt; <span class="string">&quot;/home/yulewei/test-grok.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;email&quot;</span> =&gt; <span class="string">&quot;yulewei@gmail.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;Will&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;num2&quot;</span> =&gt; <span class="number">1024</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Logstash 提供了超过 120 种默认的 grok 模式，基本上满足大多数使用场景。若没有符合要求的预定义的模式，可以使用 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-filters-grok.html#_regular_expressions">Oniguruma</a> 语法指定正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?&lt;field_name&gt;the pattern here)</span><br></pre></td></tr></table></figure>
<p>上文中的 <code>%&#123;WORD:name&#125;</code> 和 <code>%&#123;EMAILADDRESS:email&#125;</code>，等价的正则表达式的写法如下 [ <a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/v4.1.2/patterns/grok-patterns">ref1</a>, <a href="https://stackoverflow.com/a/8829363">ref2</a> ]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?&lt;name&gt;\w+)</span><br><span class="line">(?&lt;email&gt;[a-zA-Z][a-zA-Z0-9_.+-=:]+@[0-9A-Za-z][0-9A-Za-z-]&#123;0,62&#125;\.[0-9A-Za-z][0-9A-Za-z-]&#123;0,62&#125;)</span><br></pre></td></tr></table></figure>
<p>调试 grok 匹配表达式容易出错，官方提供可视化的 <a href="https://www.elastic.co/guide/en/kibana/6.5/grokdebugger-getting-started.html">Grok Debugger</a> 工具，提高调试效率。</p>
<img width="800" alt="Grok Debugger" title="Grok Debugger" src="https://static.nullwy.me/kibana-grokdebugger.png">
<h3 id="解析-http-服务器日志">解析 http 服务器日志</h3>
<p>现在来看下，真实的日志解析案例，使用 grok 过滤插件解析 http 服务器日志。通用日志格式（<a href="https://en.wikipedia.org/wiki/Common_Log_Format">Common Log Format</a>），是 http 服务器的标准的日志格式。对通用日志格式扩展，加上额外的 referer 和 user-agent 字段，称为组合日志格式（Combined Log Format）。两种日志格式包含的字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通用日志格式</span><br><span class="line">%remote-host %ident %authuser %timestamp &quot;%request&quot; %status %bytes</span><br><span class="line"># 组合日志格式</span><br><span class="line">%remote-host %ident %authuser %timestamp &quot;%request&quot; %status %bytes &quot;%referer&quot; &quot;%user-agent&quot;</span><br></pre></td></tr></table></figure>
<p><a href="https://httpd.apache.org/docs/2.4/logs.html#accesslog">Apache</a> 和 <a href="https://nginx.org/en/docs/http/ngx_http_log_module.html#log_format">Nginx</a> 服务器默认的日志格式，采用的就是通用日志格式或者组合日志格式。解析这两种日志格式，Logstash 提供预定义模式 <a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/v4.1.2/patterns/httpd#L14">COMMONAPACHELOG</a> 和 <a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/v4.1.2/patterns/httpd#L15">COMBINEDAPACHELOG</a>。</p>
<p>典型的 nginx 日志例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.2.104 - - [13/Jan/2019:02:01:15 +0800] &quot;GET /images/avatar.png HTTP/1.1&quot; 200 266975 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:64.0) Gecko/20100101 Firefox/64.0&quot;</span><br></pre></td></tr></table></figure>
<p>管道配置文件示例 <code>test-file-grokhttp-stdout.conf</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [&quot;/var/log/nginx/access.log&quot;]</span><br><span class="line">    sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot; &#125;</span><br><span class="line">    remove_field =&gt; [&quot;message&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中使用了 grok 的预定义模式 <a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/v4.1.2/patterns/httpd#L15">COMBINEDAPACHELOG</a>。另外，<code>remove_field</code> <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-filters-grok.html#plugins-filters-grok-remove_field">指令</a>用于把输出事件中某字段删除，示例中是 <code>message</code> 字段。</p>
<p>启动 logstash：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/share/logstash/bin/logstash -r -f ~/test-file-grokhttp-stdout.conf</span><br></pre></td></tr></table></figure>
<p>解析获得的结构化数据，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">           <span class="string">&quot;auth&quot;</span> =&gt; <span class="string">&quot;-&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;verb&quot;</span> =&gt; <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;clientip&quot;</span> =&gt; <span class="string">&quot;192.168.2.104&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;httpversion&quot;</span> =&gt; <span class="string">&quot;1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2019</span><span class="number">-01</span><span class="number">-13</span>T13<span class="punctuation">:</span><span class="number">35</span><span class="punctuation">:</span><span class="number">52.983</span>Z<span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;bytes&quot;</span> =&gt; <span class="string">&quot;266975&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;timestamp&quot;</span> =&gt; <span class="string">&quot;13/Jan/2019:02:01:15 +0800&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;request&quot;</span> =&gt; <span class="string">&quot;/images/avatar.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;response&quot;</span> =&gt; <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;referrer&quot;</span> =&gt; <span class="string">&quot;\&quot;-\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;path&quot;</span> =&gt; <span class="string">&quot;/var/log/nginx/access.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;agent&quot;</span> =&gt; <span class="string">&quot;\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:64.0) Gecko/20100101 Firefox/64.0\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;ident&quot;</span> =&gt; <span class="string">&quot;-&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="dissect-过滤插件">dissect 过滤插件</h2>
<p>和 grok 过滤插件使用正则表达式提取字段不同，dissect 过滤插件使用分界符切割来提取字段。由于没有使用正则表达式，运行速度相对 grok 快很多。使用 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-filters-dissect.html">dissect</a> 过滤插件时，需要指明提取字段的顺序，还要指明这些字段之间的分界符。过滤插件会对数据进行单次传输，并匹配模式中的分界符。同时，过滤插件还会将分界符之间的数据分配至指定字段。过滤插件不会对所提取数据的格式进行验证。</p>
<p>现在看下示例，<code>test-dissect.log</code> 文件内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Will, yulewei@gmail.com, 42, 1024, 3.14</span><br></pre></td></tr></table></figure>
<p>dissect 匹配规则可以写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;name&#125;, %&#123;email&#125;, %&#123;num1&#125;, %&#123;num2&#125;, %&#123;num3&#125;</span><br></pre></td></tr></table></figure>
<p>完整的配置文件，<code>test-file-dissect-stdout.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">   path =&gt; [&quot;/home/yulewei/test-dissect.log&quot;]</span><br><span class="line">   sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">   start_position =&gt; &quot;beginning&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  dissect &#123;</span><br><span class="line">    mapping =&gt; &#123;</span><br><span class="line">      &quot;message&quot; =&gt; &quot;%&#123;name&#125;, %&#123;email&#125;, %&#123;num1&#125;, %&#123;num2&#125;, %&#123;num3&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    convert_datatype =&gt; &#123;</span><br><span class="line">      &quot;num2&quot; =&gt; &quot;int&quot;</span><br><span class="line">      &quot;num3&quot; =&gt; &quot;float&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 grok 插件一样，默认提取的字段是字符串类型。配置文件中的 <code>convert_datatype</code> 指令用于将类型转为 <code>int</code> 或 <code>float</code>。</p>
<p>启动 logstash：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/share/logstash/bin/logstash -r -f ~/test-file-dissect-stdout.conf</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;num1&quot;</span> =&gt; <span class="string">&quot;42&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;Will, yulewei@gmail.com, 42, 1024, 3.14&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;Will&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;num2&quot;</span> =&gt; <span class="number">1024</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2019</span><span class="number">-01</span><span class="number">-13</span>T13<span class="punctuation">:</span><span class="number">32</span><span class="punctuation">:</span><span class="number">10.900</span>Z<span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;path&quot;</span> =&gt; <span class="string">&quot;/home/yulewei/test-dissect.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;email&quot;</span> =&gt; <span class="string">&quot;yulewei@gmail.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;num3&quot;</span> =&gt; <span class="number">3.14</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="输出到-Elasticsearch">输出到 Elasticsearch</h1>
<p>上文举的例子全部都是，输出控制台，使用 <code>stdout</code> 输出插件，没有实用价值。Elastic Stack 的核心其实是 Elasticsearch，使用Elasticsearch 搜索和分析日志。想要将数据发送到 Elasticsearch，可以使用 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-outputs-elasticsearch.html">elasticsearch</a> 输出插件。</p>
<h2 id="安装-Elasticsearch">安装 Elasticsearch</h2>
<p>如果没有安装 Elasticsearch，参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/deb.html">官方文档</a>按步骤安装。唯一要注意的是，在执行 <code>apt install</code> 命令前，必须先添加 elastic 的软件源地址，否则无法正常启动。核心命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install elasticsearch           <span class="comment"># 安装 elasticsearch</span></span><br><span class="line">$ sudo systemctl start elasticsearch.service   <span class="comment"># 系统服务方式启动 elasticsearch</span></span><br><span class="line">$ curl http://localhost:9200/                  <span class="comment"># 用 rest 接口查看 elasticsearch</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;1t9JXt5&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;yQgVsvupSqGCGQbwqnanIg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;6.5.4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_type&quot;</span> : <span class="string">&quot;deb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;d2ef93d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2018-12-17T21:17:40.758843Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;7.5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;5.6.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;5.0.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下 elasticsearch 服务器绑定的 ip 地址是回环地址 <code>127.0.0.1</code>，若想绑定特定 ip 地址，可以修改 <code>/etc/elasticsearch/elasticsearch.yml</code> 配置文件中的 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/network.host.html">network.host</a> 选项：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.109</span></span><br></pre></td></tr></table></figure>
<p>修改完成并重启后，elasticsearch 服务器访问地址从 <code>http://localhost:9200/</code> 变成 <code>http://192.168.2.109:9200/</code>。</p>
<h2 id="输出到-Elasticsearch-v2">输出到 Elasticsearch</h2>
<p>现在来看下 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-outputs-elasticsearch.html">elasticsearch</a> 输出插件。示例，<code>test-file-elasticsearch.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">   path =&gt; [&quot;/home/yulewei/test.log&quot;]</span><br><span class="line">   sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">   start_position =&gt; &quot;beginning&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;http://192.168.2.109:9200&quot;]</span><br><span class="line">    index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例的 <code>elasticsearch</code> 输出插件使用了 <code>hosts</code> 和 <code>index</code> 指令。<code>hosts</code> 指令，用于指定 elasticsearch 服务器的地址。而 <code>index</code> 指令，用于指定 elasticsearch 索引的名称模式，该指令默认值为 <code>logstash-%&#123;+YYYY.MM.dd&#125;</code>。在字符串内部的 <code>%&#123;...&#125;</code>，是 Logstash 字符串插值语法，官方称之为 <code>sprintf format</code> [ <a href="https://www.elastic.co/guide/en/logstash/6.5/event-dependent-configuration.html">doc</a> ]。<code>+YYYY.MM.dd</code>，用于指定 <code>@timestamp</code> 的格式化的格式。<code>logstash-%&#123;+YYYY.MM.dd&#125;</code>，格式化后最终生成的值可能将是 <code>logstash-2019.01.13</code>。</p>
<p>启动 logstash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/share/logstash/bin/logstash -r -f ~/test-file-elasticsearch.conf</span><br></pre></td></tr></table></figure>
<p>查看在 elasticsearch 上新创建的 <code>logstash-*</code> 索引以及从 logstash 同步过来的日志数据：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://192.168.2.109:9200/_cat/indices</span><br><span class="line">yellow open logstash-2019.01.13       tFjc5xL_QYeNw4oqe4odeg 5 1     3 0 15.5kb 15.5kb</span><br><span class="line">$ curl <span class="string">&#x27;http://192.168.2.109:9200/logstash-*/_search?pretty&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;&#123;&quot;size&quot;: 1&#125;&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span> : 0,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : 5,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span> : 5,</span><br><span class="line">    <span class="string">&quot;skipped&quot;</span> : 0,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span> : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : 3,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span> : 1.0,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;logstash-2019.01.13&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;doc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;RUHNRWgBLIBntI4FV8Rf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span> : 1.0,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;path&quot;</span> : <span class="string">&quot;/home/yulewei/test.log&quot;</span>,</span><br><span class="line">          <span class="string">&quot;@timestamp&quot;</span> : <span class="string">&quot;2019-01-13T06:01:51.303Z&quot;</span>,</span><br><span class="line">          <span class="string">&quot;@version&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="string">&quot;host&quot;</span> : <span class="string">&quot;ubuntu109&quot;</span>,</span><br><span class="line">          <span class="string">&quot;message&quot;</span> : <span class="string">&quot;hello world&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，新的索引名为 <code>logstash-2019.01.13</code>。同步过来的日志记录全部有 5 条，第 1 条日志的 <code>message</code> 内容是 <code>hello world</code>。</p>
<h2 id="使用-Kibana">使用 Kibana</h2>
<p>Kibana，能够对 Elasticsearch 中的数据进行可视化，是 Elastic Stack 的窗口。在 Ubuntu 下<a href="https://www.elastic.co/guide/en/kibana/6.5/deb.html">安装</a> Kibana 可以使用下面命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install kibana          <span class="comment"># 安装 kibana，当前最新版为 6.5.4</span></span><br><span class="line">$ sudo systemctl start kibana.service  <span class="comment"># 系统服务方式启动 kibana</span></span><br></pre></td></tr></table></figure>
<p>默认配置下，kibana 服务访问地址是 <code>http://localhost:5601/</code>，连接的 elasticsearch 地址是 <code>http://localhost:9200</code>，这两个配置分别由 <code>server.host</code> 和 <code>elasticsearch.url</code> 控制 [ <a href="https://www.elastic.co/guide/en/kibana/6.5/settings.html">doc</a> ]。上文尝试过把 elasticsearch 服务 ip 地址绑定到 <code>192.168.2.109</code>。现在来试下绑定 ip 地址到 kibana，编辑配置文件 <code>/etc/kibana/kibana.yml</code>，修改为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;192.168.2.109&quot;</span></span><br><span class="line"><span class="attr">elasticsearch.url:</span> <span class="string">&quot;http://192.168.2.109:9200&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>sudo systemctl restart kibana.service</code> 重启后，kibana 服务访问地址变成 <code>http://192.168.2.109:5601/</code>。</p>
<p>elasticsearch 服务器上存在索引 <code>logstash-2019.01.13</code>，要想把这个索引导入到 kibana，参考官方<a href="https://www.elastic.co/guide/en/kibana/6.5/tutorial-define-index.html">教程</a>即可。点击 <code>Management</code> 菜单，然后创建索引模式（index pattern）。索引模式可以直接为 <code>logstash-2019.01.13</code>，这样匹配单个索引。若要匹配多个时间的 logstash 索引，可以使用通配符 <code>*</code>，比如 <code>logstash-*</code>。如果要匹配全部 2019 年 01 月的索引，可以写成 <code>logstash-2019.01*</code>。完成索引模式定义后，便可以在 <code>Discover</code> 菜单下查看索引，如图：</p>
<img width="800" alt="Kibana" title="Kibana" src="https://static.nullwy.me/logstash-kibana.png">
<h1 id="使用-Filebeat">使用 Filebeat</h1>
<p>Filebeat，轻量型日志采集器 [ <a href="https://www.elastic.co/cn/products/beats/filebeat">home</a> ]。其前身是由 Logstash 作者 Jordan Sissel 开发的 <a href="https://github.com/elastic/logstash-forwarder">Logstash Forwarder</a>。Logstash Forwarder 项目因为和收购过来的 Packetbeat 项目功能相近，并且都是 Go 语言开发，就一起被整合改造为 Beats [ <a href="https://www.elastic.co/blog/beats-1-0-0">ref</a> ]。</p>
<p>我们知道，Logstash 使用 JRuby 开发，运行依赖 JVM，会消耗较多的系统资源。为了减少系统资源（CPU、内存和网络）的使用，Logstash Forwarder 改用 Go 语言开发。另外，在功能上也做了精简，只做单一的数据传输，不像 Logstash 有数据过滤能力。Logstash 类似于功能多样的“瑞士军刀”，能提供从多个数据源加载数据的功能，使用各种强大的插件来处理日志，并提供将多个来源的输出数据进行存储的功能。简而言之，Logstash 提供数据 ETL（数据的提取、变换和加载）的功能；而 Beats 是轻量级的数据传输工具，能将数据传输到 Logstash 或 Elasticsearch 中，其间没有对数据进行任何转换 [ <a href="https://book.douban.com/subject/30326542/">Gupta2017</a> ]。Filebeat 和 Logstash 的关系如下图所示 [ <a href="https://logz.io/blog/filebeat-vs-logstash/">logz.io</a> ]：</p>
<img width="600" alt="Filebeat 和 Logstash 的关系" title="Filebeat 和 Logstash 的关系" src="https://static.nullwy.me/filebeat-and-logstash.png">
<p>安装 filebeat 很简单，参考<a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/setup-repositories.html">官方文档</a>即可，核心命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install filebeat           <span class="comment"># 安装 filebeat</span></span><br><span class="line">$ filebeat version                        <span class="comment"># 查看 filebeat 版本</span></span><br><span class="line">filebeat version 6.5.4 (amd64), libbeat 6.5.4 [bd8922f1c7e93d12b07e0b3f7d349e17107f7826 built 2018-12-17 20:22:29 +0000 UTC]</span><br><span class="line">$ sudo systemctl start filebeat.service   <span class="comment"># 系统服务方式启动 filebeat</span></span><br></pre></td></tr></table></figure>
<h2 id="输出到-Elasticsearch-v3">输出到 Elasticsearch</h2>
<p>修改 filebeat 配置文件 /etc/filebeat/<a href="https://github.com/elastic/beats/blob/6.5/filebeat/filebeat.yml">filebeat.yml</a>，示例如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/home/yulewei/test.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;192.168.2.109:9200&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>filebeat.inputs</code> 选项用于配置日志的<a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/configuration-filebeat-options.html">输入方式</a>。子选项 <code>type</code> <a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/configuration-filebeat-options.html#filebeat-input-types">支持</a> <code>log</code>、<code>stdin</code>、<code>redis</code>、<code>udp</code>、<code>tcp</code> 等，示例中使用了 <code>log</code>，表明从日志文件输入。</p>
<p><code>output</code> 选项用于配置日志的<a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/configuring-output.html">输出方式</a>，配置支持 elasticsearch、logstash、kafka、redis、file、console 等，一次只能选择配置其中某一个。示例配置了 <code>output.elasticsearch.hosts</code>，指定日志输出目标 elasticsearch 的主机地址。<code>output.elasticsearch.index</code> 可以用来指定索引 index 名称模式，默认是 <code>filebeat-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;</code>（比如 <code>filebeat-6.5.4-2019.01.12</code>）[ <a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/elasticsearch-output.html#index-option-es">doc</a> ]。</p>
<p>完成 <code>filebeat.yml</code> 修改后，重启 filebeat，将可以看到，在 elasticsearch 上新创建的 <code>filebeat-*</code> 索引：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://192.168.2.109:9200/_cat/indices</span><br><span class="line">yellow open filebeat-6.5.4-2019.01.12 B4JbQDnZQuK5XvsQ77uedA 3 1 11043 0  1.7mb  1.7mb</span><br></pre></td></tr></table></figure>
<h2 id="输出到-Logstash">输出到 Logstash</h2>
<p>上文的示例直接把 Filebeat 采集的日志传输到 Elasticsearch，日志数据并没有被解析或者转换。若想解析和转换日志，需要在Filebeat 和 Elasticsearch 中间引入 Logstash。现在看下把日志输出到 Logstash 的示例配置文件，<code>filebeat.yml</code> 示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/home/yulewei/test.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:5044&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>filebeat.inputs</code> 和上文的示例一样。不同的是，把 <code>output.elasticsearch.hosts</code> 改成了 <code>output.logstash.hosts</code>，指定日志输出目标 <a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/logstash-output.html">Logstash</a> 的主机地址。<code>5044</code> 这个端口是 Logstash 用于监听 Filebeat 的端口。</p>
<p>现在来看下 Logstash 的管道配置文件，示例 <code>test-beats-stdout.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中，使用了 <a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-inputs-beats.html">beats</a> 输入插件，配置的端口就 <code>filebeat.yml</code> 中指定的 <code>5044</code>。输出插件为 <code>stdout</code>，即把 Logstash 采集到日志输出到控制台。</p>
<p>重启 filebeat 和 logstash：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test.log                              <span class="comment"># 查看日志文件内容</span></span><br><span class="line">hello world</span><br><span class="line">$ sudo systemctl restart filebeat.service   <span class="comment"># 重启 filebeat</span></span><br><span class="line">$ sudo /usr/share/logstash/bin/logstash -r -f ~/test-beats-stdout.conf</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="string">&quot;tags&quot;</span> =&gt; <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="string">&quot;beats_input_codec_plain_applied&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;source&quot;</span> =&gt; <span class="string">&quot;/home/yulewei/test.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;input&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;type&quot;</span> =&gt; <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;hello world&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2019</span><span class="number">-01</span><span class="number">-12</span>T13<span class="punctuation">:</span><span class="number">32</span><span class="punctuation">:</span><span class="number">05.131</span>Z<span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;prospector&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;type&quot;</span> =&gt; <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;beat&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;hostname&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;version&quot;</span> =&gt; <span class="string">&quot;6.5.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;offset&quot;</span> =&gt; <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;host&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">                   <span class="string">&quot;os&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="string">&quot;version&quot;</span> =&gt; <span class="string">&quot;16.04.4 LTS (Xenial Xerus)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;platform&quot;</span> =&gt; <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;codename&quot;</span> =&gt; <span class="string">&quot;xenial&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;family&quot;</span> =&gt; <span class="string">&quot;debian&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;architecture&quot;</span> =&gt; <span class="string">&quot;x86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   <span class="string">&quot;id&quot;</span> =&gt; <span class="string">&quot;29b1bf39547d4ca9ae26c3b7656ff9e3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;containerized&quot;</span> =&gt; <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                 <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="集成-Filebeat-Logstash-Elasticsearch-Kibana">集成 Filebeat, Logstash, Elasticsearch, Kibana</h1>
<p>真实场景下，日志文件可能分布在多台服务器上，同一台服务器上也可能分布着不同来源类型的日志。现在我们来尝试下，使用 Filebeat 把两个日志文件各自采集到两个不同的 Elasticsearch 索引中，并用 Kibana 可视化。有两个日志文件 <code>test-beats1.log</code> 和 <code>test-beats2.log</code>，内容如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test-beats1.log</span><br><span class="line">hello world1</span><br><span class="line">hello world1</span><br><span class="line">$ <span class="built_in">cat</span> test-beats2.log</span><br><span class="line">hello world2</span><br></pre></td></tr></table></figure>
<p><code>filebeat.yml</code> 配置示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/home/yulewei/test-beats1.log</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">log_type:</span> <span class="string">test1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span> </span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/home/yulewei/test-beats2.log</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">log_type:</span> <span class="string">test2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:5044&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>示例配置文件使用了 <code>filebeat.inputs.fields</code> 选项，<a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/filebeat-input-log.html#filebeat-input-log-fields">fields</a> 选项用于在日志事件输出中添加字段。添加的字段名可以任意指定，示例中名为 <code>log_type</code>。因为现在在 filebeat 配置中同时导入两个日志文件，输出到同一个 logstash 中。使用这个额外字段是为了区分日志是来自 <code>test-beats1.log</code> 还是 <code>test-beats2.log</code>。示例中，第 1 个日志事件输出的 <code>log_type</code> 字段值配置为 <code>test1</code>， 第 2 个日志配置为 <code>test2</code>。</p>
<p>管道配置文件示例，<code>test-beats-elasticsearch.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;http://192.168.2.109:9200&quot;]</span><br><span class="line">    index =&gt; &quot;filebeat-%&#123;[fields][log_type]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出插件同时使用了 <code>elasticsearch</code> 和 <code>stdout</code>。配置文件中的 <code>elasticsearch</code> 输出插件的 <code>index</code> 指令被设置为 <code>filebeat-%&#123;[fields][log_type]&#125;-%&#123;+YYYY.MM.dd&#125;</code>。<code>[fields][log_type]</code> 引用的是在 <code>filebeat.yml</code> 的 <code>filebeat.inputs.fields</code> 选项添加的 <code>log_type</code> 字段（关于在配置文件引用字段的语法，可以参考<a href="https://www.elastic.co/guide/en/logstash/6.5/event-dependent-configuration.html#logstash-config-field-references">官方文档</a>）。根据 <code>log_type</code> 字段不同，把日志将输出到不同的索引中。因为 <code>filebeat.yml</code> 配置文件中设置的 <code>log_type</code> 字段是 <code>test1</code> 或者 <code>test2</code>，所以最终生成的索引名是 <code>filebeat-test1-*</code> 或者 <code>filebeat-test1-*</code>。<code>filebeat-test1-*</code> 索引中全部日志数据来自 <code>test-beats1.log</code> 日志文件，<code>filebeat-test2-*</code> 索引数据来自 <code>test-beats2.log</code>。</p>
<p>启动 filebeat 和 logstash：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart filebeat.service</span><br><span class="line">$ sudo /usr/share/logstash/bin/logstash -r -f ~/test-beats-elasticsearch.conf</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;host&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;hello world2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;prospector&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;type&quot;</span> =&gt; <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;fields&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;log_type&quot;</span> =&gt; <span class="string">&quot;test2&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;offset&quot;</span> =&gt; <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;tags&quot;</span> =&gt; <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> <span class="string">&quot;beats_input_codec_plain_applied&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;beat&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;version&quot;</span> =&gt; <span class="string">&quot;6.5.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;hostname&quot;</span> =&gt; <span class="string">&quot;ubuntu109&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2019</span><span class="number">-01</span><span class="number">-13</span>T09<span class="punctuation">:</span><span class="number">32</span><span class="punctuation">:</span><span class="number">11.845</span>Z<span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;source&quot;</span> =&gt; <span class="string">&quot;/home/yulewei/test-beats2.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;input&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;type&quot;</span> =&gt; <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看在 elasticsearch 上新创建的 <code>filebeat-test1-*</code> 和 <code>filebeat-test1-*</code> 索引：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://192.168.2.109:9200/_cat/indices/filebeat-*</span><br><span class="line">yellow open filebeat-test1-2019.01.13 NLVfFJl5TQ-7I1r9KoVLaQ 5 1 5 0 31.8kb 31.8kb</span><br><span class="line">yellow open filebeat-test2-2019.01.13 NnsBp3P9Q3-mLc8chE-Tiw 5 1 3 0 24.1kb 24.1kb</span><br></pre></td></tr></table></figure>
<p>在 kibana 上查看收集的日志：</p>
<img width="800" alt="Kibana" title="Kibana" src="https://static.nullwy.me/filebeat-kibana.png">
<p>整体架构上，如下图所示 [ <a href="https://www.elastic.co/guide/en/logstash/6.8/deploying-and-scaling.html">doc</a> ]：</p>
<img width="800" alt="Deploying Logstash" title="Deploying Logstash" src="https://static.nullwy.me/logstash-deploy2.png">
<hr>
<p><strong>附注</strong>：本文中提到的配置文件，可以在 github 上访问得到，<a href="https://github.com/yulewei/elastic-stack-conf">elastic-stack-conf</a>。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>发展历程| Elastic <a href="https://www.elastic.co/cn/about/history-of-elasticsearch">https://www.elastic.co/cn/about/history-of-elasticsearch</a></li>
<li>2013-01 Welcome Drew &amp; Rashid (Kibana) <a href="https://www.elastic.co/blog/welcome-drew-rashid">https://www.elastic.co/blog/welcome-drew-rashid</a></li>
<li>2013-08 Welcome Jordan &amp; Logstash <a href="https://www.elastic.co/blog/welcome-jordan-logstash">https://www.elastic.co/blog/welcome-jordan-logstash</a></li>
<li>2015-05 Welcome Packetbeat, Tudor &amp; Monica <a href="https://www.elastic.co/blog/welcome-packetbeat-tudor-monica">https://www.elastic.co/blog/welcome-packetbeat-tudor-monica</a></li>
<li>2015-11 The Beats 1.0.0 <a href="https://www.elastic.co/blog/beats-1-0-0">https://www.elastic.co/blog/beats-1-0-0</a></li>
<li>2016-02 Heya, Elastic Stack and X-Pack <a href="https://www.elastic.co/blog/heya-elastic-stack-and-x-pack">https://www.elastic.co/blog/heya-elastic-stack-and-x-pack</a></li>
<li>2016-10 Elastic Stack 5.0 正式发布 <a href="https://www.elastic.co/cn/blog/elastic-stack-5-0-0-released">https://www.elastic.co/cn/blog/elastic-stack-5-0-0-released</a></li>
<li>2018-05 官方：Logstash 实用介绍 <a href="https://www.elastic.co/cn/blog/a-practical-introduction-to-logstash">https://www.elastic.co/cn/blog/a-practical-introduction-to-logstash</a></li>
<li>Filebeat vs. Logstash — The Evolution of a Log Shipper <a href="https://logz.io/blog/filebeat-vs-logstash/">https://logz.io/blog/filebeat-vs-logstash/</a></li>
<li>精通Elastic Stack，Gupta，2017 <a href="https://book.douban.com/subject/30326542/">https://book.douban.com/subject/30326542/</a></li>
<li>logstash - open source log management <a href="https://web.archive.org/web/20150512135526/http://logstash.net/">https://web.archive.org/web/20150512135526/http://logstash.net/</a></li>
<li>Logstash Config Language <a href="https://web.archive.org/web/20150907161920/http://logstash.net/docs/1.4.2/configuration">https://web.archive.org/web/20150907161920/http://logstash.net/docs/1.4.2/configuration</a></li>
<li>Accessing Event Data and Fields in the Configuration <a href="https://www.elastic.co/guide/en/logstash/6.5/event-dependent-configuration.html">https://www.elastic.co/guide/en/logstash/6.5/event-dependent-configuration.html</a></li>
<li>Logstash Configuration Examples <a href="https://www.elastic.co/guide/en/logstash/6.5/config-examples.html">https://www.elastic.co/guide/en/logstash/6.5/config-examples.html</a></li>
<li>Logstash Reference: Deploying and Scaling Logstash <a href="https://www.elastic.co/guide/en/logstash/6.8/deploying-and-scaling.html">https://www.elastic.co/guide/en/logstash/6.8/deploying-and-scaling.html</a></li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>ELK</tag>
        <tag>Elastic</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 的并发控制：锁与 MVCC</title>
    <url>/2023/07/innodb-locking/</url>
    <content><![CDATA[<p>目前主流数据库事务的并发控制实现，如 MySQL InnoDB、PostgreSQL、Oracle，都使用两阶段封锁 <a href="https://en.wikipedia.org/wiki/Two-phase_locking">2PL</a> 与 <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a> 技术，但具体实现细节上存在差异。InnoDB 是在以封锁技术为主体的情况下，用 MVCC 技术辅助实现读-写、写-读操作的并发。PostgreSQL 的并发控制技术是以 MVCC 技术为主，封锁技术为辅。本文主要关注 InnoDB 事务的并发控制实现。</p>
<span id="more"></span>
<style>
  .nav-number {
    display: none;
  }
</style>
<h1 id="背景知识">背景知识</h1>
<p>并发控制，是数据库系统的 ACID 特性中的隔离性（<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">Isolation</a>）的保障。所谓隔离性，就是事务的执行不应受到其他并发执行事务的干扰，事务的执行看上去应与其他事务是隔离的。被隔离的执行，等价于事务的某种串行执行，或者说，它等价于一个没有并发的执行。保证串行性可能只允许极小的并发度，采用较弱隔离性，能带来更高的并发度，是并发事务的正确性和性能之间的妥协。</p>
<p>早期各大数据库厂商实现并发控制时多采用基于封锁的并发控制技术，所以在基于封锁的技术背景下，才在 <a href="https://en.wikipedia.org/wiki/SQL-92">ANSI SQL-92</a> 标准中提出了四种隔离级别：未提交读（Read Uncommitted）、己提交读（Read Committed）、可重复读（Repeatable Read）、可串行化（Serializable）（附注：为了书写简便本文将各个隔离级别依次缩写为 RU、RC、RR、SER）。ANSI SQL-92 标准的四种隔离级别，是根据三种读异常现象（phenomena）定义的，隔离级别和异常现象的关系如下：</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>P1 脏读</strong></th>
<th><strong>P2 不可重复读</strong></th>
<th><strong>P4 幻读</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Read Uncommitted</strong></td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td><strong>Read Committed</strong></td>
<td>避免</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td><strong>Repeatable Read</strong></td>
<td>避免</td>
<td>避免</td>
<td>可能</td>
</tr>
<tr>
<td><strong>Serializable</strong></td>
<td>避免</td>
<td>避免</td>
<td>避免</td>
</tr>
</tbody>
</table>
<p>ANSI SQL-92 标准文档对三种读异常现象的定义原文如下 [<a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">ref</a>]：</p>
<blockquote>
<p>The isolation level specifies the kind of phenomena that can occur during the execution of concurrent SQL-transactions. The following phenomena are possible:<br>
<strong>1) P1 (&quot;Dirty read&quot;)</strong>: SQL-transaction T1 modifies a row. SQL-transaction T2 then reads that row before T1 performs a COMMIT. If T1 then performs a ROLLBACK, T2 will have read a row that was never committed and that may thus be considered to have never existed.<br>
<strong>2) P2 (&quot;Non-repeatable read&quot;)</strong>: SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.<br>
<strong>3) P3 (&quot;Phantom&quot;)</strong>: SQL-transaction T1 reads the set of rows N that satisfy some <search condition>. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the <search condition> used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same <search condition>, it obtains a different collection of rows.</p>
</blockquote>
<p>除了脏读、不可重复读和幻读这 3 种读数据异常外，还有写数据异常，即脏写和丢失更新。各个异常的含义如下：</p>
<ul>
<li><strong>P0 脏写（Dirty Write）</strong>：事务 T1 写某数据项，并且未提交或回滚，事务 T2 也写该数据项，然后事务 T1 或事务 T2 回滚，回滚导致另外一个事务的修改被连带回滚。脏写异常会导致事务无法回滚，原子性无法得到保障，所以全部隔离级别下都应该避免。脏写也可以叫回滚丢失。</li>
<li><strong>P1 脏读（Dirty Read）</strong>：读到了其他事务还未提交的数据。</li>
<li><strong>P2 不可重复读（Non-Repeatable）</strong>：事务 T1 读取某数据项，事务 T2 修改 update 或删除 delete 该数据项，事务 T1 再次读取该数据项，结果不同。</li>
<li><strong>P3 幻读（Phantom）</strong>：事务 T1 读取满足某条件的数据项集合，事务 T2 生成新的满足该条件的数据项，事务 T2 再次读取满足该条件的数据项集合，结果不同。</li>
<li><strong>P4 丢失更新（Lost Update）</strong>：事务 T1 读取某数据项，事务 T2 更新该数据项并提交，事务 T1 忽略事务 T2 的更新，直接基于最初的读取数据项做更新并提交，导致事务 T2 的更新丢失。丢失更新也可以叫覆盖丢失。</li>
</ul>
<p>各个异常的读写操作序列的简化符号表示如下 [Berenson 1995]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P0: w1[x]...w2[x]...(c1 or a1)                 事务 T2 脏写</span><br><span class="line">A1: w1[x]...r2[x]...(a1 and c2 in any order)   事务 T2 脏读，r2[x] 为脏读</span><br><span class="line">A2: r1[x]...w2[x]...c2...r1[x]...c1            事务 T1 不可重复读，两次 r1[x] 结果不同</span><br><span class="line">A3: r1[P]...w2[y in P]...c2...r1[P]...c1       事务 T1 幻读，两次 r1[P] 结果不同</span><br><span class="line">P4: r1[x]...w2[x]...w1[x]...c1                 事务 T2 更新丢失，c1 导致 w2[x] 丢失</span><br></pre></td></tr></table></figure>
<p>其中 w1[x] 表示事务 T1 写入记录 x，r1[x] 表示事务 T1 读取记录 x，c1 表示事务 T1 提交，a1 表示事务 T1 回滚，r1[P] 表示事务 T1 按照谓词 P 的条件读取若干条记录，w1[y in P] 表示事务 T1 写入记录 y 满足谓词 P 的条件。</p>
<p>Berenson 的论文评判了 ANSI SQL-92 标准的异常定义。ANSI SQL-92 标准的异常的定义存在歧义，可以严格解释，也可以宽松解释，A1、A2 和 A3 的符号表示为严格解释，按严格解释，某些特殊的异常无法囊括，所以推荐宽松解释。按照标准的定义，容易引起误解的是，在排除 P1 脏读、P2 不可重复、P3 幻读这三种读异常后就会得到可串行化隔离级别，但是事实并非如此。标准没有定义 P0 脏写和 P4 更新丢失异常。另外，基于 MVCC 技术实现的快照隔离（<a href="https://en.wikipedia.org/wiki/Snapshot_isolation">Snapshot Isolation</a>），能避免标准定义的 P1 脏读、P2 不可重复、P3 幻读，并且避免 P0 脏写和 P4 更新丢失，但还存在写偏序（Write Skew）异常。</p>
<p><strong>不可重复读和幻读的区别：</strong></p>
<ul>
<li>不可重复读对于事务 T2 的写操作是更新或删除操作，而幻读对于事务 T2 的写操作是插入（插入的新数据满足条件）或更新（使不满足条件的数据在更新后满足条件）操作。</li>
<li>对于幻读现象中事务 T2 的操作，如果操作是对现有数据的更新或删除操作，则表明这样的操作等同于不可重复读，即是在多个行数据上进行更新或删除，<strong>即在多个行数据上批量化重演了不可重复读现象</strong>。</li>
<li>不可重复读和幻象最大的区别就是前者只需要“锁住”（考虑）已经读过的数据，而幻读需要<strong>对“还不存在的数据“做出预防</strong>。不可重复读现象中事务 T2 着眼于<strong>对现有数据进行操作</strong>；而幻读现象中事务 T2 <strong>着眼于对新增</strong>（或不在锁定范围内已经存在的数据上做更新后而得的数据满足了谓词条件）<strong>数据</strong>。</li>
</ul>
<p><strong>异常由并发冲突引起，对应关系如下：</strong></p>
<ul>
<li>写写冲突：P0 脏写、P4 丢失更新</li>
<li>写读冲突：P1 脏读</li>
<li>读写冲突：P2 不可重复读、P3 幻读</li>
</ul>
<p>早期各大数据库厂商实现并发控制时多采用基于封锁的并发控制技术，所以在基于封锁的技术背景下，才在ANSI SQL 标准中提出了四种隔离级别。基于锁的并发控制技术的加锁方式与隔离级别的关系表 [Berenson 1995]：</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>写锁</strong></th>
<th><strong>数据项的读锁</strong></th>
<th><strong>谓词的读锁</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Read Uncommitted</strong></td>
<td>长写锁</td>
<td>无锁要求</td>
<td>无锁要求</td>
</tr>
<tr>
<td><strong>Read Commited</strong></td>
<td>长写锁</td>
<td>短读锁</td>
<td>短谓词锁</td>
</tr>
<tr>
<td><strong>Repeatable Read</strong></td>
<td>长写锁</td>
<td>长读锁</td>
<td>短谓词锁</td>
</tr>
<tr>
<td><strong>Serializable</strong></td>
<td>长写锁</td>
<td>长读锁</td>
<td>长谓词锁</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong></p>
<ul>
<li>短锁（short duration lock），当前正在执行的语句持有锁，语句执行完毕锁被释放。长锁（long duration lock），当锁被持有后，直到事务提交之后才被释放。</li>
<li>RU 隔离级别，阻止 P0，长写锁</li>
<li>RC 隔离级别，阻止 P0、P1，长写锁 + 短读锁 + 短谓词锁</li>
<li>RR 隔离级别，阻止 P0、P1、P4、P2，长写锁 + 长写锁 + 短谓词锁</li>
<li>SER 隔离级别，阻止 P0、P1、P4、P2、P3，长写锁 + 长写锁 + 长谓词锁</li>
</ul>
<p>基于锁的并发控制下，隔离级别和异常现象的关系：</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>P0 脏写</strong></th>
<th><strong>P1 脏读</strong></th>
<th><strong>P4 丢失更新</strong></th>
<th><strong>P2 不可重复读</strong></th>
<th><strong>P4 幻读</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Read Uncommitted</strong></td>
<td>避免</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td><strong>Read Committed</strong></td>
<td>避免</td>
<td>避免</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td><strong>Repeatable Read</strong></td>
<td>避免</td>
<td>避免</td>
<td>避免</td>
<td>避免</td>
<td>可能</td>
</tr>
<tr>
<td><strong>Serializable</strong></td>
<td>避免</td>
<td>避免</td>
<td>避免</td>
<td>避免</td>
<td>避免</td>
</tr>
</tbody>
</table>
<p>各个隔离级别在基于锁的并发控制技术下的具体的实现说明（参考自腾讯李海翔的《数据库事务处理的艺术》第 2 章）：</p>
<img width="700" alt="基于锁的并发控制" title="基于锁的并发控制" src="https://static.nullwy.me/db-lock-based.png">
<p>基于锁的并发控制，读-读操作可以并发执行，但读-写、写-读、写-写操作无法并发执行，阻塞等待。MVCC 结合封锁技术，使得读－写、写－读操作互不阻塞，即只有写－写操作不能并发，并发度被提高到 75%，这就是 MVCC 被广为使用的原因。</p>
<p>InnoDB 的并发控制以封锁技术为主，MVCC 技术为辅助。让我们先看下 InnoDB 的封锁技术。</p>
<h1 id="共享锁与排他锁">共享锁与排他锁</h1>
<p>InnoDB 存储引擎实现两种标准的<strong>行级锁</strong>模式，共享锁（读锁）和排他锁（写锁）[<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">doc</a>]：</p>
<ul>
<li>共享锁（shared lock，S）：允许事务读一行数据。</li>
<li>排他锁（exclusive Lock，X）：允许事务删除或更新一行数据。</li>
</ul>
<p>如果事务 T1 持有行 r 上的共享锁（S），则来自某个不同事务 T2 的对行 r 上的锁的请求将按如下方式处理：</p>
<ul>
<li>T2 对 S 锁的请求可以立即被授予。因此，T1 和 T2 持有 r 上的锁。</li>
<li>T2 对 X 锁的请求不能立即被授予。</li>
</ul>
<p>如果事务 T1 持有行 r 上的排他锁（X），则某个不同事务 T2 对 r 上任一类型的锁的请求无法立即被授予。相反，事务 T2 必须等待事务 T1 释放其对行 r 的锁定。</p>
<p><strong>共享锁和排他锁的兼容性：</strong></p>
<table>
<thead>
<tr>
<th>待申请 \ 已持有</th>
<th>共享锁 S</th>
<th>排他锁 X</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享锁 S</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>排他锁 X</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody>
</table>
<p><strong>区分共享锁（读锁）和排它锁（写锁）后，读锁与读锁的并发可被允许进行，并发能力得以提高。</strong></p>
<p>对于 <code>update</code>、<code>delete</code> 和 <code>insert</code> 语句，InnoDB 会自动给涉及数据集加排他锁（X）；对于普通 <code>select</code> 语句，InnoDB 不会加任何锁（<code>SERIALIZABLE</code>隔离级别下除外）；事务可以通过以下语句显式给查询 <code>select</code> 显式加共享锁或排他锁：</p>
<ul>
<li>共享锁（S）：<code>select ... for share</code></li>
<li>排他锁（X）：<code>select ... for update</code></li>
</ul>
<p>现在让我们来试验下共享锁和排他锁。创建 <code>tbl</code> 表，并添加表数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl </span><br><span class="line">  (a <span class="type">int</span>, b <span class="type">int</span>, c <span class="type">int</span>, d <span class="type">int</span>, <span class="keyword">primary</span> key(a), <span class="keyword">unique</span> key(b), key(c));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl <span class="keyword">values</span></span><br><span class="line">  (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>), (<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>), </span><br><span class="line">  (<span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>), (<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>), (<span class="number">60</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">60</span>), </span><br><span class="line">  (<span class="number">70</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">70</span>), (<span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>), (<span class="number">90</span>, <span class="number">90</span>, <span class="number">90</span>, <span class="number">90</span>),</span><br><span class="line">  (<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>InnoDB 的排它锁示例，如下：</p>
<table>
<thead>
<tr>
<th><strong>事务1</strong></th>
<th><strong>事务2</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql&gt; begin;</td>
<td>mysql&gt; begin;</td>
</tr>
<tr>
<td>-- 在 a = 10 的索引记录上添加排他锁<br>mysql&gt; select * from tbl where a = 10 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，获取 a = 10 的排他锁超时<br>mysql&gt; update tbl set b = 42 where a = 10;<br>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，获取 a = 10 的排他锁超时<br>mysql&gt; update tbl set b = 42 where a &gt;= 10;</td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，获取 a = 10 的排他锁超时<br>mysql&gt; delete from tbl where a = 10;</td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，获取 a = 10 的排他锁超时<br>mysql&gt; select * from tbl where a = 10 for update;</td>
</tr>
<tr>
<td></td>
<td>-- 更新成功，可以获得其他记录的排他锁<br>mysql&gt; update tbl set b = 42 where a = 20;</td>
</tr>
<tr>
<td>mysql&gt; commit;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 更新成功，在事务 1 释放锁后，其他事务可以获取排他锁<br>mysql&gt; update tbl set b = 42 where a = 10;</td>
</tr>
</tbody>
</table>
<p>InnoDB的共享锁示例，如下：</p>
<table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql&gt; begin;</td>
<td>mysql&gt; begin;</td>
</tr>
<tr>
<td>-- 在 a = 10 的索引记录上添加共享锁<br>mysql&gt; select * from tbl where a = 10 for share;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 获取 a = 10 的共享锁成功<br>mysql&gt; select * from tbl where a = 10 for share;</td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，获取 a = 10 的排他锁超时<br>mysql&gt; update tbl set b = 42 where a = 10;</td>
</tr>
<tr>
<td>mysql&gt; commit;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 更新成功，在事务 1 释放锁后，其他事务可以获取排他锁<br>mysql&gt; update tbl set b = 42 where a = 10;</td>
</tr>
</tbody>
</table>
<h1 id="多粒度与意向锁">多粒度与意向锁</h1>
<p>InnoDB 存储引擎支持多粒度锁定（<a href="https://en.wikipedia.org/wiki/Multiple_granularity_locking">multiple granularity locking</a>），这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB 存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如果需要对页上的记录 r 进行上 X 锁，那么分别需要对数据库 A、表、页上意向锁 IX，最后对记录 r 上 X 锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。</p>
<p>在一个对象加锁之前，该对象的全部祖先节点均加上了意向锁。希望给某个记录加锁的事务必须遍历从根到记录的路径。在遍历树的过程中，该事务给各节点加上意向锁。</p>
<img width="600" alt="粒度层次图" title="粒度层次图" src="https://static.nullwy.me/db-lock-hierarchy.png">
<p>举例来说，假设在表 1 的记录 r 上持有 X 锁，表 1 上必定持有 IX 锁。如果其他事务想在表 1 上加 S 表锁或 X 表锁，但与已有 IX 锁不兼容，所以该事务需要等待。再举例，假设表 1  持有 S 锁，如果其他事务想在表 1 的记录 r 上加 X 锁，需要先获得表 1 的 IX 锁，但与已有 S 锁不兼容，所以该事务需要等待。有了意向锁之后，就能快速判断行锁和表锁之间是否兼容。</p>
<p>InnoDB 存储引擎支持意向锁设计比较简练，其意向锁即为<strong>表级别的锁</strong>，两种意向锁 [<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks">doc</a>]：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁（S），事务在给一个数据行加共享锁（S）前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁（X），事务在给一个数据行加排他锁（X）前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>IS、IX、S、X 锁的兼容性：</strong></p>
<table>
<thead>
<tr>
<th>待申请 \ 已持有</th>
<th><strong>IS</strong></th>
<th><strong>IX</strong></th>
<th><strong>S</strong></th>
<th><strong>X</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IS</strong></td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td><strong>IX</strong></td>
<td>兼容</td>
<td>兼容</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody>
</table>
<p><strong>兼容关系</strong>：各种意向锁（IS、IX）之间全部兼容，意向共享锁 IS 和共享锁 S 兼容，共享锁 S 和共享锁 S 兼容，其他冲突。</p>
<p>SQL 语句可以分为数据定义语言（DDL）、数据控制语言（DCL）、数据查询语言（DQL）、数据操纵语言（DML）四种类型的语句，前两种语句，涉及的对象在数据之上，所以加锁的范围，通常是表级，对应表级锁。后两种语句操作的对象是数据，加锁的范围，通常是数据级，这就对应行级锁。</p>
<h1 id="三种行锁：记录锁、间隙锁和-next-key-锁">三种行锁：记录锁、间隙锁和 next-key 锁</h1>
<p>InnoDB 行锁分为 3 种类型 [<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">doc</a>]：</p>
<ul>
<li><strong>记录锁（record lock）</strong>：对索引记录项加锁。</li>
<li><strong>间隙锁（gap lock）</strong>：间隙锁，对索引记录项之间的“间隙”、笫一条记录前的“间隙”或最后一条记录后的“间隙“加锁。锁定一个范围，但不包含索引记录本身。</li>
<li><strong>next-key 锁（next-key Lock）</strong>：前两种锁的组合，记录锁 + 间隙锁，锁定一个范围，并且锁定索引记录本身。（中文世界有时将 next-key lock 翻译为“临键锁”）</li>
</ul>
<p>如果索引上包含 10, 20, 30, 40, 50 这些记录，那么可能的 next-key 锁的锁区间（<a href="https://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93">interval</a>），如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(-无穷, 10]     即，间隙锁 (-无穷, 10) + 记录锁 10。区间为，左开右闭区间</span><br><span class="line">(10, 20]       即，间隙锁 (10, 20) + 记录锁 20</span><br><span class="line">(20, 30]       即，间隙锁 (20, 30) + 记录锁 30</span><br><span class="line">(30, 40]       即，间隙锁 (30, 40) + 记录锁 40</span><br><span class="line">(40, 50]       即，间隙锁 (40, 50) + 记录锁 50</span><br><span class="line">(50, +无穷]     即，间隙锁 (50, +无穷)</span><br></pre></td></tr></table></figure>
<p>最后一个锁区间 <code>(50, +无穷]</code>，对应的是上界伪记录（<code>supremum pseudo-record</code>），不是真实存在的记录。这个锁区间用于防止在最大值 50 之后插入记录。</p>
<p>记录锁总是会去锁住索引记录，如果 InnoDB 存储引擎表在建立的时候没有设置任何一个索引，那么这时 InnoDB 存储引擎会使用隐式的主键来进行锁定。</p>
<p>MySQL 默认的事务隔离级别是可重复读（REPEATABLE-READ），<strong>如果把事务隔离级别改成已提交读（READ-COMMITTED），间隙锁会被禁用</strong>。禁用间隙锁后，幻读异常会出现，因为其他事务可以在间隙中插入新行。<strong>InnoDB 的间隙锁，就是为了解决幻读异常而引入的</strong>。关于幻读异常，参见官方文档 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html">doc</a>。</p>
<p>RR 隔离级别下，InnoDB 的锁通常使用 next-key 锁。但是，<strong>在唯一索引（和主键索引）上的等值查询</strong>，<strong>next-key 锁退化为记录锁</strong>，间隙锁并不需要，即仅锁住索引本身，而不是范围。<strong>如果在唯一索引（和主键索引）上做范围查询，间隙锁依然需要</strong>。官方文档描述如下 [<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">doc</a>]：</p>
<blockquote>
<p>Gap locking is not needed for statements that lock rows using a unique index to search for a unique row. (This does not include the case that the search condition includes only some columns of a multiple-column unique index; in that case, gap locking does occur.)</p>
</blockquote>
<p><strong>间隙锁是“纯抑制性的”，间隙锁唯一的作用就是为了防止其他事务的插入到间隙中。间隙锁和间隙锁之间是互不冲突的，所以间隙共享 S 锁和间隙排他 X 锁没有任何区别。</strong></p>
<p>另外，还有一种锁叫<strong>插入意向锁（insert intention lock）</strong>，基于间隙锁，专门用于 insert 操作。在执行 insert 操作时，需要先申请获取插入意向锁，也就是说，需要先检查当前插入位置上的下一条记录上是否持有间隙锁，如果被间隙锁锁住，则锁冲突，插入被阻塞。多个事务做 insert 操作，被相同的间隙锁阻塞，如果插入的值各不相同，这些事务的 insert 操作之间不阻塞。</p>
<p>所以，间隙锁与插入意向锁的兼容关系是，已持有的间隙锁与待申请的插入意向锁冲突，而插入意向锁之间兼容，在一个间隙锁锁上可以有多个意向锁等待。</p>
<p><strong>IS、IX、X、S 锁和记录锁、间隙锁、next-key 锁的关系：</strong></p>
<ul>
<li>IS、IX、S、X 是锁模式（lock mode）（源码层面上对应 <a href="https://github.com/mysql/mysql-server/blob/mysql-8.0.30/storage/innobase/include/lock0types.h#L51">lock_mode</a> 枚举）。</li>
<li>记录锁、间隙锁、next-key 锁、插入意向锁是行锁类型（record lock type）。</li>
<li>每一种行锁类型，都包含 IS、IX、S、X 锁模式，如共享的记录锁、排他的记录锁、共享的间隙录锁、排他的间隙锁等。</li>
</ul>
<h1 id="锁监控：data-locks-和-data-lock-waits-表">锁监控：data_locks 和 data_lock_waits 表</h1>
<p>MySQL 8.0 之前，<code>information_schema</code> 库提供 <code>innodb_trx</code>、<code>innodb_locks</code> 和 <code>innodb_lock_waits</code> 三张表，用来监控事务和诊断潜在的锁问题，具体介绍可以参见官方 5.7 文档 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-transactions.html">doc</a>。</p>
<ul>
<li><code>innodb_trx</code>：当前事务表</li>
<li><code>innodb_locks</code>：锁等待中的锁信息表</li>
<li><code>innodb_lock_waits</code>：锁等待中的事务表</li>
</ul>
<p>在 MySQL 8.0 之前，要想获得当前已持有的锁信息，需要开启参数 <code>innodb_status_output_locks</code> 并且执行命令 <code>show engine innodb status</code>，具体介绍可以参见官方文档“15.17 InnoDB Monitors”，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-monitors.html">doc</a>。</p>
<p>MySQL 8.0 开始，<code>innodb_locks</code> 表和 <code>innodb_lock_waits</code> 表，被 <code>performance_schema</code> 库的 <code>data_locks</code> 表和 <code>data_lock_waits</code> 表替代。其中值得注意的不同点是，新的 <code>data_locks</code> 表，同时包含了已持有的锁和请求中的锁的信息，这样查看当前已持有的锁信息更加方便。相关 SQL 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询全部锁信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_locks \G</span><br><span class="line"><span class="comment">-- 查询全部记录锁的锁信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_locks <span class="keyword">where</span> LOCK_TYPE <span class="operator">=</span> <span class="string">&#x27;RECORD&#x27;</span> \G</span><br><span class="line"><span class="comment">-- 查询等待中的锁信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_locks <span class="keyword">where</span> LOCK_STATUS <span class="operator">=</span> <span class="string">&#x27;WAITING&#x27;</span> \G</span><br><span class="line"><span class="comment">-- 查询锁等待中的事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_lock_waits \G</span><br><span class="line"><span class="comment">-- 使用 sys 库的 innodb_lock_waits 视图</span></span><br><span class="line"><span class="comment">-- 查询锁等待中的事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits \G</span><br></pre></td></tr></table></figure>
<p>命令 <code>show engine innodb status</code> 的输出和 <code>data_locks</code> 表的对应关系，可以参考文章 <a href="https://hackmysql.com/post/mysql-data-locks-mapping-80-to-57/">link</a>。</p>
<h1 id="行锁加锁案例分析">行锁加锁案例分析</h1>
<h2 id="RR-隔离级别">RR 隔离级别</h2>
<p>本文的全部案例采用的 MySQL 版本为 8.0.30。MySQL 的默认事务隔离级别是 <code>REPEATABLE-READ</code>（可重复读），事务隔离级别可以通过系统变量 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_transaction_isolation">transaction_isolation</a> 控制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务隔离级别，默认为可重复读（Repeatable Read）</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@global</span>.transaction_isolation, @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@global</span>.transaction_isolation <span class="operator">|</span> @<span class="variable">@transaction_isolation</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ                <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><code>tbl</code> 表的数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> a   <span class="operator">|</span> b    <span class="operator">|</span> c    <span class="operator">|</span> d    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">10</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">30</span> <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">40</span> <span class="operator">|</span>   <span class="number">40</span> <span class="operator">|</span>   <span class="number">40</span> <span class="operator">|</span>   <span class="number">40</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">50</span> <span class="operator">|</span>   <span class="number">50</span> <span class="operator">|</span>   <span class="number">50</span> <span class="operator">|</span>   <span class="number">50</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">60</span> <span class="operator">|</span>   <span class="number">60</span> <span class="operator">|</span>   <span class="number">60</span> <span class="operator">|</span>   <span class="number">60</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">70</span> <span class="operator">|</span>   <span class="number">70</span> <span class="operator">|</span>   <span class="number">70</span> <span class="operator">|</span>   <span class="number">70</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">80</span> <span class="operator">|</span>   <span class="number">80</span> <span class="operator">|</span>   <span class="number">80</span> <span class="operator">|</span>   <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">90</span> <span class="operator">|</span>   <span class="number">90</span> <span class="operator">|</span>   <span class="number">90</span> <span class="operator">|</span>   <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+------+------+</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="a1-主键索引上的等值查询">(a1) 主键索引上的等值查询</h3>
<p><strong>SQL 语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p><code>data_locks</code> 表中的行锁数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_locks <span class="keyword">where</span> LOCK_TYPE <span class="operator">=</span> <span class="string">&#x27;RECORD&#x27;</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: <span class="number">4816436360</span>:<span class="number">185</span>:<span class="number">4</span>:<span class="number">3</span>:<span class="number">140408965390368</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">56664</span></span><br><span class="line">            THREAD_ID: <span class="number">367</span></span><br><span class="line">             EVENT_ID: <span class="number">22</span></span><br><span class="line">        OBJECT_SCHEMA: testdb</span><br><span class="line">          OBJECT_NAME: tbl</span><br><span class="line">       PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">    SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">PRIMARY</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">140408965390368</span></span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>加锁情况：</strong></p>
<ul>
<li>在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</li>
</ul>
<p><strong>其他 SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加共享记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> b <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>加锁与锁冲突 SQL 演示：</p>
<table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql&gt; begin;</td>
<td>mysql&gt; begin;</td>
</tr>
<tr>
<td>-- 在 a = 10 的索引记录上添加排他记录锁<br>mysql&gt; select * from tbl where a = 10 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，因为 a = 10 上存在排他记录锁<br>mysql&gt; select * from tbl where a = 10 for update;<br>-- 阻塞，因为 a = 10 上存在排他记录锁<br>mysql&gt; insert into tbl (a) values (10);</td>
</tr>
<tr>
<td></td>
<td>-- 插入成功<br>mysql&gt; insert into tbl (a) values (9);<br>-- 插入成功<br>mysql&gt; insert into tbl (a) values (11);</td>
</tr>
<tr>
<td>mysql&gt; rollback;</td>
<td>mysql&gt; rollback;</td>
</tr>
</tbody>
</table>
<h3 id="a2-唯一索引上的等值查询">(a2) 唯一索引上的等值查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 b = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 覆盖索引，但系统会认为接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</span></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 10 的索引记录上添加共享记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加共享记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 10 的索引记录上添加共享记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 覆盖索引，所以只在字段 b 上加锁</span></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> b <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上面的全部 SQL，除了走覆盖索引的 <code>select for share</code> 外，其他的加锁范围都相同。</p>
<h3 id="a3-非唯一索引上的等值查询">(a3) 非唯一索引上的等值查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他 next-key 锁，区间为 (-无穷, 10]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 c = 20 的索引记录上添加排他间隙锁，区间为 (10, 20)（X,GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加共享 next-key 锁，区间为 (-无穷, 10]（S）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加共享记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 c = 20 的索引记录上添加共享间隙锁，区间为 (10, 20)（S,GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加共享 next-key 锁，区间为 (-无穷, 10]（S）</span></span><br><span class="line"><span class="comment">-- 在 c = 20 的索引记录上添加共享间隙锁，区间为 (10, 20)（S,GAP）</span></span><br><span class="line"><span class="comment">-- 覆盖索引，所以只在字段 c 上加锁</span></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他 next-key 锁，区间为 (-无穷, 10]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 c = 20 的索引记录上添加排他间隙锁，区间为 (10, 20)（X,GAP）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> c <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他 next-key 锁，区间为 (-无穷, 10]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 c = 20 的索引记录上添加排他间隙锁，区间为 (10, 20)（X,GAP）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上面的全部 SQL，除了走覆盖索引的 <code>select for share</code> 外，其他的加锁范围都相同。</p>
<p>加锁与锁冲突 SQL 演示：</p>
<table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql&gt; begin;</td>
<td>mysql&gt; begin;</td>
</tr>
<tr>
<td>-- 在 c = 10 的索引记录上添加排他 next-key 锁，区间为 (-无穷, 10]<br>-- 在 a = 10 的索引记录上添加排他记录锁<br>-- 在 c = 20 的索引记录上添加排他间隙锁，区间为 (10, 20)<br>mysql&gt; select * from tbl where c = 10 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，因为 c = 10 上存在排他 next-key 锁<br>mysql&gt; select * from tbl where c = 10 for update;<br>-- 阻塞，因为 a = 10 上存在排他记录锁<br>mysql&gt; select * from tbl where a = 10 for update;</td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，因为 c = 10 上存在排他 next-key 锁，区间为 (-无穷, 10]<br>mysql&gt; insert into tbl (a, c) values (1, 9);<br>-- 阻塞，因为 c = 10 上存在排他 next-key 锁，区间为 (-无穷, 10]<br>mysql&gt; insert into tbl (a, c) values (1, 10);</td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，因为 c = (10, 20) 区间存在间隙锁<br>mysql&gt; insert into tbl (a, c) values (1, 11);<br>-- 插入成功<br>mysql&gt; insert into tbl (a, c) values (1, 21);</td>
</tr>
<tr>
<td>mysql&gt; rollback;</td>
<td>mysql&gt; rollback;</td>
</tr>
</tbody>
</table>
<h3 id="a4-无索引的等值查询">(a4) 无索引的等值查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 a 主键的全部索引记录上添加排他 next-key 锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> d <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>因为字段 d 上没有索引，这个 SQL 语句，只能在聚簇索引上全表扫描。加锁情况，在 a 主键的全部索引记录上添加排他 next-key 锁。表 <code>tbl</code> 共 10 条记录，全部的持有的 next-key 锁的锁区间，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(-无穷, 10]</span><br><span class="line">  (10, 20]</span><br><span class="line">  (20, 30]</span><br><span class="line">  (30, 40]</span><br><span class="line">  (40, 50]</span><br><span class="line">  (50, 60]</span><br><span class="line">  (60, 70]</span><br><span class="line">  (70, 80]</span><br><span class="line">  (80, 90]</span><br><span class="line">  (90, 100]</span><br><span class="line">(100, +无穷]</span><br></pre></td></tr></table></figure>
<h3 id="a5-值不存在的等值查询">(a5) 值不存在的等值查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---- 主键索引上的值不存在的等值查询</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他间隙锁，区间为 (90, 100)（X,GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">95</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 在 a 的索引记录上添加排他 next-key 锁，区间为 (100, +无穷]（X）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">---- 唯一索引上的值不存在的等值查询</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加间隙锁，区间为 (90, 100)（X,GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">95</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 在 b 的索引记录上添加排他 next-key 锁，区间为 (100, +无穷]（X）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">---- 非唯一索引上的值不存在的等值查询</span></span><br><span class="line"><span class="comment">-- 在 c = 100 的索引记录上添加间隙锁，区间为 (90, 100)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">95</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 在 c 的索引记录上添加排他 next-key 锁，区间为 (100, +无穷]（X）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<h3 id="b1-主键索引上的范围查询">(b1) 主键索引上的范围查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）</span></span><br><span class="line"><span class="comment">-- 在 a 的索引记录上添加排他 next-key 锁，区间为 (100, +无穷]（X）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a 的索引记录上添加排他 next-key 锁，区间为 (100, +无穷]（X）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他间隙锁，区间为 (90, 100)（X,GAP）</span></span><br><span class="line"><span class="comment">-- 附注：与主键上的等值查询 `a = 90` 的加锁范围的区别是额外加了区间为 (90, 100) 间隙锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> a <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他间隙锁，区间为 (90, 100)（X,GAP）</span></span><br><span class="line"><span class="comment">-- 附注：与相同查询条件的 `select for update`，加锁范围相同</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> d <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> a <span class="operator">&lt;</span> <span class="number">91</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他间隙锁，区间为 (90, 100)（X,GAP）</span></span><br><span class="line"><span class="comment">-- 附注：与相同查询条件的 `select for update` 的 SQL，加锁范围相同</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> a <span class="operator">&lt;</span> <span class="number">91</span>;</span><br></pre></td></tr></table></figure>
<h3 id="b2-唯一索引上的范围查询">(b2) 唯一索引上的范围查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b 的索引记录上添加排他 next-key 锁，区间为 (100, +无穷]（X）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> d <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">91</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">91</span>;</span><br></pre></td></tr></table></figure>
<p>加锁与锁冲突 SQL 演示：</p>
<table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql&gt; begin;</td>
<td>mysql&gt; begin;</td>
</tr>
<tr>
<td>-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]<br>-- 在 a = 90 的索引记录上添加排他记录锁<br>-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]<br>mysql&gt; select * from tbl where b &gt;= 90 and b &lt; 91 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 阻塞，因为 b = 90 上存在排他 next-key 锁<br>mysql&gt; select * from tbl where b = 90 for update;<br>-- 阻塞，因为 b = 100 上存在排他 next-key 锁（不必要的记录锁）<br>mysql&gt; select * from tbl where b = 100 for update;<br>-- 阻塞，因为 a = 90 上存在排他记录锁<br>mysql&gt; select * from tbl where a = 90 for update;</td>
</tr>
<tr>
<td>mysql&gt; rollback;</td>
<td>mysql&gt; rollback;</td>
</tr>
</tbody>
</table>
<h3 id="b3-非唯一索引上的范围查询">(b3) 非唯一索引上的范围查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b 的索引记录上添加排他 next-key 锁，区间为 (100, +无穷]（X）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 c = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> d <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> c <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">91</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">91</span>;</span><br></pre></td></tr></table></figure>
<p>对比，唯一索引上的范围查询的加锁情况，容易得出结论，<strong>唯一索引和普通索引上的范围查询的加锁规则相同</strong>。</p>
<h2 id="RC-隔离级别">RC 隔离级别</h2>
<p>把事务隔离级别修改为已提交读（Read Committed）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务隔离级别，修改为已提交读（Read Committed）</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> @<span class="variable">@transaction_isolation</span> <span class="operator">=</span> <span class="string">&#x27;READ-COMMITTED&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="a1-主键索引上的等值查询-v2">(a1) 主键索引上的等值查询</h3>
<p><strong>SQL 语句的加锁情况（通过查 <code>data_locks</code> 表确认）：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加共享记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> b <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>结论：因为主键索引上的等值查询不涉及间隙锁，所以 RR 和 RC 隔离级别下的加锁规则相同。</p>
<h3 id="a2-唯一索引上的等值查询-v2">(a2) 唯一索引上的等值查询</h3>
<p>同样的，因为唯一索引上的等值查询不涉及间隙锁，所以 RR 和 RC 隔离级别下的加锁规则相同。</p>
<h3 id="a3-非唯一索引上的等值查询-v2">(a3) 非唯一索引上的等值查询</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他记录锁（S,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 覆盖索引，所以只在字段 b 上加锁</span></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> share;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> c <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 c = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="a4-无索引的等值查询-v2">(a4) 无索引的等值查询</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 a = 10 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> d <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<h3 id="a5-值不存在的等值查询-v2">(a5) 值不存在的等值查询</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---- 主键索引上的值不存在的等值查询</span></span><br><span class="line"><span class="comment">-- 无锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">95</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 无锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">---- 唯一索引上的值不存在的等值查询</span></span><br><span class="line"><span class="comment">-- 无锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">95</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 无锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">---- 非唯一索引上的值不存在的等值查询</span></span><br><span class="line"><span class="comment">-- 无锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">95</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 无锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<h3 id="b1-主键索引上的范围查询-v2">(b1) 主键索引上的范围查询</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> a <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> d <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> a <span class="operator">&lt;</span> <span class="number">91</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> a <span class="operator">&lt;</span> <span class="number">91</span>;</span><br></pre></td></tr></table></figure>
<h3 id="b2-唯一索引上的范围查询-v2">(b2) 唯一索引上的范围查询</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">update</span> tbl <span class="keyword">set</span> d <span class="operator">=</span> <span class="number">42</span> <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">91</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">91</span>;</span><br></pre></td></tr></table></figure>
<h3 id="b3-非唯一索引上的范围查询-v2">(b3) 非唯一索引上的范围查询</h3>
<p>加锁情况，和 RC 隔离级别的唯一索引上的范围查询完全相同。</p>
<h1 id="行锁加锁规则总结">行锁加锁规则总结</h1>
<p><strong>RC 隔离级别时的加锁规则：</strong></p>
<ul>
<li>间隙锁被禁用，只有记录锁，没有间隙锁和 next-key 锁。</li>
<li>对全部满足查询条件的索引记录加记录锁。如果查询条件满足覆盖索引，就只对辅助索引加记录锁。如果需要回表，对辅助索引记录和聚簇索引记录引同时加锁。</li>
<li>如果不存在满足查询条件的索引记录，就不加锁。</li>
</ul>
<p><strong>RR 隔离级别时的加锁规则：</strong></p>
<ul>
<li>加锁的基本单位是 next-key 锁。</li>
<li>对全部满足查询条件的索引记录加 next-key 锁。如果查询条件满足覆盖索引，就只对辅助索引加记录锁。如果需要回表，对辅助索引记录和聚簇索引记录引同时加锁。</li>
<li>范围查询时，或值不存在的等值查询时，在从右扫描到的最后的不满足查询条件的记录上加<strong>间隙锁</strong>。如果索引的最大记录值，满足查询条件，则在上界伪记录（supremum pseudo-record）上加 next-key 锁（相当于间隙锁）。</li>
<li>等值查询时，在主键索引和唯一索引上加锁，next-key 锁退化为记录锁。</li>
</ul>
<h2 id="范围查询时的不必要加锁-bug">范围查询时的不必要加锁 bug</h2>
<p>注意，RR 隔离级别时，在主键索引上的范围查询时，确实是按上文的规则加<strong>间隙锁</strong>。但实际验证发现，在辅助索引（包括唯一索引和普通索引）上的范围查询时，在最后的不满足查询条件的记录上实际加的是 <strong>next-key 锁</strong>。这样加锁的问题是，会在不满足查询条件的记录上记录锁，这个记录锁其实是不必要的，是一个 bug。</p>
<p>其实，这个不必要的记录锁 bug，在 MySQL 8.0.18 之前，主键索引的场景下也存在，MySQL 8.0.18 修复了，但只修复了主键索引的场景，辅助索引的场景未修复。修复对应 bug 为“Bug #29508068 UNNECESSARY NEXT-KEY LOCK TAKEN”，修复提交记录见 <a href="https://github.com/mysql/mysql-server/commit/d1b0afd75ee669f54b70794eb6dab6c121f1f179">github</a>。</p>
<p>在 MySQL 8.0.19 版本上，有人再次提了 bug，“Bug #<a href="https://bugs.mysql.com/bug.php?id=98639">98639</a> Redundant row-level locking for secondary index”。不过 MySQL 官方认为“Not a Bug”。然后，提 bug 的人，也只好妥协认为这个是“performance issue”。</p>
<p>对比下面这 3 个 SQL 的加锁情况，可以发现后 2 个 SQL 存在不必要的加锁问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 主键索引上的范围查询</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 a = 100 的索引记录上添加排他间隙锁，区间为 (90, 100)（X,GAP）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> a <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 唯一索引上的范围查询</span></span><br><span class="line"><span class="comment">-- 在 b = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 b = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非唯一索引上的范围查询</span></span><br><span class="line"><span class="comment">-- 在 c = 90 的索引记录上添加排他 next-key 锁，区间为 (80, 90]（X）</span></span><br><span class="line"><span class="comment">-- 在 a = 90 的索引记录上添加排他记录锁（X,REC_NOT_GAP）</span></span><br><span class="line"><span class="comment">-- 在 c = 100 的索引记录上添加排他 next-key 锁，区间为 (90, 100]（X）（不必要的记录锁）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> c <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">91</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<h1 id="隔离级别的实现">隔离级别的实现</h1>
<p>上文提到，PostgreSQL 的并发控制技术是以 MVCC 技术为主，封锁技术为辅。先看下 PostgreSQL 对隔离级别的实现 [<a href="https://www.postgresql.org/docs/15/transaction-iso.html">doc</a>]：</p>
<ul>
<li>PostgreSQL 支持 SQL 标准的 4 种隔离级别，默认的隔离级别是 RC。但 PostgreSQL 内部只实现 3 种隔离级别 RC、RR 和 SER。若选择 RU 隔离，实际上是 RC。</li>
<li>PostgreSQL 的 RR 隔离级别，底层是基于 MVCC 技术实现的快照隔离（SI，<a href="https://en.wikipedia.org/wiki/Snapshot_isolation">Snapshot Isolation</a>）。快照隔离下，能避免 SQL-92 定义的三种异常，脏读、不可重复读和幻读异常，但是可能会出现写偏序（Write Skew）异常。</li>
<li>PostgreSQL 的 SER 隔离，底层是可串行化的快照隔离（SSI，Serializable Snapshot Isolation）。</li>
</ul>
<p>InnoDB 的并发控制以封锁技术为主，MVCC 技术辅助，各个隔离级别的具体实现是：</p>
<ul>
<li>RC 隔离级别：快照读 + 写长锁
<ul>
<li>快照读，能避免脏读</li>
</ul>
</li>
<li>RR 隔离级别：快照读 + 写长锁 + 间隙锁（没有实现真正的快照隔离 SI）
<ul>
<li>快照读，能一定程度避免不可重复读和幻读异常，但因为 InnoDB 的刷新快照的特殊实现，不能完全避免</li>
<li>间隙锁，能避免幻读异常，只有锁定读时才会申请获取间隙锁</li>
</ul>
</li>
<li>可串行化隔离级别：读长锁 + 写长锁 + 间隙锁
<ul>
<li>完全基于锁实现串行化，并发度很低，性能不好</li>
</ul>
</li>
</ul>
<p>InnoDB 实现的 MVCC 技术，能让事务以<strong>快照读</strong>的方式执行查询。<strong>快照读</strong>（<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read">snapshot read</a>），或者叫一致性非锁定读（consistent nonlocking read），或者一致性读（consistent read），即使用多版本技术实现的读取数据在某个时间点的快照的查询。在 RR 和 RC 隔离级别下，一致性读是普通的 <code>select</code> 语句的默认模式。快照读<strong>避免加锁</strong>，从而提高并发度。在 RR 和 RC 隔离级别下快照读的区别：</p>
<ul>
<li>RR 隔离级别时，事务中的所有一致性读都会读取该事务中第一次此类读取建立的快照。</li>
<li>RC 隔离级别时，事务中的每个一致性读都会设置并读取其自己的最新快照，快照是最新已提交的数据。</li>
</ul>
<p>如果事务在查询数据后，要对该数据做修改操作，快照读无法提供足够的保护，因为其他事务可以对这些数据做修改操作。为了提供额外的保护，InnoDB 提供<strong>锁定读</strong>（<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking_read">locking read</a>），即同时执行锁定操作的 <code>select</code> 语句，锁持有直到事务结束。锁定读分两种：</p>
<ul>
<li><code>select ... for share</code> 是加共享锁的查询数据</li>
<li><code>select ... for update</code> 是加排他锁的查询数据</li>
</ul>
<h2 id="RR-隔离级别下的不可重复读和幻读异常">RR 隔离级别下的不可重复读和幻读异常</h2>
<p>上文提到，“快照读，能一定程度避免不可重复读和幻读异常，但因为 InnoDB 的刷新快照的特殊实现，不能完全避免”。现在来看下 RR 隔离级别下的不可重复读异常的示例：</p>
<table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql&gt; begin;</td>
<td>mysql&gt; begin;</td>
</tr>
<tr>
<td>-- 返回值为 10，快照读<br>mysql&gt; select b from tbl where a = 10;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-- 把 b 值修改为 0<br>mysql&gt; update tbl set b = 0 where a = 10;<br>mysql&gt; commit;</td>
</tr>
<tr>
<td>-- 返回值为 10，没有出现不可重复读异常<br>mysql&gt; select b from tbl where a = 10;</td>
<td></td>
</tr>
<tr>
<td>-- update 会读取 a = 10 的已提交的最新值<br>-- 同时 a = 10 记录的快照会被刷新<br>mysql&gt; update tbl set b = b + 1 where a = 10;</td>
<td></td>
</tr>
<tr>
<td>-- 返回值为 1，出现不可重复读异常<br>mysql&gt; select b from tbl where a = 10;</td>
<td></td>
</tr>
</tbody>
</table>
<p>这个问题在 MySQL 的 Bug 系统中可以找到，参见：Bug #<a href="https://bugs.mysql.com/bug.php?id=57973">57973</a>、Bug #<a href="https://bugs.mysql.com/bug.php?id=63870">63870</a> 等。官方认为，这不是 Bug，InnoDB 就是按这种方式设计。Bug #57973 下 MySQL 工程师 Kevin Lewis 对这个问题的解答 [<a href="https://bugs.mysql.com/bug.php?id=57973#c403965">ref</a>]：</p>
<blockquote>
<p><strong>[16 Aug 2013 19:23] Kevin Lewis</strong><br>
Rejecting this bug because InnoDB is working as designed for the following reason;<br>
...<br>
But when InnoDB Repeatable Read transactions modify the database, it is possible to get phantom reads added into the static view of the database, just as the ANSI description allows.  Moreover, <strong>InnoDB relaxes the ANSI description for Repeatable Read isolation in that it will also allow non-repeatable reads during an UPDATE or DELETE. Specifically, it will write to newly committed records within its read view</strong>.  And because of gap locking, it will actually wait on other transactions that have pending records that may become committed within its read view.  So not only is an UPDATE or DELETE affected by pending or newly committed records that satisfy the predicate, but also 'SELECT … LOCK IN SHARE MODE' and 'SELECT … FOR UPDATE'.<br>
This WRITE COMMITTED implementation of REPEATABLE READ is not typical of any other database that I am aware of.  But it has some real advantages over a standard 'Snapshot' isolation.  When an update conflict would occur in other database engines that implement a snapshot isolation for Repeatable Read, an error message would typically say that you need to restart your transaction in order to see the current data. So the normal activity would be to restart the entire transaction and do the same changes over again.  But InnoDB allows you to just keep going with the current transaction by waiting on other records which might join your view of the data and including them on the fly when the UPDATE or DELETE is done.  This WRITE COMMITTED implementation combined with implicit record and gap locking actually adds a serializable component to Repeatable Read isolation.</p>
</blockquote>
<p>就是说，InnoDB 实现的 RR 隔离级别，放松了 SQL 标准对 RR 隔离级别的要求。事务 T1 在快照读后，如果其他事务 T2 修改了快照对应的记录并提交，之后事务 T1 执行涉及快照的 DML 语句（update、delete、insert）或锁定读，会触发快照刷新，事务 T2 最新提交的修改会刷新进快照。最终导致事务 T1 再次执行相同条件的快照读，读取结果不同，出现不可重复读或幻读异常。<strong>简单概括就是，在快照失效后，又刷新快照，导致两次读到的快照不同。另外，如果实现上选择不刷新快照，并且事务 T1 正常执行，会出现 P4 丢失更新异常。</strong></p>
<p><strong>不可重复读异常的避免（一定程度上避免，但没有完全避免）：</strong></p>
<ul>
<li>如果事务重复的两次读都是快照读（普通 <code>select</code> 语句），并且中间没有执行涉及快照的 DML 或锁定读，这样两次读到的是相同的快照读，所以不会出现不可重复读异常。</li>
<li>如果事务重复的两次读都是当前读（<code>select for update/share</code>），因为第一次加锁，其他事务无法更新该记录，所以也不会出现不可重复读异常。</li>
<li>如果事务重复的两次读都是快照读，但是中间执行涉及快照的 DML 或锁定读，触发了快照刷新，如果快照被更新，就会出现不可重复读异常。</li>
</ul>
<p><strong>幻读异常的避免（一定程度上避免，但没有完全避免）：</strong></p>
<ul>
<li>如果事务重复的两次读都是快照读（普通 <code>select</code> 语句），并且中间没有执行涉及快照的 DML 或锁定读，这样两次读到的是相同的快照读，所以不会出现幻读异常。</li>
<li>如果事务重复的两次读都是当前读（<code>select for update/share</code>），因为第一次当前读加间隙锁，其他事务无法插入，被阻塞，所以也不会出现幻读异常。</li>
<li>如果事务重复的两次读都是快照读，但是中间执行涉及快照的 DML 或锁定读，触发了快照刷新，如果快照被更新，就会出现幻读异常。</li>
</ul>
<p>上述的<strong>快照失效</strong>的场景，PostgreSQL 的处理方式是，事务会被回滚并报错提示，应用程序收到这个报错，可以尝试重试，重试的事务读到的快照是最新的，这样即避免丢失更新异常，也避免了幻读和不可重复读异常（参见官方文档 <a href="https://www.postgresql.org/docs/15/transaction-iso.html#XACT-REPEATABLE-READ">doc</a>）。</p>
<h1 id="参考资料">参考资料</h1>
<p><strong>MySQL 8.0 Reference Manual</strong></p>
<ul>
<li>15.7 InnoDB Locking and Transaction Model <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-transaction-model.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-transaction-model.html</a>
<ul>
<li>15.7.1 InnoDB Locking <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</a></li>
<li>15.7.2 InnoDB Transaction Model <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html</a></li>
<li>15.7.3 Locks Set by Different SQL Statements in InnoDB <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html</a></li>
<li>15.7.4 Phantom Rows <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html</a></li>
</ul>
</li>
<li>15.15 InnoDB INFORMATION_SCHEMA Tables
<ul>
<li>15.15.2 InnoDB INFORMATION_SCHEMA Transaction and Locking Information <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema-transactions.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema-transactions.html</a></li>
</ul>
</li>
<li>15.17 InnoDB Monitors <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-monitors.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-monitors.html</a></li>
</ul>
<p><strong>其他参考资料：</strong></p>
<ul>
<li>Hal Berenson, <a href="https://en.wikipedia.org/wiki/Phil_Bernstein">Philip A. Bernstein</a>, <a href="https://en.wikipedia.org/wiki/Jim_Gray_%28computer_scientist%29">Jim Gray</a>, Jim Melton, Elizabeth J. O'Neil, Patrick E. O'Neil: <strong>A Critique of ANSI SQL Isolation Levels</strong>. SIGMOD Conference 1995: 1-10（隔离级别的经典论文，其中作者 Jim Gray 因“对数据库和事务处理研究的开创性贡献以及系统实现方面的技术领导力”而于 1998 年获得图灵奖）</li>
<li>数据库事务处理的艺术，腾讯李海翔 2017</li>
<li>MySQL技术内幕：InnoDB存储引擎，姜承尧 第2版2013：第6章 锁</li>
<li>2013-12 何登成：MySQL 加锁处理分析 <a href="https://web.archive.org/web/0/http://hedengcheng.com/?p=771">https://web.archive.org/web/0/http://hedengcheng.com/?p=771</a> <a href="https://bit.ly/44rsCH7">https://bit.ly/44rsCH7</a></li>
<li>2019-04 阿里王德浩/孟勃荣：开发者都应该了解的数据库隔离级别 <a href="https://mp.weixin.qq.com/s/bFg8XFYd9HLvEoYyzAD3jg">https://mp.weixin.qq.com/s/bFg8XFYd9HLvEoYyzAD3jg</a></li>
<li>2021-07 MySQL Data Locks: Mapping 8.0 to 5.7 <a href="https://hackmysql.com/post/mysql-data-locks-mapping-80-to-57/">https://hackmysql.com/post/mysql-data-locks-mapping-80-to-57/</a></li>
<li>2019-07 Bug #29508068 UNNECESSARY NEXT-KEY LOCK TAKEN (MySQL 8.0.18 发布) <a href="https://github.com/mysql/mysql-server/commit/d1b0afd75ee669f54b70794eb6dab6c121f1f179">https://github.com/mysql/mysql-server/commit/d1b0afd75ee669f54b70794eb6dab6c121f1f179</a></li>
<li>2020-02 Bug #98639 Redundant row-level locking for secondary index (8.0.19) <a href="https://bugs.mysql.com/bug.php?id=98639">https://bugs.mysql.com/bug.php?id=98639</a></li>
<li>2010-11 Bug #57973 UPDATE tries to lock rows not visible to read view <a href="https://bugs.mysql.com/bug.php?id=57973#c403965">https://bugs.mysql.com/bug.php?id=57973#c403965</a></li>
<li>2011-12 Bug #63870 Repeatable-read isolation violated in UPDATE (5.1.42, 5.5.20) <a href="https://bugs.mysql.com/bug.php?id=63870">https://bugs.mysql.com/bug.php?id=63870</a></li>
<li>PostgreSQL Documentation: 13.2. Transaction Isolation <a href="https://www.postgresql.org/docs/15/transaction-iso.html">https://www.postgresql.org/docs/15/transaction-iso.html</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
        <tag>锁</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>iText处理pdf书签和标注代码乱记</title>
    <url>/2016/12/itext-pdf/</url>
    <content><![CDATA[<p>将文档1中的书签转存到文档2﻿​：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PdfReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfReader</span>(<span class="string">&quot;in1.pdf&quot;</span>);</span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; bookmarks = SimpleBookmark.getBookmark(reader1);</span><br><span class="line"> </span><br><span class="line"><span class="type">PdfReader</span> <span class="variable">reader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfReader</span>(<span class="string">&quot;in2.pdf&quot;</span>);</span><br><span class="line"><span class="type">PdfStamper</span> <span class="variable">stamper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfStamper</span>(reader2, <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.pdf&quot;</span>));</span><br><span class="line">stamper.getWriter().setOutlines(bookmarks);</span><br><span class="line">stamper.close();</span><br></pre></td></tr></table></figure>
<p>导出书签文件﻿​：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PdfReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfReader</span>(<span class="string">&quot;in.pdf&quot;</span>);</span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; bookmarks = SimpleBookmark.getBookmark(reader);</span><br><span class="line">SimpleBookmark.exportToXML(bookmarks, <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.xml&quot;</span>), <span class="string">&quot;utf-8&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">导入书签到文件﻿​：</span><br><span class="line"><span class="type">PdfReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfReader</span>(<span class="string">&quot;in.pdf&quot;</span>);</span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; bookmarks = SimpleBookmark.importFromXML(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;out.xml&quot;</span>));</span><br><span class="line"><span class="type">PdfStamper</span> <span class="variable">stamper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfStamper</span>(reader, <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.pdf&quot;</span>));</span><br><span class="line">stamper.getWriter().setOutlines(bookmarks);</span><br><span class="line">stamper.close();</span><br></pre></td></tr></table></figure>
<p>将文档1中的标注（包括超链接）转存到文档2﻿​：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PdfReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfReader</span>(<span class="string">&quot;in1.pdf&quot;</span>);</span><br><span class="line"><span class="type">PdfReader</span> <span class="variable">reader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfReader</span>(<span class="string">&quot;in2.pdf&quot;</span>);</span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>(reader2.getPageSize(<span class="number">3</span>));</span><br><span class="line"><span class="type">PdfWriter</span> <span class="variable">writer</span> <span class="operator">=</span> PdfWriter.getInstance(document, <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.pdf&quot;</span>));</span><br><span class="line">document.open();</span><br><span class="line"> </span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; bookmarks = SimpleBookmark.getBookmark(reader1);</span><br><span class="line">writer.setOutlines(bookmarks);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> reader1.getNumberOfPages();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    <span class="type">PdfImportedPage</span> <span class="variable">page</span> <span class="operator">=</span> writer.getImportedPage(reader2, i);</span><br><span class="line">    <span class="type">PdfContentByte</span> <span class="variable">content</span> <span class="operator">=</span> writer.getDirectContent();</span><br><span class="line">    content.addTemplate(page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">PdfDictionary</span> <span class="variable">pageDict</span> <span class="operator">=</span> reader1.getPageN(i);</span><br><span class="line">    <span class="type">PdfArray</span> <span class="variable">annotArray</span> <span class="operator">=</span> pageDict.getAsArray(PdfName.ANNOTS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; annotArray != <span class="literal">null</span> &amp;&amp; j &lt; annotArray.size(); ++j) &#123;</span><br><span class="line">        <span class="type">PdfDictionary</span> <span class="variable">curAnnot</span> <span class="operator">=</span> annotArray.getAsDict(j);</span><br><span class="line">        <span class="type">PdfAnnotation</span> <span class="variable">pdfAnnot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfAnnotation</span>(writer, <span class="literal">null</span>);</span><br><span class="line">        pdfAnnot.putAll(curAnnot);</span><br><span class="line">        writer.addAnnotation(pdfAnnot);</span><br><span class="line">    &#125;</span><br><span class="line">    document.newPage();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">document.close();</span><br><span class="line">reader1.close();</span><br><span class="line">reader2.close();</span><br></pre></td></tr></table></figure>
<p>如果仅仅读取全部链接，只需将上述代码18行开始的for循环修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; annotArray != <span class="literal">null</span> &amp;&amp; j &lt; annotArray.size(); ++j) &#123;</span><br><span class="line">    <span class="type">PdfDictionary</span> <span class="variable">curAnnot</span> <span class="operator">=</span> annotArray.getAsDict(j);</span><br><span class="line">    <span class="keyword">if</span> (PdfName.LINK.equals(curAnnot.getAsName(PdfName.SUBTYPE))) &#123;</span><br><span class="line">        <span class="type">PdfAnnotation</span> <span class="variable">pdfAnnot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfAnnotation</span>(writer, <span class="literal">null</span>);</span><br><span class="line">        pdfAnnot.putAll(curAnnot);</span><br><span class="line">        writer.addAnnotation(pdfAnnot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<ol>
<li>iText 5 examples - iText 5 actions and annotations <a href="http://developers.itextpdf.com/content/itext-5-examples">http://developers.itextpdf.com/content/itext-5-examples</a></li>
<li>iText in Action, 2nd 2010, 7. Making documents interactive <a href="https://www.manning.com/books/itext-in-action-second-edition">https://www.manning.com/books/itext-in-action-second-edition</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>代码</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 的 Stream API 笔记</title>
    <url>/2016/12/java-8-stream-api/</url>
    <content><![CDATA[<p>Java 8增加了函数式编程的能力，通过流（Stream）API来支持对集合的<a href="https://en.wikipedia.org/wiki/Filter_%28higher-order_function%29">filter</a>/<a href="https://en.wikipedia.org/wiki/Map_%28higher-order_function%29">map</a>/<a href="https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29">reduce</a>操作。流是Java 8中处理集合的关键抽象概念，实现声明式的集合处理方式。</p>
<span id="more"></span>
<h1 id="Java-8流API示例">Java 8流API示例</h1>
<p>对集合的filter、map和reduce操作，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算偶数个数</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream()</span><br><span class="line">        .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选出偶数列表</span></span><br><span class="line">List&lt;Integer&gt; evenList = list.stream()</span><br><span class="line">        .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(evenList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选出偶数列表, 然后全部元素加1</span></span><br><span class="line">List&lt;Integer&gt; plusList = list.stream()</span><br><span class="line">        .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .map(x -&gt; x + <span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(plusList); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部偶数求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream()</span><br><span class="line">        .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .mapToInt(Integer::intValue).sum();</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部偶数求和</span></span><br><span class="line">sum = list.stream()</span><br><span class="line">        .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>
<h1 id="流与集合的区别">流与集合的区别</h1>
<p>流（Stream）和集合（collection）有以下区别 [<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description">doc</a>]：</p>
<ul>
<li><strong>无存储</strong>（no storage）。流并不是存储元素的数据结构。流，通过计算的操作流水线来传输数据源。数据源，比如数据结构、数组、生成器函数或I/O通道。</li>
<li><strong>原生函数式</strong>（functional in nature）。对流进行操作会产生结果，但并不会修改数据源。比如，筛选流，是生成一个不包含被筛选掉的元素新流，而不是从原集合中删除元素。</li>
<li><strong>惰性读取</strong>（laziness-seeking）。很多对流的操作，比如筛选（filtering）、映射（mapping）或去重（duplicate removal），能够被惰性实现，以便于性能的优化。比如，“找出第一个由三个连续单词组成的String”，并不需要检测全部的输入字符串。流操作被划分为<em>中间操作</em>（用于生成流）和<em>终止操作</em>（用于生成值或副作用）。中间操作总是惰性的。</li>
<li><strong>可能是无界的</strong>（possibly unbounded）。集合的大小是必须确定的，但流并不是。像limit(n) 或 findFirst()这样的逻辑短路操作，允许在有限时间内完成对无限流的计算。</li>
<li><strong>可消耗的</strong>（consumable）。流的元素在流的生命周期中只能被访问一次。类似于 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">Iterator</a>，要想重新访问同一个元素，必须生成新的流。</li>
</ul>
<h1 id="流操作与流水线">流操作与流水线</h1>
<p>当使用Stream时，会通过三个阶段来建立一个操作流水线 [<a href="https://book.douban.com/subject/26274206/">ref</a>]。</p>
<ol>
<li>创建一个Stream。</li>
<li>在一个或多个步骤中，指定将初始Stream转换为另一个Stream的<code>中间操作</code>。</li>
<li>使用一个<code>终止操作</code>来产生一个结果。该操作会强制它之前的<em><strong>延迟</strong></em>操作立即执行。在这之后，该Stream就不会再被使用了。</li>
</ol>
<p>整个流操作流水线，如图所示 [<a href="http://www.logicbig.com/tutorials/core-java-tutorial/java-util-stream/stream-api-intro/">ref</a>]：</p>
<p><img src="https://static.nullwy.me/2017-04-25-%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="流操作流水线"></p>
<p>Java 8的流创建、中间操作和终止操作的API汇总表，如下 [<a href="http://www.logicbig.com/tutorials/core-java-tutorial/java-util-stream/stream-cheat-sheet/">ref</a>]</p>
<style>
  td,th { border: 1px solid; } 
  td { vertical-align: top; }
</style>
<table>
<thead>
<tr>
<th>创建流</th>
<th>中间操作</th>
<th>终止操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a></strong> <br> stream() <br> parallelStream() <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a></strong>, <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html">IntStream</a></strong>, <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/LongStream.html">LongStream</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html">DoubleStream</a></strong> <br> static generate() <em>无序</em> <br> static of(..) <br> static empty() <br> static iterate(..) <br> static concat(..) <br> static builder() <br> <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html">IntStream</a></strong>, <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/LongStream.html">LongStream</a></strong> <br> static range(..) <br> static rangeClosed(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html">Arrays</a></strong> <br> static stream(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html">BufferedReader</a></strong> <br> lines(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html">Files</a></strong> <br> static list(..) <br> static walk(..) <br> static find(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/jar/JarFile.html">JarFile</a></strong> <br> stream() <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/ZipFile.html">ZipFile</a></strong> <br> stream() <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a></strong> <br> splitAsStream(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html">SplittableRandom</a></strong> <br> ints(..) <em>无序</em> <br> longs(..) <em>无序</em> <br> doubles(..) <em>无序</em> <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html">Random</a></strong> <br> ints(..) <br> longs(..) <br> doubles(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadLocalRandom.html">ThreadLocalRandom</a></strong> <br> ints() <br> longs(..) <br> doubles(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/BitSet.html">BitSet</a></strong> <br> stream() <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html">CharSequence</a> (String)</strong> <br> IntStream chars() <br> IntStream codePoints() <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/StreamSupport.html">StreamSupport</a> (low level)</strong> <br> static doubleStream(..) <br> static intStream(..) <br> static longStream(..) <br> static stream(..) <p></td>
<td><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html">BaseStream</a></strong> <br> sequential() <br> parallel() <br> unordered() <br> onClose(..) <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a></strong> <br> filter(..) <br> map(..) <br> mapToInt(..) <br> mapToLong(..) <br> mapToDouble(..) <br> flatMap(..) <br> flatMapToInt(..) <br> flatMapToLong(..) <br> flatMapToDouble(..) <br> distinct() <em>有状态</em> <br> sorted(..) <em>有状态</em> <br> peek(..) <br> limit(..) <em>有状态, 逻辑短路</em> <br> skip(..) <em>有状态</em> <p> IntStream、LongStream和DoubleStream方法与Stream类似, 其中<em>额外的</em>方法如下：<p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html">IntStream</a></strong> <br> mapToObj(..) <br> asLongStream() <br> asDoubleStream() <br> boxed() <br> <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/LongStream.html">LongStream</a></strong> <br> mapToObj(..) <br> asDoubleStream() <br> boxed() <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html">DoubleStream</a></strong> <br> mapToObj(..) <br> boxed()</td>
<td><p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html">BaseStream</a></strong> <br> iterator() <br> spliterator() <p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a></strong> <br> forEach(..) <br> forEachOrdered(..) <br> toArray(..) <br> reduce(..) <br> collect(..) <br> min(..) <br> max(..) <br> count() <br> anyMatch(..) <em>逻辑短路</em> <br> allMatch(..) <em>逻辑短路</em> <br> noneMatch(..) <em>逻辑短路</em> <br> findFirst() <em>逻辑短路</em> <br> findAny() <em>逻辑短路</em>*, 不确定* <br> <p> IntStream、LongStream和DoubleStream方法与Stream类似, 其中<em>额外的</em>方法如下：<p> <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html">IntStream</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/LongStream.html">LongStream</a></strong>, <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html">DoubleStream</a></strong> <br> sum() <br> average()﻿﻿﻿﻿﻿ <br> summaryStatistics()</td>
</tr>
</tbody>
</table>
<h1 id="筛选与映射操作">筛选与映射操作</h1>
<p>筛选与映射操作，即上文所说的中间操作。相关的API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends R&gt; mapper)</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-">filter(..)</a>，筛选出元素符合某个条件的新流。<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-">map(..)</a>，用于对元素作某种形式的转换。<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-">flatMap(..)</a>，用于将多个子流合并为一个新流。</p>
<p>其他的中间操作有，提取子流，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#limit-long-">limit(..)</a>（提取前n个）和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#skip-long-">skip(..)</a>（丢弃前n个）；有状态的转换，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#distinct--">distinct()</a>（过滤重复元素）和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted-java.util.Comparator-">sorted(..)</a>（排序），以及主要用于日志调试的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-">peek(..)</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure>
<h1 id="归约操作与收集器">归约操作与收集器</h1>
<p>流有多种形式的通用的归约操作，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">reduce(..)</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-">collect(..)</a>，同时也有多种特化的归约形式，比如 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--">sum()</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-">min(..)</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-">max(..)</a>或<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--">count()</a>等。<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">reduce(..)</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-">collect(..)</a>的方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity, BiFunction&lt;U,? <span class="built_in">super</span> T,U&gt; accumulator,</span></span><br><span class="line"><span class="params">             BinaryOperator&lt;U&gt; combiner)</span></span><br><span class="line">&lt;R,A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T,A,R&gt; collector)</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--">sum()</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-">min(..)</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-">max(..)</a>或<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--">count()</a>等特化的归约操作，是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">reduce(..)</a>归约操作的特殊化，内部实现依赖<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">reduce(..)</a>，相应JDK的实现源码可以作为印证。</p>
<p>IntStream的sum(..)的JDK现实源码为 [<a href="https://github.com/stain/jdk8u/blob/master/src/share/classes/java/util/stream/IntPipeline.java#L412">github</a>]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntStream的min(..)的JDK现实源码为 [<a href="https://github.com/stain/jdk8u/blob/master/src/share/classes/java/util/stream/IntPipeline.java#L417">github</a>]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> OptionalInt <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reduce(Math::min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stream的count()的JDK现实源码为 [<a href="https://github.com/stain/jdk8u/blob/master/src/share/classes/java/util/stream/ReferencePipeline.java#L524">github</a>]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapToLong(e -&gt; <span class="number">1L</span>).sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想将流归约为单个值，而只要查看集合被流操作后的结果，需要使用收集器（collector）。上文已经见到，将流收集为List：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; evenList = list.stream()</span><br><span class="line">        .filter(..).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collectors</a>是收集器工具类，提供获取预定义收集器（实现接口<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html">Collector</a>）的静态方法。<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collectors</a>类，除了将流收集为List，还可以是Map、Set、String，或者也能进行统计操作，如求和、计算平均值、最大值、最小值。<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collectors</a>的全部静态方法列表如下：</p>
<ul>
<li>averaging[Double|Int|Long]</li>
<li>collectingAndThen</li>
<li>counting</li>
<li>groupingBy</li>
<li>groupingByConcurrent</li>
<li>joining</li>
<li>mapping</li>
<li>maxBy</li>
<li>minBy</li>
<li>partitioningBy</li>
<li>reducing</li>
<li>summarizing[Double|Int|Long]</li>
<li>summing[Double|Int|Long]</li>
<li>toCollection</li>
<li>toConcurrentMap</li>
<li>toList</li>
<li>toMap</li>
<li>toSet</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O 多路复用与网络服务器并发策略</title>
    <url>/2023/07/io-multiplexing-network-server/</url>
    <content><![CDATA[<p>目前主流的网络服务器，网络 I/O 相关的底层最核心的技术都是 I/O 多路复用（I/O Multiplexing），比如 Apache HTTP Server、Nginx、Redis 等。本文尝试解释各种 I/O 模型，包括解释什么是 I/O 多路复用，同时也总结 I/O 多路复用底层的系统调用 select、poll、kqueue 和 epoll 的演进和区别，并编写了使用这些函数的示例代码。另外，本文还总结了各种基于 I/O 多路复用实现的网络服务器的并发策略的三种模式，包括对 Apache HTTP Server、Nginx 和 Redis 等网络服务器的并发策略的具体案例的解析。</p>
<span id="more"></span>
<h1 id="I-O-模型与多路复用">I/O 模型与多路复用</h1>
<p>类 Unix 系统下的 I/O 操作，默认是<strong>阻塞 I/O（Blocking I/O，缩写为 BIO）</strong>。比如，当一个进程发出了读操作请求，但没有可访问的数据时，该进程通常会阻塞在内核中，直到出现可以访问的数据为止。然而，进程有时要处理对多个描述符的 I/O 操作，需要在多个文件描述符上阻塞，典型的场景是终端 I/O 和网络 I/O。</p>
<p>例如，有一个远程登录程序，它要从键盘读入数据然后把这些数据通过套接字发送到一个远程的计算机上。这个程序还需要从和远程终端相连接的套接字上读取数据，并将数据显示于屏幕上。如果进程在读键盘数据时阻塞，它就不能读那些从远程终端发送到屏幕上的数据。这样一来，在来自远程终端的更多数据到达之前，用户就不知道该通过键盘输入些什么，于是，死锁便产生了。相反的，如果进程在读从远程终端送来的数据时阻塞，它将不能读来自键盘终端的数据。</p>
<p>历史上，<strong>Unix 系统通过使用多个进程让应用能同时处理多个文件描述符</strong>，这些进程间可以通过管道或者是其他的进程间通信方法进行通信。然而，如果处理上下文切换的代价比处理输入的代价更大，那么这种方法就会导致巨大的系统开销，因为它要求在进程间进行频繁的上下文切换。并且，在一个进程内实现这种应用会显得比较直观。由于上述原因，BSD 提供了三种机制，允许对描述符进行多路 I/O 访问，非阻塞式 I/O、 I/O 多路复用和信号驱动 I/O<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<ul>
<li><strong>非阻塞 I/O（Nonblocking I/O，缩写为 NIO）</strong>：进程对描述符尝试 I/O 操作，如果描述符未就绪（ready），系统不把本进程投入睡眠，而是返回一个错误（<code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>）。进程收到错误后，要么放弃，要么不停地轮询（polling），直至发现有描述符可以进行 I/O 操作为止。这种轮询的方法的问题在于，进程必须连续不断地运行，检查描述符是否就绪，很浪费 CPU 时间。</li>
<li><strong>I/O 多路复用（I/O Multiplexing）</strong>：让系统提供一种方法在多个感兴趣的描述符中查找哪个描述符可以进行 I/O 操作，如果没有这样的描述符，系统会让进程处于睡眠状态，直到出现这样的描述符为止。这种方法的缺点是对于每个操作，进程要完成两个系统调用，一个用来查找就绪描述符，另一个是 I/O 操作本身。<strong>非阻塞 I/O 是在用户空间轮询查找就绪描述符，而 I/O 多路复用是执行特殊的系统调用在内核空间查找就绪描述符。</strong></li>
<li><strong>信号驱动 I/O（Signal-Driven I/O）</strong>：当可以进行 I/O 操作时，使所有描述符发信号。进程只用等待这些信号就可以知道是否可以进行 I/O 操作。这种方法的缺点在于捕获这些信号的开销是巨大的，所以此方法对于那些涉及大量 I/O 操作的应用并不实用。</li>
</ul>
<p>类 Unix 系统下，默认的 I/O 操作都是阻塞 I/O。有两种方法可以将描述符设置非阻塞 I/O：(1) 如果是调用 <a href="https://man7.org/linux/man-pages/man2/open.2.html">open</a>() 获得描述符，则可以在调用时设置 <code>O_NONBLOCK</code> 标志；(2) 对于已经打开的一个描述符，则可调用 <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl</a>()，由该函数为描述符设置 <code>O_NONBLOCK</code> 标志。另外，对于网络套接字的描述符，如果想在获得描述符时直接指定为非阻塞 I/O，可以在调用 <a href="https://man7.org/linux/man-pages/man2/socket.2.html">socket</a>() 或 <a href="https://man7.org/linux/man-pages/man2/accept.2.html">accept</a>() 时传入 <code>SOCK_NONBLOCK</code> 标志，当然也可以在获得描述符后，再调用 <code>fcntl()</code>修改。</p>
<p>I/O 多路复用，最早是在 4.2BSD（1983.08）中由 <a href="https://man.freebsd.org/cgi/man.cgi?query=select&amp;apropos=0&amp;sektion=2&amp;manpath=4.3BSD+Reno&amp;arch=default&amp;format=html">select</a>() 系统调用提供的。虽然该系统调用主要用于终端 I/O 和网络 I/O，但它对其他描述符同样是起作用的。<code>poll()</code> 是另外一个实现 I/O 多路复用的系统调用，和 <code>select()</code> 功能几乎相同。SVR3（1987）在增加 STREAMS 机制时增加了 <a href="https://man.freebsd.org/cgi/man.cgi?query=poll&amp;apropos=0&amp;sektion=2&amp;manpath=NetBSD+1.3&amp;arch=default&amp;format=html">poll</a>() 系统调用。但在 SVR4 （1988）之前，<code>poll()</code> 只对 STREAMS 设备起作用。SVR4 开始支持对任意描述符起作用的 <code>poll()</code>。<strong><code>select()</code> 和 <code>poll()</code> 系统调用，都是在 POSIX.1-2001 开始标准化定义，然而从可移植性角度考虑，支持 <code>select()</code> 的系统比支持 <code>poll()</code> 的系统要多，所以在应用的实现上，相比于 <code>poll()</code> 基于 <code>select()</code> 实现更多</strong>。另外 POSIX 还定义了 <code>pselect()</code>，它是能够处理信号阻塞并提供了更高时间分辨率的 <code>select()</code> 的增强版本。</p>
<p>在 Linux 系统下，<code>poll()</code> 系统调用从 2.1.23 版本（1997.01）开始提供，而 <code>poll()</code> 库函数由 libc 5.4.28（1997.05）开始提供。早期 Linux 内核未提供 <code>poll()</code> 系统调用，glibc 使用 <code>select()</code> 来模拟实现 <code>poll()</code>。另外，Linux 还提供特有的 I/O 多路复用解决方案，即 <code>epoll</code>，详细介绍参见下文。</p>
<p>为了能持续不断的监听 I/O 操作就绪事件，应用实现上需要循环调用 <code>select()</code>或 <code>poll()</code>。为了方便使用，封装各个不同的 I/O 多路复用函数的第三方库，通常会把这样的循环调用被抽象为<strong>事件循环（event loop）</strong>，然后把 I/O 就绪事件的处理抽象成回调函数（callback）。最早的提供事件循环（event loop）抽象的典型的第三方库是 <a href="https://libevent.org/">libevent</a> 库（最早在 2002.04 发布）。</p>
<p>信号驱动 I/O，在描述符就绪时内核会发送 <code>SIGIO</code> 信号。但是信号驱动 I/O 对于 TCP 套接字近乎无用，问题在于 <code>SIGIO</code> 信号产生得过于频繁，并且它的出现并没有告诉我们发生了什么事件，无法区分触发信号的各种情况。在 UDP 上使用信号驱动式 I/O 没有上述问题。关于信号驱动 I/O 的详细阐述，可以参阅《UNIX网络编程 卷1》的第 25 章<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<h2 id="描述符就绪条件">描述符就绪条件</h2>
<p><code>select()</code> 和 <code>poll()</code> 系统调用是在多个文件描述符中查找就绪（ready）的描述符。就绪条件具体指是什么呢？<code>select()</code> 的 <a href="https://man7.org/linux/man-pages/man2/select.2.html">man</a> 文档，有如下描述（<code>poll()</code> 的就绪条件类似，不展开讨论）：</p>
<blockquote>
<p>A file descriptor is considered ready <strong>if it is possible to perform a corresponding I/O operation (e.g., read(2), or a sufficiently small write(2)) without blocking</strong>.<br>
...<br>
A file descriptor is ready for <strong>reading</strong> if a read operation will <strong>not block</strong>; in particular, a file descriptor is also ready on <strong>end-of-file</strong>.<br>
A file descriptor is ready for <strong>writing</strong> if a write operation will <strong>not block</strong>. However, even if a file descriptor indicates as writable, a large write may still block.</p>
</blockquote>
<p>针对网络套接字描述符的就绪条件，《UNIX网络编程 卷1》如下总结：</p>
<img width="600" alt="套接字描述的就绪条件小结" title="套接字描述的就绪条件小结" src="https://static.nullwy.me/unix-socket-fd-ready.png">
<p>表中的“有数据可读”含义是，该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于 0 的值（也就是返回准备好读入的数据）。接收低水位标记，可以通过调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+14.0-CURRENT&amp;arch=default&amp;format=html">setsockopt</a>() 的 <code>SO_RCVLOWAT</code> 选项来设置，默认值为 1。</p>
<p>表中的“有可用于写的空间”含义是，该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且或者该套接字已连接，或者该套接字不需要连接（如UDP套接字）。发送低水位标记，可以通过调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+14.0-CURRENT&amp;arch=default&amp;format=html">setsockopt</a>() 的 <code>SO_SNDLOWAT</code> 选项来设置，默认值为 1024。</p>
<p>表中的“关闭连接的读一半”和“关闭连接的写一半”含义是，套接字的 TCP 连接接收了关闭 FIN，此时会收到读就绪事件和写就绪事件。对这样的套接字做读操作将不阻塞并返回 0（也就是返回 EOF）；对这样的套接字做写操作将产生 <code>SIGPIPE</code> 信号（Broken pipe: write to pipe with no readers）。</p>
<h2 id="I-O-模型的比较">I/O 模型的比较</h2>
<p>上文阐述的就是 Unix 系统的 4 种 I/O 模型，<strong>阻塞 I/O、非阻塞 I/O、I/O 多路复用和信号驱动式 I/O</strong>。另外，还有一种 I/O 模型是，<strong>异步 I/O（Asynchronous I/O，缩写为 AIO）</strong>。异步 I/O，由 POSIX 规范定义，工作机制是，告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知进程。这种模型与信号驱动模型的主要区别在于：信号驱动 I/O 是由内核通知我们何时可以启动一个 I/O 操作，而异步 I/O 模型是由内核通知我们 I/O 操作何时完成。POSIX 定义的异步 I/O 的函数为，<code>aio_write()</code>、<code>aio_read()</code> 等。</p>
<p>关于 POSIX 异步 IO，Linux 的 aio 的 <a href="https://man7.org/linux/man-pages/man7/aio.7.html">man</a> 文档，有如下说明：</p>
<blockquote>
<p>The current Linux POSIX AIO implementation is provided in user space by glibc. This has a number of limitations, most notably that maintaining multiple threads to perform I/O operations is expensive and scales poorly. Work has been in progress for some time on a kernel state-machine-based implementation of asynchronous I/O (see io_submit(2), io_setup(2), io_cancel(2), io_destroy(2), io_getevents(2)), but this implementation hasn't yet matured to the point where the POSIX AIO implementation can be completely reimplemented using the kernel system calls.</p>
</blockquote>
<p>本质上，Linux 下的 POSIX AIO 是在用户空间下用线程模拟实现的 AIO，并非真正的 AIO，性能很差，所以很少被使用。</p>
<p>Linux 内核实现的 AIO 是 <a href="https://man7.org/linux/man-pages/man2/io_submit.2.html">io_submit</a>、<a href="https://man7.org/linux/man-pages/man2/io_setup.2.html">io_setup</a>、<a href="https://man7.org/linux/man-pages/man2/io_getevents.2.html">io_getevents</a> 等系统调用，也被成为“Linux Native AIO”，或者缩写为 KAIO（kernel AIO），从 Linux 2.5 开始支持（2001.11），这些系统调用对应的库函数由 <code>libaio</code> 库提供。但是 Linux Native AIO 几乎不可用，只适合以 <code>O_DIRECT</code> 方式做直接 IO（无缓存的 I/O）。如果真的实现了异步 AIO，<code>io_submit</code> 系统调用不应该阻塞，但是对缓存 I/O、网络访问、管道等，<code>io_submit</code> 会发生阻塞，整个操作将在 <code>io_submit</code> 系统调用期间执行，并且通过调用 <code>io_getevents</code>，I/O 操作完成结果可以立即访问，这样也就破坏了异步 I/O 的目的<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 。</p>
<p>最新的内核实现的 AIO 是 <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring</a>，已经被 Linux 5.1（2019.05）采纳。很多开源项目，比如 <a href="https://github.com/libevent/libevent/issues/1019">libevent</a>、<a href="https://github.com/libuv/libuv/pull/3952">libuv</a>、<a href="https://mailman.nginx.org/pipermail/nginx-devel/2020-November/013632.html">Nginx</a>、<a href="https://github.com/redis/redis/issues/10881">Redis</a> 等，都有打算支持或甚至已经支持 io_uring。io_uring 的杂类资料整理，可以参考“Awesome io_uring”<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。本文主要关注 I/O 多路复用，io_uring 不再展开讨论。</p>
<p>《UNIX网络编程 卷1》对这 5 种 I/O 模型做了对比<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>：</p>
<img width="800" alt="5 种 I/O 模型的比较" title="5 种 I/O 模型的比较" src="https://static.nullwy.me/unix-io-models.png">
<p>可以看出，前 4 种模型的主要区别在于第一阶段（等待描述符就绪），因为它们的第二阶段是一样的：在数据从内核复制到调用者的缓冲区期间，进程阻塞于 <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recvfrom</a> 调用。相反，异步 I/O 模型在这两个阶段都要处理，从而不同于其他 4 种模型。</p>
<p>各个 I/O 模型，用户空间的应用与内核空间的交互过程如下图所示（信号驱动 I/O 实际场景较少使用，所以忽略）<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：</p>
<table>
<thead>
<tr>
<th><img width="350" alt="阻塞式 I/O" title="阻塞式 I/O" src="https://static.nullwy.me/unix-io-models-bio.gif"></th>
<th><img width="350" alt="非阻塞式 I/O" title="非阻塞式 I/O" src="https://static.nullwy.me/unix-io-models-nio.gif"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img width="350" alt="非阻塞式 I/O + I/O 多路复用" title="非阻塞式 I/O + I/O 多路复用" src="https://static.nullwy.me/unix-io-models-multiplexing.gif"></td>
<td><img width="350" alt="异步 I/O" title="异步 I/O" src="https://static.nullwy.me/unix-io-models-aio.gif"></td>
</tr>
</tbody>
</table>
<p>通常对“I/O 多路复用”术语的理解，其实就是特指，<strong>由 select() 、poll() 或类似的系统调用实现的在多个文件描述符中查找就绪状态描述符的技术</strong>。不过，根据 McKusick 书籍的描述<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>，<strong>I/O 多路复用也可以泛指为，单个进程同时处理多个文件描述符的技术，与之相对立的技术是早期的由多个进程同时处理多个描述符的解决方案。广义理解的话，I/O 多路复用包括非阻塞 I/O、狭义的 I/O 多路复用、信号驱动式 I/O、异步 IO 等技术</strong>。</p>
<p>单独的“多路复用（<a href="https://en.wikipedia.org/wiki/Multiplexing">multiplexing</a>）”术语，维基百科的解释是，一个通信和计算机网络领域的专业术语，多路复用通常表示在一个信道上传输多路信号或数据流的过程和技术。</p>
<h2 id="阻塞、非阻塞与同步、异步的区别">阻塞、非阻塞与同步、异步的区别</h2>
<p>在概念上，阻塞 I/O 和非阻塞 I/O，是根据系统<strong>是否会阻塞进程的执行</strong>而区分的：</p>
<ul>
<li>阻塞 I/O，在执行 I/O 操作后，如果 I/O 操作的描述符未就绪，系统会让进程进入睡眠状态，直到描述符就绪为止。</li>
<li>非阻塞 I/O，在执行 I/O 操作后，不会阻塞当前进程，可以继续执行其他的任务。</li>
</ul>
<p>另外，POSIX 定义了同步 I/O（Synchronous I/O）和异步 I/O（Asynchronous I/O）两个术语<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">[2:2]</a></sup>：</p>
<ul>
<li>同步 I/O 操作，导致请求进程阻塞，直到 I/O 操作完成</li>
<li>异步 I/O 操作，不导致请求进程阻塞。</li>
</ul>
<blockquote>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.<br>
An asynchronous I/O operation does not cause the requesting process to be blocked.</p>
</blockquote>
<p>按照这个定义，阻塞 I/O、非阻塞 I/O、I/O 多路复用和信号驱动 I/O 都是同步 I/O，因为其中真正的 I/O 操作将阻塞进程（第二阶段，将数据从内核复制到用户空间的缓冲区阶段）。只有异步 I/O 模型与 POSIX 定义的异步 I/O 相匹配。</p>
<p>不过，对于 I/O 多路复用是属于同步 I/O 还是异步 I/O 存在争议，不同视角下存在不同的理解。I/O 多路复用，单看等待 I/O 就绪阶段，其实是异步的。所以很多时候，<strong>I/O 多路复用，虽然没有实现真正的 POSIX 定义的异步 I/O，但也被归类为异步 I/O</strong>。比如，Jones 的文章<sup class="footnote-ref"><a href="#fn5" id="fnref5:1">[5:1]</a></sup>，<strong>将 I/O 多路复用归类为阻塞的异步 I/O，将 POSIX AIO 归类为非阻塞的异步 I/O</strong>。类似的，封装各个不同的 I/O 多路复用函数的 <code>libevent</code> 库的官方文档<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>自称是“Asynchronous I/O”。<code>Node.js</code> 底层是基于 I/O 多路复用封装的 <a href="https://libuv.org/">libuv</a> 库，<code>libuv</code> 库也自称是“Asynchronous I/O”。另外，如果跳出 I/O 视角，从整体应用的执行流程角度看，基于 I/O 多路复用实现的应用，相对于在多个描述符列表上主轮询流程，在单个描述符上 I/O 事件的应用处理流程相对独立，可以认为是异步的。Node.js 文档对“异步”的解释如下<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>：</p>
<blockquote>
<p>Asynchronous means that things can happen independently of the main program flow.</p>
</blockquote>
<p>严格意义上，典型的 I/O 多路复用的应用是单进程单线程执行的，本质上都是串行执行的，是假异步。</p>
<h1 id="服务器并发策略与-C10K-问题">服务器并发策略与 C10K 问题</h1>
<p>世界上第一个 HTTP 服务器，<a href="https://en.wikipedia.org/wiki/CERN_httpd">CERN httpd</a>，早期实现采用的 I/O 模型是阻塞 I/O，然后为了能同时处理多个客户端连接，会为每个客户端连接创建一个新的处理请求的子进程（process-per-connection），这种并发模式被称为 <strong>fork 模式</strong>，这也是传统的 Unix 服务器采用的并发模式。之后的版本，改为基于 <code>select()</code> 的 I/O 多路复用 + fork 模式（参见源码 <a href="https://github.com/hackervera/cern-httpd/blob/master/Daemon/Implementation/HTDaemon.c#L2118">HTDaemon.c</a>）。</p>
<p><a href="https://en.wikipedia.org/wiki/NCSA_HTTPd">NCSA HTTPd</a>，是早期的第一个流行的 HTTP 服务器，在版本 1.3 以及之前版本，也是采用阻塞 I/O + fork 模式实现，会为每个客户端连接创建一个新的子进程（参见源码 <a href="https://github.com/TooDumbForAName/ncsa-httpd/blob/1.3/src/httpd.c#L160">httpd.c</a>）。之后 NCSA HTTPd 的 1.4 版本，I/O 模型改造为基于 select() 的 I/O 多路复用，进程模型改为“<strong>pre-forking</strong>”模式，但这种模式本质上还是每个客户端连接对应单个子进程（process-per-connection），“pre-forking”的优点是在创建新客户端连接时有预先创建的子进程直接处理请求（类似进程池），避免在创建新连接的同时执行创建子进程这样的重型操作，具体可以参见 1996.03 的官方文档的对“pre-forking”模型的性能测试<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>（相关的实现源码参见 <a href="https://github.com/TooDumbForAName/ncsa-httpd/blob/1.4.2/src/httpd.c#L508">httpd.c</a>）。</p>
<p>Apache HTTP Server，最早在 1995.04 对外公开发布首个版本 0.6.2，这个版本的代码基于 NCSA httpd 1.3<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>。 之后在 5 月和 6 月，Apache 也开始实现“pre-forking”特性，在版本 0.8.0 开始正式支持<sup class="footnote-ref"><a href="#fn9" id="fnref9:1">[9:1]</a></sup><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。一直到 Apache HTTP Server 2.2，<a href="https://httpd.apache.org/docs/2.4/en/mod/prefork.html">prefork</a> 模式依然是 Unix 系统下的默认模式<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>。<strong>在 Apache 的 prefork 模式下，每个客户端连接由单独的子进程处理，这样的子进程被 Apache 称为 worker 进程，worker 进程数就是同时处理的客户端连接数</strong>。因为线程相对进程更加轻量，理论上每个客户端连接对应单个线程（thread-per-connection）更有优势。所以，在 2002.04，Apache 发布 2.0 的首个 GA 版本时，新增了 <a href="https://httpd.apache.org/docs/2.4/mod/worker.html">worker</a> 模式，一种多进程和多线程混合的模式。<strong>在 Apache 的 worker 模式下，每个客户端连接由单独的子线程处理，这样的子线程也就是 worker 线程，worker 线程数就是同时处理的客户端连接数。</strong></p>
<p>相对单线程，多进程或多线程的问题是，占用更多内存（每个线程都需要维护自己的线程栈），以及频繁的上下文切换。所以，有些 HTTP 服务器倾向于基于 <code>select()</code> 实现单进程单线程的网络服务器。这种模式实现的服务器一般会把循环调用 <code>select()</code> 的过程抽象为事件循环（event loop），把 I/O 操作就绪事件的处理抽象成回调函数（callback），所以也被称为<strong>事件驱动服务器（event-driven server）</strong>。多核 CPU 时，为了能充分使用 CPU 多核资源，事件驱动服务器的进程数（或线程数）通常为 CPU 核数。事件驱动模式，在软件架构中被也称为 <a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor</a> 模式。基于事件并发和基于线程的并发的比较，可以阅读 <a href="https://en.wikipedia.org/wiki/John_Ousterhout">John Ousterhout</a> 的 1995 年的经典 slides：“Why Threads Are A Bad Idea (for most purposes)”<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>。</p>
<p>早期的典型的基于 <code>select()</code> 实现的单线程 HTTP 服务器的例子，是由 ACME 实验室开发并开源的 <a href="https://en.wikipedia.org/wiki/Thttpd">thttpd</a>（1995.11 对外发布 <a href="https://web.archive.org/web/19970124214241if_/http://www.acme.com:80/software/thttpd/thttpd_100.tar.Z">1.0</a> 版）。thttpd 服务器作者 Jef Poskanzer 在文章“Web Server Comparisons”（1998.07）<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>中对比了各个 Web 服务器。根据文章的对比，容易发现基于 <code>select()</code> 实现的单线程服务器，在响应性能和最大并发连接数上都占优，thttpd 支持的最大的每秒请求数 QPS 是 720，thttpd 支持的最大并发连接数是 1000+。</p>
<p>虽然在实验条件下表现良好，但是在真实场景下，基于 <code>select()</code> 实现的 HTTP 单线程服务器，性能并没有优于传统的基于 fork 模式的服务器<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>。Banga 等人经过分析后得出的主要原因是，当服务器同时处理的客户端连接数超过几千后，系统调用 <code>select()</code> 或 <code>poll()</code> 的性能很差，不具备可伸缩性。</p>
<p>最早的 HTTP 1.0 协议，在服务响应完成后连接会立即关闭，连接无法保持。HTTP 底层是 TCP 协议，建立 TCP 连接需要经过三次握手的过程。<strong>如果能复用 TCP 连接，同一个 HTTP 连接上的后续的 HTTP 请求就不用重新建立 TCP 连接，也就是能在同一个 HTTP 连接上支持多次 HTTP 请求和响应，这样 HTTP 性能也就得到了提高</strong>。于是，HTTP 1.1 协议（RFC 2068，1997.01）开始<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">持久连接</a>（persistent connection），默认让 HTTP 连接“keep-alive”。关于 HTTP 持久连接的详细介绍，可以参考 RFC 2068 的“<a href="https://datatracker.ietf.org/doc/html/rfc2068#section-8.1">8.1 Persistent Connections</a>”。</p>
<p>HTTP 协议支持持久连接后，也带来了另外一个问题，就是出现大量的冷链接（cold connection）。浏览器如果未主动关闭连接，停留在网页上，并且如果连接未超时，此时的连接虽然不活跃但会保持一段时间，这样的连接就是冷链接。同时，随着互联网的快速发展，访问网站的用户量不断上升，Web 服务器需要维持的链接数也不断上升，如何让服务支持更多客户端连接问题也愈发尖锐。当时 Web 服务器支持的最大并发连接数大致是 1K，于是 Dan Kegel 在 1999 年提出了 <a href="https://en.wikipedia.org/wiki/C10k_problem">C10k</a> 问题，如何能让服务器支持 10K 的客户端连接，字母“C”代表的是“client connection”。在文章“The C10K problem”<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>中，Dan Kegel 对 C10K 问题的描述如下：</p>
<blockquote>
<p>It's time for web servers to <strong>handle ten thousand clients simultaneously</strong>, don't you think? After all, the web is a big place now.</p>
</blockquote>
<p>另外，值得一提的是，HTTP 1.0 和 HTTP 1.1 协议存在队头阻塞问题（HOL 阻塞，<a href="https://en.wikipedia.org/wiki/Head-of-line_blocking#In_HTTP">head of line blocking</a>），为了避免队头阻塞，从而使网页能更快响应，大多数浏览器会为每个域名同时开启多个 HTTP 连接，通常是 6 个并发连接<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>，结果导致 Web 服务器需要维持的链接数增加数倍。在发布 HTTP 1.1 协议的十几年后的 2012 年，HTTP 2.0 的首个草稿发布，而制定 HTTP/2 协议的最大的目标之一就是解决队头阻塞问题。</p>
<h1 id="select-和-poll-性能问题">select 和 poll 性能问题</h1>
<p>当 Web 服务器需要同时处理大量客户端连接时，服务器的性能表现差，原因就出在系统调用 <code>select()</code> 和 <code>poll()</code> 的性能上，具体的问题有如下三点<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>：</p>
<ul>
<li>每次调用 <code>select()</code> 或 <code>poll()</code>，内核都必须检查所有被指定的文件描述符，看它们是否处于就绪状态。随着待检查的文件描述符数量的增加，调用耗时也随之线性增加。<strong>若待检查的文件描述符数为 n，<code>select()</code> 或 <code>poll()</code> 的时间复杂度为 O(n)。</strong></li>
<li>每次调用 <code>select()</code> 或 <code>poll()</code>，程序都必须传递一个表示所有需要被检查的文件描述符的数据结构到内核，内核检查过描述符后，修改这个数据结构并返回给程序。（此外，对于 <code>select()</code> 来说，我们还必须在每次调用前初始化这个数据结构。）随着待检查的文件描述符数量的增加，传递给内核的数据结构大小也会随之增加。当检查大量文件描述符时，从用户空间到内核空间来回拷贝这个数据结构将占用大量的 CPU 时间。</li>
<li><code>select()</code> 或 <code>poll()</code> 调用完成后，程序必须检查返回的数据结构中的每个元素，以此查明哪个文件描述符处于就绪状态。</li>
</ul>
<p>解决系统调用 <code>select()</code> 和 <code>poll()</code> 的性能问题，让服务器能同时处理大量连接，比较典型的解决方案是，FreeBSD 4.1（2000.07 发布）开始支持的 <code>kqueue</code> 系统调用 ，以及 Linux 2.5.44（2002.10 发布）开始支持的 <code>epoll</code> 系统调用。</p>
<h1 id="kqueue-和-epoll-系统调用">kqueue 和 epoll 系统调用</h1>
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=kqueue&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+14.0-CURRENT&amp;arch=default&amp;format=html">kqueue</a> 相关的 API 主要涉及两个系统调用 <code>kqueue()</code> 和 <code>kevent()</code>：</p>
<ul>
<li><code>kqueue()</code>：用于在内核空间创建 <code>kqueue</code> 数据结构</li>
<li><code>kevent()</code>：
<ul>
<li>当传入其中的 <code>changelist</code> 等参数时，用于将感兴趣的 <code>kevent</code> 事件对象注册到 <code>kqueue</code>，<code>kevent</code> 对象上记录感兴趣文件描述符和事件类型</li>
<li>当传入其中的 <code>eventlist</code> 等参数时，用于查询就绪的 <code>kevent</code> 事件对象列表</li>
</ul>
</li>
</ul>
<p><strong>kqueue 的实现原理</strong><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>：调用 <code>kqueue()</code> 创建由内核空间维护 <code>kqueue</code> 实例，<code>kqueue</code> 实例内包含链表，链表上保存全部监听的 <code>kevent</code> 事件对象，<code>kevent</code> 对象上感兴趣的记录文件描述符和事件类型。通过 <code>kevent()</code> 系统调用，可以在链表上注册、删除某 <code>kevent</code> 对象。当设备 I/O 事件触发时，设备与 <code>kqueue</code> 实例关联的钩子函数（hook）会被执行，钩子函数会判断事件是否与监听的事件相符合，如果符合就把事件添加到 <code>kqueue</code> 实例内下链表 <code>active list</code> 的末尾。查询就绪事件列表时，调用 <code>kevent()</code>，内核只需要检查链表 <code>active list</code> 是否有元素，若有就把就绪事件列表拷贝到用户空间。</p>
<p><a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> 相关的 API 主要涉及三个系统调用 <code>epoll_create()</code>、<code>epoll_ctl()</code> 和 <code>epoll_wait()</code>：</p>
<ul>
<li><code>epoll_create()</code>：用于在内核空间创建 <code>epoll</code> 实例</li>
<li><code>epoll_ctl()</code>：用于添加感兴趣的 <code>epoll_event</code> 事件对象到 <code>epoll</code> 实例，<code>epoll_event</code> 对象上记录感兴趣文件描述符和事件类型</li>
<li><code>epoll_wait()</code>：用于查询就绪的 <code>epoll_event</code> 事件对象列表</li>
</ul>
<p><strong>epoll 的实现原理</strong>：调用 <code>epoll_create()</code> 创建由内核空间维护的 <code>epoll</code> 实例，epoll 实例内包含红黑树，红黑树上保存全部监听的 <code>epoll_event</code> 事件对象，<code>epoll_event</code> 对象上记录感兴趣的文件描述符和事件类型。通过 <code>epoll_ctl()</code> 系统调用，可以在红黑树上注册、删除某 <code>epoll_event</code> 对象。所有添加到红黑树中的事件都会与设备驱动程序建立回调关系，当 I/O 就绪事件触发时，会把事件添加到 <code>epoll</code> 实例内的链表 <code>rdllist</code>。查询就绪事件列表时，调用 <code>epoll_wait()</code>，内核只需要检查链表 <code>rdllist</code> 是否有元素，若有就把就绪事件列表拷贝到用户空间。</p>
<h2 id="水平触发和边缘触发">水平触发和边缘触发</h2>
<p><code>epoll</code> 系统调用的事件通知模式，区分水平触发（level-triggered，LT）和边缘触发（edge-triggered，ET），默认通知模式是水平触发 LT，<code>EPOLLET</code> 标志可以将通知模式改为边缘触发。<code>poll()</code> 和 <code>select()</code> 所提供的通知模式是水平触发，不支持边缘触发。水平触发和边缘触发的通知模式的含义如下<sup class="footnote-ref"><a href="#fn17" id="fnref17:1">[17:1]</a></sup>：</p>
<ul>
<li><strong>水平触发通知模式</strong>：如果文件描述符上可以非阻塞地执行 I/O 系统调用，此时认为它已经就绪。水平触发模式下，应用程序可以不立即处理该事件，当应用程序下一次调用 epoll_wait() 时，epoll_wait() 还会再次向应用程序通告此事件，直到该事件被处理。这种模式下 epoll 相当于一个效率较高的 poll。</li>
<li><strong>边缘触发通知模式</strong>：如果文件描述符自上次状态检查以来有了新的 I/O 事件，此时需要触发通知。也就是说，当 epoll_wait() 检测到某 I/O 事件发生并将此事件通知应用程序后，后续的 epoll_wait() 调用将不再向应用程序通知这一事件，只通知新的 I/O 事件。边缘触发模式在很大程度上降低了同一个 epoll 事件被重复触发的次数，因此效率要比水平触发模式高。但是相对水平触发，边缘触发模式下开发难度更大。</li>
</ul>
<p>“水平触发”和“边缘触发”术语源于电子工程领域。水平触发是只要有状态发生就触发。边缘触发是只有在状态改变的时候才会发生。条件触发关心的是事件状态，边缘触发关心的是事件本身。</p>
<p><strong>采用边缘触发通知的程序通常要按照如下规则来设计：</strong></p>
<ul>
<li>在接收到一个 I/O 事件通知后，程序在某个时刻应该在相应的文件描述符上尽可能多地执行 I/O（比如尽可能多地读取字节）。如果程序没这么做，那么就可能失去执行 I/O 的机会。</li>
<li>如果尽可能多地执行 I/O，而文件描述符被设置为阻塞模式，那么最终当没有更多的 I/O 可执行时，I/O 系统调用就会阻塞。所以，每个被检查的文件描述符通常都应该设置为非阻塞模式。</li>
</ul>
<p>另外，在边缘触发 ET 模式下，如果多个线程同时监听相同的描述符，只会有一个线程被唤醒用来处理 I/O 事件。epoll 的 <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">man</a> 文档对这个特性有如下描述，这个特性也避免了“惊群问题”（<a href="https://en.wikipedia.org/wiki/Thundering_herd_problem">thundering herd problem</a>）。</p>
<blockquote>
<p>If multiple threads (or processes, if child processes have inherited the epoll file descriptor across fork(2)) are blocked in epoll_wait(2) waiting on the same epoll file descriptor and a file descriptor in the interest list that is marked for edge-triggered (EPOLLET) notification becomes ready, just one of the threads (or processes) is awoken from epoll_wait(2). This provides a useful optimization for avoiding &quot;thundering herd&quot; wake-ups in some scenarios.</p>
</blockquote>
<p>因此，边缘触发通知模式其中一个适用的场景是，多核 CPU 上的多线程服务器，每个 CPU 核上运行一个线程，这些线程同时监听相同的描述符<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>。</p>
<p><code>kqueue</code> 文档没有使用水平触发和边缘触发术语。但接口效果上，默认是水平触发。开启<code>EV_CLEAR</code>标志可以达到类似边缘触发的效果。<code>EV_CLEAR</code> 标志的 <a href="https://man.freebsd.org/cgi/man.cgi?query=kqueue&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+14.0-CURRENT&amp;arch=default&amp;format=html">man</a> 文档描述：</p>
<blockquote>
<p>After the event is retrieved by the user, its state is reset.</p>
</blockquote>
<p>因为边缘触发通知模式效率更高，Nginx 服务器采用的就是边缘触发，参见源码 <a href="https://github.com/nginx/nginx/blob/release-1.25.0/src/event/modules/ngx_epoll_module.c#L292">ngx_epoll_module.c</a> 和 <a href="https://github.com/nginx/nginx/blob/release-1.25.0/src/event/modules/ngx_kqueue_module.c#L238">ngx_kqueue_module.c</a>。</p>
<h1 id="select、poll、kqueue-和-epoll-的比较">select、poll、kqueue 和 epoll 的比较</h1>
<p><code>select</code>、<code>poll</code>、<code>kqueue</code> 和 <code>epoll</code> 系统调用的多个维度的对比总结，如下表：</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>select</strong></th>
<th><strong>poll</strong></th>
<th><strong>kqueue</strong></th>
<th><strong>epoll</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类 Unix 系统的支持情况</strong></td>
<td>POSIX 标准。最早 4.2BSD 提供（1983)</td>
<td>POSIX 标准。最早 SVR3 提供（1987)</td>
<td>BSD 专有。最早 FreeBSD 4.1 提供 （2000.08）</td>
<td>Linux 专有。最早 Linux 2.5.44 提供（2002.10）</td>
</tr>
<tr>
<td><strong>查询就绪描述符的时间复杂度</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>感兴趣描述符列表传递</strong></td>
<td>每次 select() 都全量拷贝到内核空间</td>
<td>每次 poll() 都全量拷贝到内核空间</td>
<td>由内核空间维护</td>
<td>由内核空间维护</td>
</tr>
<tr>
<td><strong>就绪描述符列表的返回</strong></td>
<td>只返回就绪描述符数量，需要检查感兴趣描述符列表来判断哪些是就绪描述符</td>
<td>只返回就绪描述符数量，需要检查感兴趣描述符列表来判断哪些是就绪描述符</td>
<td>返回就绪事件数量，并同时返回就绪事件列表</td>
<td>返回就绪事件数量，并同时返回就绪事件列表</td>
</tr>
<tr>
<td><strong>最大描述符数</strong></td>
<td>被常数 <code>FD_SETSIZE</code> 限制（值为 1024）</td>
<td>无限制</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td><strong>触发通知模式</strong></td>
<td>水平</td>
<td>水平</td>
<td>水平和边缘</td>
<td>水平和边缘</td>
</tr>
</tbody>
</table>
<p><strong>附注</strong>：查询就绪描述符的时间复杂度，<code>select</code> 和 <code>poll</code> 都是 O(n)，n 为感兴趣描述符的总数，因为内核实现上需要轮询全部感兴趣的描述符列表。<code>kqueue</code> 和 <code>epoll</code> 都是 O(1)，实际的查询耗时与就绪描述符总数线性有关，但真实场景下就绪描述符数量相对描述符总数很小，可以认为是常数，所以复杂度是 O(1)。</p>
<p>总体上，<code>select</code> 和 <code>poll</code> 之间大同小异，而 <code>kqueue</code> 和 <code>epoll</code> 之间也是大同小异。</p>
<p><a href="https://libevent.org/">libevent</a> 库，对系统调用 <code>select</code>、<code>poll</code>、<code>kqueue</code> 和 <code>epoll</code> 做了性能基准测试，如下图所示（<a href="https://monkey.org/~provos/libevent/libevent-benchmark2.jpg">图片来源</a>）。基准测试声明了大量连接（文件描述符），大多数连接是冷的，只有少数是活跃的。测试衡量的是，在不同的总连接数下，为 100 个活动连接提供服务所需的时间。可以看到，系统调用 <code>select</code> 和 <code>poll</code>，随着文件描述符的增加，耗时也随之线性增加，2500 个文件描述符时耗时大约 20ms，5000 个文件描述符时耗时大约 40ms，10000 个文件描述符时耗时大约 80ms。而系统调用 <code>kqueue</code> 和 <code>epoll</code>，耗时始终在 3ms ~ 5ms 之间。</p>
<img width="700" alt="性能基准测试：select vs poll vs kqueue vs epoll" title="性能基准测试：select vs poll vs kqueue vs epoll" src="https://static.nullwy.me/libevent-benchmark2.png">
<h1 id="echo-服务的简单示例代码">echo 服务的简单示例代码</h1>
<p>上文总结了 <code>select</code>、<code>poll</code>、<code>kqueue</code> 和 <code>epoll</code> 的接口特性和实现原理，但对具体应该如何使用这些函数没有切身感受。<strong>笔者使用 I/O 多路复用函数 select、poll、epoll 和 kqueue 以及 libevent 库，各自编写了 echo 服务的简单示例代码</strong>。所谓 echo 服务，即服务端接收到客户端的字符串输入，然后响应相同的字符串（为了方便区分响应字符串加了 <code>&gt; </code> 前缀）。比如，如果客户端输入字符串 <code>hello</code>，服务端将响应字符串 <code>&gt; hello</code>；如果客户端输入字符串 <code>world</code>，服务端将响应字符串 <code>&gt; world</code>。完整的示例代码参见 <a href="https://github.com/yulewei/io-multiplexing-demo">io-multiplexing-demo</a>。</p>
<h1 id="Nginx-服务器的并发策略解析">Nginx 服务器的并发策略解析</h1>
<p>上文介绍了 NCSA HTTPd、Apache HTTP Server 和 thttpd 等 Web 服务器的并发策略。主要的并发策略有三种模式：单连接单进程模式、单连接单线程模式和单线程的事件驱动模式。</p>
<p><a href="https://en.wikipedia.org/wiki/Nginx">Nginx</a> 最早是 2002 年开始开发的，2004.08 采用 BSD 协议对外开源首个版本 <a href="https://github.com/nginx/nginx/tree/release-0.1.0">0.1.0</a>，开发 Nginx 的目的是为了解决 C10k 问题<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>。2002 年，当时 FreeBSD 已经提供 <code>kqueue</code> 系统调用，而 Linux 的 <code>epoll</code> 即将正式发布，新的 <code>kqueue</code> 和 <code>epoll</code> 系统调用让 Nginx 解决 C10k 问题成为可能。根据 w3techs 的统计，在 2013.07 Nginx 超越 Apache 成为 top 1000 网站使用最多的 Web 服务器<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>。</p>
<p>Nginx 采用的是<strong>事件驱动架构</strong>，在单线程的进程上执行事件循环，以异步非阻塞的方式处理 I/O 操作事件，事件循环底层基于高效的 <code>epoll</code> 或 <code>kqueue</code> 实现的 I/O 多路复用<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>。</p>
<p>Nginx 服务器，区分 Master 进程和 Worker 进程。Master 进程，用于加载配置文件、启动 Worker 进程和平滑升级等。Worker 进程，是单线程的进程，用于执行事件循环，并以非阻塞方式处理 I/O 操作，因此单个 Worker 进程就能并发处理大量连接。一个完整的请求完全由 Worker 进程来处理，而且只在一个 Worker 进程中处理。为了能充分利用多核 CPU 资源，通常生产环境配置的 Worker 进程数量等于 CPU 核心数。Nginx 的架构图如下<sup class="footnote-ref"><a href="#fn22" id="fnref22:1">[22:1]</a></sup>：</p>
<img width="700" alt="Nginx 架构图" title="Nginx 架构图" src="https://static.nullwy.me/nginx-architecture.png">
<h1 id="Redis-服务器的并发策略解析">Redis 服务器的并发策略解析</h1>
<p>Redis 是内存数据库，处理网络请求也是采用<strong>单线程的事件驱动模式</strong>，底层基于高效的 <code>epoll</code> 或 <code>kqueue</code> 实现的 I/O 多路复用。事件循环处理的事件主要有，建立客户端新连接事件、客户端连接的缓冲区可读事件、客户端连接的缓冲区可写事件。Redis 的命令处理过程如下：</p>
<ul>
<li>在收到建立客户端新连接事件后，会在新建立的客户端套接字上监听可读事件，用于等待客户端发起命令请求。客户端连接可能会一直保持，处理之后的多个客户端命令请求。</li>
<li>如果监听到客户端连接的缓冲区可读事件，也就是收到客户端的命令请求，服务器会读取命令、解析命令，然后执行命令，最后把命令响应结果输出到内存缓冲区。值得注意的是，命令响应结果输出到内存缓冲区，但并未输出客户端连接的缓冲区。</li>
<li>在等到开启新的事件循环时，Redis 会在等待接收新的 I/O 事件之前，统一将全部内存缓冲区的命令响应结果输出到各个客户端。当命令响应结果数据量非常大时，无法一次性将所有数据都发送给某客户端，这时就会监听该客户端缓冲区可写事件。</li>
<li>如果监听到客户端连接的缓冲区可写事件，Redis 就会发送剩余部分的数据给客户端。</li>
</ul>
<p>上述的命令处理过程，在源码层面上涉及的核心代码都在 <code>networking.c</code> 中：处理客户端新连接建立的事件的回调函数是 <a href="https://github.com/redis/redis/blob/4.0.14/src/networking.c#L695">acceptTcpHandler</a>，处理客户端命令请求事件的回调函数 <a href="https://github.com/redis/redis/blob/4.0.14/src/networking.c#L1391">readQueryFromClient</a>，命令响应结果输出到各个客户端对应的函数是 <a href="https://github.com/redis/redis/blob/4.0.14/src/networking.c#L1011">handleClientsWithPendingWrites</a>，处理客户端的可写事件的回调函数是 <a href="https://github.com/redis/redis/blob/4.0.14/src/networking.c#L1004">sendReplyToClient</a>。更详细的实现原理解析，本文不再展开，可以自行深入阅读相关源代码或书籍资料。</p>
<p>Redis 与 Nginx 在并发策略上有不同的选择，Nginx 有多个 Worker 进程，每个 Worker 进程都运行自己的事件循环，而 <strong>Redis 整体上只有一个事件循环，采用的是单线程架构</strong>。这样的架构设计带来的问题就是 Redis 无法多核 CPU 并发。针对无法多核 CPU 并发问题，Redis 官方 FAQ 的推荐的解决方案是<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>：在多核 CPU 的单台机器上启动多个 Redis 实例。Redis 作者 antirez，解释了选择单线程而不选择多线程的原因，主要是：在 Redis 的数据结构上实现并发控制太复杂，多线程编程降低开发速度并且导致 bug 修复困难<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup><sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>。采用单线程的原因，概况成一句话就是<sup class="footnote-ref"><a href="#fn25" id="fnref25:1">[25:1]</a></sup>：</p>
<blockquote>
<p>There is less to gain, and a lot of complexity to add.</p>
</blockquote>
<p>不过，随着 Redis 版本的演进，部分逻辑已经改成了多线程实现，Redis 新增的多线程特性有三处，Redis 2.4 新增的异步磁盘 IO、Redis 4.0 新增的“<a href="https://github.com/redis/redis/blob/4.0.0/redis.conf#L603">Lazy Freeing</a>”和 Redis 6.0 新增的“<a href="https://github.com/redis/redis/blob/6.0.0/redis.conf#L972">Threaded I/O</a>”。<strong>但整体设计上，还是可以认为 Redis 主要使用单线程设计，依然是单线程的事件循环，并以单线程的方式执行命令</strong>（绝大多数命令，“Lazy Freeing”相关的命令除外）<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup><sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup>。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>FreeBSD操作系统设计与实现，McKusick，2004：6.4.5 描述符上的多路I/O操作 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Unix网络编程 卷1：套接字联网API，Stevens，第3版2003 <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2014-04 AIO User Guide: A description of how to use AIO <a href="https://web.archive.org/web/0/http://code.google.com/p/kernel/wiki/AIOUserGuide">https://web.archive.org/web/0/http://code.google.com/p/kernel/wiki/AIOUserGuide</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Awesome io_uring <a href="https://github.com/espoal/awesome-iouring">https://github.com/espoal/awesome-iouring</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2006-08 M. Jones: Boost application performance using asynchronous I/O <a href="https://developer.ibm.com/articles/l-async/">https://developer.ibm.com/articles/l-async/</a> <a href="#fnref5" class="footnote-backref">↩︎</a> <a href="#fnref5:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Learning Libevent: A tiny introduction to asynchronous IO <a href="https://libevent.org/libevent-book/01_intro.html">https://libevent.org/libevent-book/01_intro.html</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Node.js: JavaScript Asynchronous Programming and Callbacks <a href="https://nodejs.dev/en/learn/javascript-asynchronous-programming-and-callbacks/">https://nodejs.dev/en/learn/javascript-asynchronous-programming-and-callbacks/</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>1995-04 NCSA httpd: Performance of Several HTTP Demons on an HP 735 Workstation <a href="https://web.archive.org/web/0/http://www.ncsa.uiuc.edu/InformationServers/Performance/V1.4/report.html">https://web.archive.org/web/0/http://www.ncsa.uiuc.edu/InformationServers/Performance/V1.4/report.html</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>About the Apache HTTP Server Project <a href="https://httpd.apache.org/ABOUT_APACHE.html">https://httpd.apache.org/ABOUT_APACHE.html</a> <a href="#fnref9" class="footnote-backref">↩︎</a> <a href="#fnref9:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Changes with Apache (12 Jun 1995: This release included modified versions of a lot of code from the Apache 0.6.4 public release, plus an early pre-forking patch codeveloped by Robert Thau and Rob Hartill.) <a href="https://github.com/apache/httpd/blob/1.3.x/src/CHANGES#L9427">https://github.com/apache/httpd/blob/1.3.x/src/CHANGES#L9427</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Apache HTTP Server Version 2.2: Multi-Processing Modules (MPMs) <a href="https://httpd.apache.org/docs/2.2/en/mpm.html#defaults">https://httpd.apache.org/docs/2.2/en/mpm.html#defaults</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>1995 John Ousterhout: Why Threads Are A Bad Idea (for most purposes) (slides) <a href="http://www.cc.gatech.edu/classes/AY2010/cs4210_fall/papers/ousterhout-threads.pdf">http://www.cc.gatech.edu/classes/AY2010/cs4210_fall/papers/ousterhout-threads.pdf</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>1998-07 Jef Poskanzer: Web Server Comparisons（thttpd 服务器作者） <a href="http://www.acme.com/software/thttpd/benchmarks.html">http://www.acme.com/software/thttpd/benchmarks.html</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>1998 Gaurav Banga, Jeffrey C. Mogul: <strong>Scalable Kernel Performance for Internet Servers Under Realistic Loads</strong>. USENIX Annual Technical Conference 1998 <a href="https://dblp.uni-trier.de/rec/conf/usenix/BangaM98.html">dblp</a> <a href="https://www.usenix.org/conference/1998-usenix-annual-technical-conference/scalable-kernel-performance-internet-servers">usenix.org</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>1999-05 Dan Kegel: The C10K problem（最后更新时间 2011.07） <a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>2014-02 详解浏览器最大并发连接数 <a href="https://web.archive.org/web/0/http://www.iefans.net/liulanqi-zuida-bingfa-lianjieshu">https://web.archive.org/web/0/http://www.iefans.net/liulanqi-zuida-bingfa-lianjieshu</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Linux Unix系统编程手册，Kerrisk 下册：第63章 其他备选的I/O模型 <a href="#fnref17" class="footnote-backref">↩︎</a> <a href="#fnref17:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2001 Jonathan Lemon: <strong>Kqueue - A Generic and Scalable Event Notification Facility</strong>. USENIX Annual Technical Conference 2001 <a href="https://dblp.org/rec/conf/usenix/Lemon01.html">dblp</a> <a href="https://www.usenix.org/conference/2001-usenix-annual-technical-conference/kqueue%E2%80%93-generic-and-scalable-event-notification">usenix.org</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>What is the purpose of epoll's edge triggered option? <a href="https://stackoverflow.com/a/73540436/689699">https://stackoverflow.com/a/73540436/689699</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>2012-01 Interview with Igor Sysoev, author of Apache's competitor NGINX <a href="https://web.archive.org/web/0/http://www.freesoftwaremagazine.com/articles/interview_igor_sysoev_author_apaches_competitor_nginx">https://web.archive.org/web/0/http://www.freesoftwaremagazine.com/articles/interview_igor_sysoev_author_apaches_competitor_nginx</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>2013-07 Nginx just became the most used web server among the top 1000 websites <a href="https://w3techs.com/blog/entry/nginx_just_became_the_most_used_web_server_among_the_top_1000_websites">https://w3techs.com/blog/entry/nginx_just_became_the_most_used_web_server_among_the_top_1000_websites</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>2012-03 AOSA Volume 2 - nginx (Andrew Alexeev) <a href="https://aosabook.org/en/v2/nginx.html">https://aosabook.org/en/v2/nginx.html</a> <a href="#fnref22" class="footnote-backref">↩︎</a> <a href="#fnref22:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Redis FAQ: How can Redis use multiple CPUs or cores? <a href="https://redis.io/docs/getting-started/faq/#how-can-redis-use-multiple-cpus-or-cores">https://redis.io/docs/getting-started/faq/#how-can-redis-use-multiple-cpus-or-cores</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>2010-09 antirez: An update on the Memcached/Redis benchmark <a href="http://oldblog.antirez.com/post/update-on-memcached-redis-benchmark.html">http://oldblog.antirez.com/post/update-on-memcached-redis-benchmark.html</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>2019-02 antirez: An update about Redis developments in 2019 <a href="http://antirez.com/news/126">http://antirez.com/news/126</a> <a href="#fnref25" class="footnote-backref">↩︎</a> <a href="#fnref25:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Redis Doc: Diagnosing latency issues: Single threaded nature of Redis <a href="https://redis.io/docs/management/optimization/latency/#single-threaded-nature-of-redis">https://redis.io/docs/management/optimization/latency/#single-threaded-nature-of-redis</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>2019-08 林添毅：正式支持多线程！Redis 6.0与老版性能对比评测 <a href="https://mp.weixin.qq.com/s/6WQNq5dNk-GuEhZXtVCo-A">https://mp.weixin.qq.com/s/6WQNq5dNk-GuEhZXtVCo-A</a> <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>IO</tag>
        <tag>服务器</tag>
        <tag>网络</tag>
        <tag>并发</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java书籍资料整理</title>
    <url>/2016/11/java-books/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Template:Java_%28software_platform%29">https://en.wikipedia.org/wiki/Template:Java_(software_platform)</a><br>
<a href="http://c2.com/cgi/wiki?JavaIdioms">http://c2.com/cgi/wiki?JavaIdioms</a><br>
<a href="http://c2.com/cgi/wiki?JavaDesignFlaws">http://c2.com/cgi/wiki?JavaDesignFlaws</a> Java语言设计缺陷</p>
<ol>
<li>2011-06 Java Books Reading Order <a href="http://stackoverflow.com/q/6341593">http://stackoverflow.com/q/6341593</a></li>
<li>2009-03 Java书籍Top 10 <a href="http://coolshell.cn/articles/14.html">http://coolshell.cn/articles/14.html</a></li>
<li>2012-03 JVM程序员的阅读清单 <a href="http://blog.jobbole.com/15342/">http://blog.jobbole.com/15342/</a></li>
</ol>
<span id="more"></span>
<hr>
<h1 id="Java官方文档与书籍">Java官方文档与书籍</h1>
<p><a href="http://docs.oracle.com/javase/8/">http://docs.oracle.com/javase/8/</a><br>
<a href="http://docs.oracle.com/javase/tutorial/">http://docs.oracle.com/javase/tutorial/</a></p>
<p>Java Language and Virtual Machine Specifications <a href="http://docs.oracle.com/javase/specs/">http://docs.oracle.com/javase/specs/</a></p>
<p>Sun官方Addison-Wesley出版的Java Series，<a href="http://www.informit.com/imprint/series_detail.aspx?ser=334838">link</a></p>
<ol>
<li>1996-2014，<a href="http://en.wikipedia.org/wiki/James_Gosling">Gosling</a>, <a href="http://en.wikipedia.org/wiki/Bill_Joy">Joy</a>, <a href="http://en.wikipedia.org/wiki/Guy_L._Steele">Steele</a>, <a href="http://en.wikipedia.org/wiki/Gilad_Bracha">Bracha</a>，《Java语言规范》（The Java Language Specification, <a href="http://amzn.com/0201310082">2nd</a> 2000, <a href="http://amzn.com/0321246780">3rd</a> 2005, <a href="http://amzn.com/013390069X">Java SE 8</a> 2014），Java 7 <a href="http://docs.oracle.com/javase/specs/jls/se7/html/index.html">online</a>，第3版<a href="http://book.douban.com/subject/1837615/">豆瓣</a>，Java 8中文<a href="https://book.douban.com/subject/26740358/">豆瓣</a></li>
<li>1996-2013，Lindholm, Yellin, <a href="http://en.wikipedia.org/wiki/Gilad_Bracha">Bracha</a>, etc，《<strong>Java虚拟机规范</strong>》（The Java Virtual Machine Specification, <a href="http://amzn.com/020163452X">1st</a> 1996, <a href="http://amzn.com/0201432943">2nd</a> 1999, <a href="http://www.amazon.com/Virtual-Machine-Specification-Edition-Series/dp/0133260445">Java SE 7</a> 2013, <a href="http://amzn.com/013390590X">Java SE 8</a> 2014），Java 7 <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/">online</a>，<a href="http://book.douban.com/subject/25792515/">豆瓣</a></li>
<li>1996-2005，<a href="http://en.wikipedia.org/wiki/Ken_Arnold">Arnold</a>, <a href="http://en.wikipedia.org/wiki/James_Gosling">Gosling</a>, etc，《Java程序设计语言》（The Java Programming Language, 1st 1996，2nd 1997，<a href="http://amzn.com/0321349806">4th</a> 2005），第4版<a href="http://book.douban.com/subject/1908274/">豆瓣</a>：涵盖J2SE 5.0，内容比《Java编程思想》精简，条理更清晰，覆盖面更广</li>
<li>1998-2013，《Java教程》（The Java Tutorial: A Short Course on the Basics, <a href="http://amzn.com/0201310074">2nd</a> 1998, <a href="http://amzn.com/0201703939%20">3rd</a> 2001, <a href="http://amzn.com/0321334205">4th</a> 2006, <a href="http://www.amazon.com/The-Java-Tutorial-Course-Edition/dp/0132761696">5th</a> 2013），第4版<a href="http://book.douban.com/subject/2208538/">豆瓣</a>：全书415页，涵盖Java 5.0和6.0，内容比《Java程序设计语言》简单，是官方在线指定文档</li>
<li>1997，《Java经典问答》（The Java Faq, 1997），<a href="http://book.douban.com/subject/1244713/">豆瓣</a></li>
<li>1997.06，《Java语言编码规范》（Code Conventions for the Java Programming Language），<a href="http://oracle.com">oracle.com</a> <a href="http://www.oracle.com/technetwork/java/index-135089.html">html</a>, <a href="http://www.oracle.com/technetwork/java/codeconventions-150003.pdf">pdf</a></li>
</ol>
<hr>
<h1 id="Java书籍">Java书籍</h1>
<ol>
<li>1998-2006，<a href="http://en.wikipedia.org/wiki/Bruce_Eckel">Bruce Eckel</a>，《Java编程思想》（<a href="http://en.wikipedia.org/wiki/Thinking_in_Java">Thinking in Java</a>, <a href="http://amzn.com/0136597238">1st</a> 1998, <a href="http://www.amazon.com/Thinking-Java-4th-Bruce-Eckel/dp/0131872486">4th</a> 2006），<a href="http://mindview.net/Books/TIJ4">home</a>，<a href="http://book.douban.com/subject/2130190/">豆瓣</a>：内容有深度，但组织混乱，抓不住脉络，杂糅了Java与C++比较、设计模式等内容，2003年Jolt震撼大奖</li>
<li>1996-2012，Cay S. Horstmann，《Java核心技术，2卷》（Core Java 2, <a href="http://dl.acm.org/citation.cfm?id=230334">1st</a> 1996, <a href="http://www.informit.com/store/core-java-volume-i-fundamentals-9780132354769">8th</a> 2007, <a href="http://www.amazon.com/Core-Java-I--Fundamentals-9th/dp/0137081898">9th</a> 2012），<a href="http://www.horstmann.com/corejava.html">home</a>，第10版卷1<a href="https://book.douban.com/subject/26880667/">豆瓣</a>、卷2<a href="http://book.douban.com/subject/25841326/">豆瓣</a></li>
<li>2001、2008，<a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Joshua Bloch</a>，《Effective Java》，<a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683">2nd</a> 2008，<a href="http://book.douban.com/subject/3360807/">豆瓣</a>：2002年Jolt震撼大奖</li>
<li>2005，<a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Joshua Bloch</a> &amp; Neal Gafter，《Java解惑》（Java Puzzlers: Traps, Pitfalls, and Corner Cases, <a href="http://www.amazon.com/Java%C2%BF-Puzzlers-Traps-Pitfalls-Corner/dp/032133678X">amazon</a>），<a href="http://www.javapuzzlers.com/">home</a>，<a href="http://www.ituring.com.cn/book/88">图灵</a><a href="http://www.ituring.com.cn/book/88">2010</a>，<a href="http://book.douban.com/subject/5362860/">豆瓣</a></li>
<li>Java语言精粹 Java: The Good Parts <a href="http://book.douban.com/subject/6516576/">http://book.douban.com/subject/6516576/</a></li>
<li>2006，Metsker，《Java设计模式》（Design Patterns in Java, <a href="http://amzn.com/0321333020">amazon</a>），<a href="http://book.douban.com/subject/1972333/">豆瓣</a>，修订版<a href="http://book.douban.com/subject/11629400/">豆瓣</a></li>
<li><a href="http://en.wikipedia.org/wiki/Herbert_Schildt">Herbert Schildt</a>，《Java完全参考手册》（Java: The Complete Reference, <a href="http://amzn.com/0071606300">8th</a> 2011），第8版<a href="http://book.douban.com/subject/19955764/">豆瓣</a>，第9版<a href="http://book.douban.com/subject/26556574/">豆瓣</a>：Oracle Press，全书1105页，参考手册，可读性不高，涵盖Java 7</li>
<li><a href="http://en.wikipedia.org/wiki/Herbert_Schildt">Herbert Schildt</a>，《Java编程入门教程》（Java: A Beginner's Guide），第6版<a href="http://book.douban.com/subject/26320992/">豆瓣</a></li>
<li>2012，Sarang，《Java 7编程高级进阶》（Java Programming, <a href="http://amzn.com/007163360X">amazon</a>），<a href="http://book.douban.com/subject/22226750/">豆瓣</a>：Oracle Press，内容条理清晰，但<strong>深度、广度不够</strong>，Java虚拟机技术总监Pampuch作序，客户端软件的首席架构师Coward技术校审</li>
<li>Jakarta Commons Cookbook中文版 <a href="https://book.douban.com/subject/1936665/">https://book.douban.com/subject/1936665/</a></li>
</ol>
<p><a href="https://github.com/iluwatar/java-design-patterns">https://github.com/iluwatar/java-design-patterns</a></p>
<h1 id="Java并发编程">Java并发编程</h1>
<ol>
<li>2006，<a href="https://www.linkedin.com/in/briangoetz">Goetz</a>, Peierls, <a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Joshua Bloch</a>, <a href="http://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a> &amp; etc，《Java并发编程实战》（Java Concurrency in Practice, <a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">amazon</a>），<a href="http://book.douban.com/subject/10484692/">豆瓣</a>：top1书籍，Sun官方书籍，相对偏向理论的并发编程书籍见“多处理器编程的艺术，修订版2012”</li>
<li>2011，Subramaniam，《Java虚拟机并发编程》（Programming Concurrency on the JVM, <a href="http://www.amazon.com/Programming-Concurrency-JVM-Mastering-Synchronization/dp/193435676X">amazon</a>），<a href="http://book.douban.com/subject/24533312/">豆瓣</a>：全书216页，主要讲Scala下的Akka</li>
<li>1999，<a href="http://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a>，《Java并发编程：设计原则与模式》（Concurrent Programming in Java, <a href="http://amzn.com/0201310090">2nd</a> 1999），<a href="http://book.douban.com/subject/1244021/">豆瓣</a>：过时</li>
<li>2012，[西] González，《Java 7并发编程实战手册》（Java 7 Concurrency Cookbook, <a href="http://amzn.com/1849687889%20">amazon</a>），<a href="http://book.douban.com/subject/25844475/">豆瓣</a>：amazon评价不高，可作辅助阅读，难度低于Goetz版</li>
</ol>
<p>2012-12 Review : Java 7 Concurrency Cookbook，原文：<a href="http://www.mkyong.com/book-review/review-java-7-concurrency-cookbook/">mkyong.com</a>，译文：<a href="http://www.importnew.com/2346.html">importnew.com</a></p>
<h1 id="Java高级内容（Java-7-Java-8）">Java高级内容（Java 7 &amp; Java 8）</h1>
<ol>
<li>2012，Evans &amp; Verburg，《Java程序员修炼之道》（The Well-Grounded Java Developer, <a href="http://www.amazon.com/The-Well-Grounded-Java-Developer-Programming/dp/1617290068">amazon</a>），<a href="http://www.ituring.com.cn/book/1027">图灵2013</a>，<a href="http://book.douban.com/subject/24841235/">豆瓣</a>：全面解读Groovy、Scala在JVM上的应用</li>
<li>2014，《Java 8实战》（Java 8 in Action, <a href="http://amzn.com/1617291994">amazon</a>），<a href="https://book.douban.com/subject/26772632/">豆瓣</a></li>
<li>2014，Horstmann，《写给大忙人看的Java SE 8》（Java SE 8 for the Really Impatient, <a href="https://amzn.com/0321927761">amazon</a>），<a href="http://book.douban.com/subject/26274206/">豆瓣</a>：极好的全面介绍Java 8</li>
<li>2014，《Java 8函数式编程》（Java 8 Lambdas, <a href="https://amzn.com/1449370772">amazon</a>），<a href="http://book.douban.com/subject/26346017/">豆瓣</a></li>
<li>2014，Subramaniam，“Functional Programming in Java”, <a href="http://amzn.com/1937785467">amazon</a>，<a href="http://book.douban.com/subject/25830739/">豆瓣</a></li>
</ol>
<h1 id="Java虚拟机与底层书籍">Java虚拟机与底层书籍</h1>
<ol>
<li>2014，Scott Oaks，《Java性能权威指南》（Java Performance: The Definitive Guide），<a href="https://book.douban.com/subject/26740520/">豆瓣</a></li>
<li>2011，Charlie Hunt, Binu John，《Java性能优化权威指南》（Java Performance, <a href="http://www.amazon.com/Java-Performance-Charlie-Hunt/dp/0137142528">amazon</a>），<a href="http://book.douban.com/subject/25828043/">豆瓣</a>：第1作者是Oracle JVM性能主管工程师</li>
<li>2000，Bill Venners，《深入Java虚拟机》（Inside the Java Virtual Machine, <a href="http://www.amazon.com/Inside-Java-2-Virtual-Machine/dp/0071350934">2nd</a> 2000），<a href="http://book.douban.com/subject/1138768/">豆瓣</a></li>
<li>2011、2013，周志明，《深入理解Java虚拟机：VM高级特性与最佳实践》，<a href="http://book.douban.com/subject/24722612/">豆瓣</a>：相比较陈涛版更偏向概念和理论</li>
<li>2014，陈涛，《HotSpot实战》，<a href="http://book.douban.com/subject/25847620/">豆瓣</a>：内容有大量的HotSpot源码解析</li>
<li>2015，高翔龙，《Java虚拟机精讲》，<a href="http://book.douban.com/subject/26353219/">豆瓣</a></li>
<li>2014，《大规模Java平台虚拟化与调优》</li>
<li>Scott Oaks, Java Performance: The Definitive Guide，<a href="http://book.douban.com/subject/25872755/">豆瓣</a></li>
<li>2015，OpenJDK cookbook，<a href="http://amzn.com/1849698406">amazon</a></li>
</ol>
<hr>
<h1 id="偏向Java-EE">偏向Java EE</h1>
<ol>
<li>2004，<a href="http://en.wikipedia.org/wiki/Bruce_Tate">Bruce Tate</a>，《轻快的Java》（Better, Faster, Lighter Java, <a href="http://shop.oreilly.com/product/9780596006761.do">O'Reilly</a>, <a href="http://www.amazon.com/Better-Faster-Lighter-Java-Bruce/dp/0596006764">amazon</a>），<a href="http://book.douban.com/subject/1911882/">豆瓣</a>：2005年Jolt震撼大奖</li>
<li>2005，<a href="http://en.wikipedia.org/wiki/Bruce_Tate">Bruce Tate</a>，《超越Java：探讨程序语言的未来》（Beyond Java, <a href="http://shop.oreilly.com/product/9780596100940.do">O'Reilly</a>, <a href="http://www.amazon.com/Beyond-Java-Bruce-Tate/dp/0596100949">amazon</a>），<a href="http://book.douban.com/subject/2043934/">豆瓣</a></li>
<li>2010，<a href="http://en.wikipedia.org/wiki/Bruce_Tate">Bruce Tate</a>，《七周七语言：理解多种编程范型》（Seven Languages in Seven Weeks, <a href="http://pragprog.com/book/btlang/seven-languages-in-seven-weeks">Pragmatic</a>, <a href="http://www.amazon.com/Seven-Languages-Weeks-Programming-Programmers/dp/193435659X">amazon</a>），<a href="http://book.douban.com/subject/10555435/">豆瓣</a>：2011年Jolt生产力大奖</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Agent 学习笔记</title>
    <url>/2018/10/java-agent/</url>
    <content><![CDATA[<p>Java 从 1.5 开始提供了 <code>java.lang.instrument</code>（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/instrumentation/">doc</a>）包，该包为检测（<a href="https://en.wikipedia.org/wiki/Instrumentation_%28computer_programming%29">instrument</a>） Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 <code>java.lang.instrument</code> 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测。关于如何使用 <code>java.lang.instrument</code> 包，可以参考 javadoc 的包描述（<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">en</a>, <a href="http://www.cjsdn.net/doc/jdk60/java/lang/instrument/package-summary.html">zh</a>）。</p>
<span id="more"></span>
<p>开发 Java Agent 的涉及的要点如下图所示 [ <a href="https://zeroturnaround.com/rebellabs/how-to-inspect-classes-in-your-jvm/">ref</a> ]<br>
<img width="700" alt="Java Agent" title="Java Agent" src="https://static.nullwy.me/java-agent-overview.png"></p>
<p>Java Agent 支持两种方式加载，启动时加载，即在 JVM 程序启动时在命令行指定一个选项来启动代理；启动后加载，这种方式使用从 JDK 1.6 开始提供的 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/attach/index.html">Attach API</a> 来动态加载代理。</p>
<h1 id="启动时加载-agent">启动时加载 agent</h1>
<h2 id="最简单的例子">最简单的例子</h2>
<p>现在创建命名为 proj-demo 的 gradle 项目，目录布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree proj-demo</span><br><span class="line">proj-demo</span><br><span class="line">├── build.gradle</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   └── java</span><br><span class="line">    │       └── com</span><br><span class="line">    │           └── demo</span><br><span class="line">    │               └── App.java</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br><span class="line"></span><br><span class="line">7 directories, 2 files</span><br></pre></td></tr></table></figure>
<p><code>com.demo.App</code> 类的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(getGreeting());</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getGreeting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>com.demo.App</code>，每隔 1 秒输出 <code>hello world</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gradle build</span><br><span class="line">$ java -<span class="built_in">cp</span> <span class="string">&quot;target/classes/java/main&quot;</span> com.demo.App</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>现在创建名称为 proj-premain 的 gradle 项目，<code>com.demo.MyPremain</code> 类实现 <code>premain</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPremain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        System.out.println(agentArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>META-INF/MANIFEST.MF</code> 文件指定 <code>Premain-Class</code> 属性：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">&#x27;Premain-Class&#x27;</span>: <span class="string">&#x27;com.demo.MyPremain&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">from</span> &#123;</span><br><span class="line">        <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包生成 <code>proj-premain.jar</code>，这个 jar 包就是 javaagent 代理。现在来试试运行 <code>com.demo.App</code> 时，启动这个 javaagent 代理。根据 javadoc 的描述，可以将以下选项添加到命令行来启动代理：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-javaagent:jarpath[=options] </span><br></pre></td></tr></table></figure>
<p>指定 <code>-javaagent:&quot;proj-premain.jar=hello agent&quot;</code>，传入的 <code>agentArgs</code> 为 <code>hello agent</code>，再次运行 <code>com.demo.App</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ java -javaagent:<span class="string">&quot;proj-premain.jar=hello agent&quot;</span> -<span class="built_in">cp</span> <span class="string">&quot;target/classes/java/main&quot;</span> com.demo.App</span><br><span class="line">hello agent</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>可以看到，在运行 <code>main</code> 之前，运行了 <code>premain</code> 方法，即先输出 <code>hello agent</code>，每隔 1 秒输出 <code>hello world</code>。</p>
<h2 id="修改字节码">修改字节码</h2>
<p>在实现 <code>premain</code> 时，除了能获取 <code>agentArgs</code> 参数，还能获取 <code>Instrumentation</code> 实例。<code>Instrumentation</code> 类提供 <code> addTransformer</code> 方法，用于注册提供的转换器 <code>ClassFileTransformer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册提供的转换器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span><br></pre></td></tr></table></figure>
<p><code>ClassFileTransformer</code> 是抽象接口，唯一需要实现的是 <code>transform</code> 方法。在转换器使用 <code>addTransformer</code> 注册之后，每次定义新类时（调用 <code>ClassLoader.defineClass</code>）都将调用该转换器的 <code>transform</code> 方法。该方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此方法的实现可以转换提供的类文件，并返回一个新的替换类文件</span></span><br><span class="line"><span class="type">byte</span>[] transform(ClassLoader loader,</span><br><span class="line">                 String className,</span><br><span class="line">                 Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                 ProtectionDomain protectionDomain,</span><br><span class="line">                 <span class="type">byte</span>[] classfileBuffer)</span><br><span class="line">                 <span class="keyword">throws</span> IllegalClassFormatException</span><br></pre></td></tr></table></figure>
<p>操作字节码可以使用 ASM、Apache BCEL、Javassist、cglib、Byte Buddy 等库。下面示例代码，使用 <a href="https://commons.apache.org/proper/commons-bcel/">BCEL</a> 库实现名为 <code>GreetingTransformer</code> 转换器。该转换器实现的逻辑就是，将 <code>com.demo.App.getGreeting()</code> 方法输出的 <code>hello world</code>，替换为输出 <code>premain</code> 方法的传入的参数 <code>agentArgs</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPremain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">GreetingTransformer</span>(agentArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.bcel.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String agentArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GreetingTransformer</span><span class="params">(String agentArgs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.agentArgs = agentArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!className.equals(<span class="string">&quot;com/demo/App&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> Repository.lookupClass(className);</span><br><span class="line">            <span class="type">ClassGen</span> <span class="variable">cg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassGen</span>(clazz);</span><br><span class="line">            <span class="type">ConstantPoolGen</span> <span class="variable">cp</span> <span class="operator">=</span> cg.getConstantPool();</span><br><span class="line">            <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;getGreeting&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">MethodGen</span> <span class="variable">mg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodGen</span>(method, cg.getClassName(), cp);</span><br><span class="line">                    <span class="type">InstructionList</span> <span class="variable">il</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstructionList</span>();</span><br><span class="line">                    il.append(<span class="keyword">new</span> <span class="title class_">PUSH</span>(cp, <span class="built_in">this</span>.agentArgs));</span><br><span class="line">                    il.append(InstructionFactory.createReturn(Type.STRING));</span><br><span class="line">                    mg.setInstructionList(il);</span><br><span class="line">                    mg.setMaxStack();</span><br><span class="line">                    mg.setMaxLocals();</span><br><span class="line">                    cg.replaceMethod(method, mg.getMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cg.getJavaClass().getBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="启动后加载-agent">启动后加载 agent</h1>
<p>最早 JDK 1.5发布 <code>java.lang.instrument</code> 包时，agent 是必须在 JVM 启动时，通过命令行选项附着（attach）上去。但在 JVM 正常运行时，加载 agent 没有意义，只有出现问题，需要诊断才需要附着 agent。JDK 1.6 实现了 attach-on-demand（按需附着）[ JDK-<a href="https://bugs.openjdk.java.net/browse/JDK-4882798">4882798</a> ]，可以使用 Attach API 动态加载 agent [ <a href="https://blogs.oracle.com/corejavatechtips/the-attach-api">oracle blog</a>, <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/attach/index.html">javadoc</a> ]。这个 Attach API 在 <code>tools.jar</code> 中。JVM 启动时默认不加载这个 jar 包，需要在 classpath 中额外指定。使用 Attach API 动态加载 agent 的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: java -cp .:$JAVA_HOME/lib/tools.jar&quot;</span></span><br><span class="line">                    + <span class="string">&quot; com.demo.AgentLoader &lt;pid/name&gt; &lt;agent&gt; [options]&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">jvmPid</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">agentJar</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">options</span> <span class="operator">=</span> args.length &gt; <span class="number">2</span> ? args[<span class="number">2</span>] : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (VirtualMachineDescriptor jvm : VirtualMachine.list()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jvm.displayName().contains(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                jvmPid = jvm.id();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">VirtualMachine</span> <span class="variable">jvm</span> <span class="operator">=</span> VirtualMachine.attach(jvmPid);</span><br><span class="line">        jvm.loadAgent(agentJar, options);</span><br><span class="line">        jvm.detach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动时加载 agent，<code>-javaagent</code> 传入的 jar 包需要在 <code>MANIFEST.MF</code> 中包含 <code>Premain-Class</code> 属性，此属性的值是 <em>代理类</em> 的名称，并且这个 <em>代理类</em> 要实现 <code>premain</code> 静态方法。启动后加载 agent 也是类似，通过 <code>Agent-Class</code> 属性指定 <em>代理类</em>，<em>代理类</em> 要实现 <code>agentemain</code> 静态方法。agent 被加载后，JVM 将尝试调用 <code>agentmain</code> 方法。</p>
<p>上文提到每次定义新类（调用 <code>ClassLoader.defineClass</code>）时，都将调用该转换器的 <code>transform</code> 方法。对于已经定义加载的类，需要使用重定义类（调用 <code>Instrumentation.redefineClass</code>）或重转换类（调用 <code>Instrumentation.retransformClass</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册提供的转换器。如果 canRetransform 为 true，那么重转换类时也将调用该转换器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span></span><br><span class="line"><span class="comment">// 使用提供的类文件重定义提供的类集。新的类文件字节，通过 ClassDefinition 传入</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span></span><br><span class="line">                     <span class="keyword">throws</span> ClassNotFoundException, UnmodifiableClassException</span><br><span class="line"><span class="comment">// 重转换提供的类集。对于每个添加时 canRetransform 设为 true 的转换器，在这些转换器中调用 transform 方法 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span></span><br><span class="line">                        <span class="keyword">throws</span> UnmodifiableClassException</span><br></pre></td></tr></table></figure>
<p>重定义类（redefineClass）从 JDK 1.5 开始支持，而重转换类（retransformClass）是 JDK 1.6 引入。相对来说，重转换类能力更强，当存在多个转换器时，重转换将由 transform 调用链组成，而重定义类无法组成调用链。重定义类能实现的逻辑，重转换类同样能完成，所以保留重定义类方法（<code>Instrumentation.redefineClass</code>）可能只是为了向后兼容 [ <a href="https://stackoverflow.com/q/19009583">stackoverflow</a> ]。</p>
<p>实现 agentmain 的示例代码如下，其中 <code>GreetingTransformer</code> 转换器的类定义和上文一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgentMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">GreetingTransformer</span>(agentArgs), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.demo.App&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (inst.isModifiableClass(clazz)) &#123;</span><br><span class="line">                inst.retransformClasses(clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MANIFEST.MF</code> 文件配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes &#x27;Agent-Class&#x27;: &#x27;com.demo.MyAgentMain&#x27;</span><br><span class="line">        attributes &#x27;Can-Redefine-Classes&#x27; : true</span><br><span class="line">        attributes &#x27;Can-Retransform-Classes&#x27; : true</span><br><span class="line">    &#125;</span><br><span class="line">    from &#123;</span><br><span class="line">        configurations.compile.collect &#123; it.isDirectory() ? it : zipTree(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，和定义新类不同，重定义类和重转换类，可能会更改方法体、常量池和属性，但不得添加、移除、重命名字段或方法；不得更改方法签名、继承关系 [ <a href="http://www.cjsdn.net/doc/jdk60/java/lang/instrument/Instrumentation.html">javadoc</a> ]。这个限制将来可能会通过 “JEP 159: Enhanced Class Redefinition” 移除 [ <a href="http://openjdk.java.net/jeps/159">ref</a> ]。</p>
<h1 id="使用-Byte-Buddy">使用 Byte Buddy</h1>
<p>Byte Buddy（<a href="http://bytebuddy.net/">home</a>, <a href="https://github.com/raphw/byte-buddy">github</a>, <a href="http://bytebuddy.net/javadoc/1.8.0/">javadoc</a>），运行时的代码生成和操作库，2015 年获得 Oracle 官方 Duke's Choice award，提供高级别的创建和修改 Java 类文件的 API，使用这个库时，不需要了解字节码。另外，对 Java Agent 的开发 Byte Buddy 也有很好的支持，可以参考 Byte Buddy 作者 Rafael Winterhalter 写的介绍文章 [ <a href="http://www.infoq.com/cn/articles/easily-create-java-agents-with-bytebuddy">ref1</a>, <a href="https://www.sitepoint.com/fixing-bugs-in-running-java-code-with-dynamic-attach/">ref2</a> ]。</p>
<p>上文使用 BCEL 实现的 <code>GreetingTransformer</code>，现在改用 Byte Buddy，会变得非常简单。实现 <code>premain</code> 示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Default()</span><br><span class="line">            .type(ElementMatchers.named(<span class="string">&quot;com.demo.App&quot;</span>))</span><br><span class="line">            .transform(<span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Transformer() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder,</span><br><span class="line">                                                        TypeDescription typeDescription,</span><br><span class="line">                                                        ClassLoader classLoader,</span><br><span class="line">                                                        JavaModule <span class="keyword">module</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> builder.method(ElementMatchers.named(<span class="string">&quot;getGreeting&quot;</span>))</span><br><span class="line">                            .intercept(FixedValue.value(agentArgs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).installOn(inst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>agentmain</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Default()</span><br><span class="line">            .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)</span><br><span class="line">            .disableClassFormatChanges()</span><br><span class="line">            .type(ElementMatchers.named(<span class="string">&quot;com.demo.App&quot;</span>))</span><br><span class="line">            .transform(<span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Transformer() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder,</span><br><span class="line">                                                        TypeDescription typeDescription,</span><br><span class="line">                                                        ClassLoader classLoader,</span><br><span class="line">                                                        JavaModule <span class="keyword">module</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> builder.method(ElementMatchers.named(<span class="string">&quot;getGreeting&quot;</span>))</span><br><span class="line">                            .intercept(FixedValue.value(agentArgs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).installOn(inst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，Byte Buddy 对 Attach API 作了封装，屏蔽了对 <code>tools.jar</code> 的加载，可以直接使用 <code>ByteBuddyAgent</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuddyAgent.attach(<span class="keyword">new</span> <span class="title class_">File</span>(agentJar), jvmPid, options);</span><br></pre></td></tr></table></figure>
<p>上文中的 <code>AgentLoader</code>，可以使用这个 API 简化，实现的完整示例参见 <a href="https://github.com/yulewei/javaagent-demo/blob/master/proj-demo/src/main/java/com/demo/AgentLoader2.java">AgentLoader2</a>。</p>
<h1 id="实现性能计时器">实现性能计时器</h1>
<p>Byte Buddy 的 github 的 <a href="https://github.com/raphw/byte-buddy#changing-existing-classes">README</a> 文档提供了一个性能计时拦截器的代码示例，能对某个方法的运行耗时做统计。现在我们来看下是如何实现的。假设 <code>com.demo.App2</code> 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(getGreeting());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getGreeting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (<span class="number">1000</span> * Math.random()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Byte Buddy 实现计时拦截器的 agent，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerAgent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Default()</span><br><span class="line">                .type(ElementMatchers.any())</span><br><span class="line">                .transform((builder, type, classLoader, <span class="keyword">module</span>) -&gt;</span><br><span class="line">                        builder.method(ElementMatchers.nameMatches(agentArgs))</span><br><span class="line">                                .intercept(MethodDelegation.to(TimingInterceptor.class)))</span><br><span class="line">                .installOn(inst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimingInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RuntimeType</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">intercept</span><span class="params">(<span class="meta">@Origin</span> Method method, <span class="meta">@SuperCall</span> Callable&lt;?&gt; callable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> callable.call();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(method + <span class="string">&quot; took &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>getGreeting</code> 方法进行性能剖析，运行结果如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$ java -javaagent:&quot;proj-byte-buddy.jar=get.*&quot; -cp &quot;target/classes/java/main&quot; com.demo.App2</span><br><span class="line">public static java.lang.String com.demo.App2.getGreeting() took 694ms</span><br><span class="line">hello world</span><br><span class="line">public static java.lang.String com.demo.App2.getGreeting() took 507ms</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>示例代码中的 <code>premain</code> 参数 <code>agentArgs</code> 用于指定需要剖析性能的方法名，支持正则表达式。当实际参数传入 <code>get.*</code> 时，匹配到 <code>getGreeting</code> 方法。上面的示例，使用的是 Byte Buddy 的方法委托 Method Delegation API [ <a href="http://bytebuddy.net/javadoc/1.9.12/net/bytebuddy/implementation/MethodDelegation.html">javadoc</a> ]。Delegation API 实现原理就是，将被拦截的方法委托到另一个办法上，如下左图所示（图片来自 Rafael Winterhalter 的 <a href="https://www.slideshare.net/RafaelWinterhalter/runtime-code-generation-for-the-jvm">slides</a>）。这种写法会修改被代理类的类定义格式，只能用在启动时加载 agent，即 <code>premain</code> 方式代理。</p>
<p>若要通过 Byte Buddy 实现启动后动态加载 agent，官方提供了 Advice API [ <a href="http://bytebuddy.net/javadoc/1.9.12/net/bytebuddy/asm/Advice.html">javadoc</a> ]。Advice API 实现原理上是，在被拦截方法内部的开始和结尾添加代码，如下右图所示。这样只更改了方法体，不更改方法签名，也没添加额外的方法，符合重定义类（redefineClass）和重转换类（retransformClass）的限制。</p>
<img width="400" alt="delegation vs. advice" title="delegation vs. advice" src="https://static.nullwy.me/byte-buddy-delegation-vs-advice.png">
<p>现在来看下使用 Advice API 实现性能定时器的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimingAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodEnter</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="meta">@Advice</span>.Origin Method method, <span class="meta">@Advice</span>.Enter <span class="type">long</span> start)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(method + <span class="string">&quot; took &quot;</span> + duration + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Default()</span><br><span class="line">            .disableClassFormatChanges()</span><br><span class="line">            .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)</span><br><span class="line"><span class="comment">//          .with(AgentBuilder.Listener.StreamWriting.toSystemOut())</span></span><br><span class="line">            .type(ElementMatchers.any())</span><br><span class="line">            .transform((builder, type, classLoader, <span class="keyword">module</span>) -&gt;</span><br><span class="line">                    builder.visit(Advice.to(TimingAdvice.class)</span><br><span class="line">                            .on(ElementMatchers.nameMatches(agentArgs))))</span><br><span class="line">            .installOn(inst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若对 <code>com.demo.App</code> 类，动态加载这个 Advice API 实现的 agent，<code>getGreeting()</code> 方法将会被重定义为（真正的实现可能稍有不同，但原理一致）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getGreeting</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">$start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="type">String</span> <span class="variable">$result</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">$duration</span> <span class="operator">=</span> System.nanoTime() – $start;</span><br><span class="line">    System.out.println(<span class="string">&quot;App.getGreeting()&quot;</span> + <span class="string">&quot; took &quot;</span> + $duration + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实际应用案例">实际应用案例</h1>
<p>Java Agent 的实际应用案例很多，举些笔者实际工作中使用到的开源软件的应用案例。</p>
<p>微服务是目前流行的互联网架构，实施微服务架构其中用于观察分布式服务的 APM （应用性能管理）系统是必不可缺的一环。典型的 APM 系统，如 <a href="https://naver.github.io/pinpoint/">Pinpoint</a>、<a href="https://skywalking.apache.org/">SkyWalking</a>，为了减少的 Java 服务应用代码的入侵，底层实现上都采用 Java Agent 技术，在 Java 服务应用启动时加载 agent，进行字节码增强技术，实现分布式追踪、服务性能监控等特性。具体可参见 Pinpoint <a href="https://naver.github.io/pinpoint/1.8.5/installation.html#5-pinpoint-agent">文档</a>和 SkyWalking <a href="https://github.com/apache/skywalking/blob/master/docs/en/setup/service-agent/java-agent/README.md">文档</a>。</p>
<p>Alibaba Java 诊断利器 <a href="https://github.com/alibaba/arthas">Arthas</a>，实现上使用了动态 Attach API，相关源代码参见 <a href="https://github.com/alibaba/arthas/blob/4.0.x/core/src/main/java/com/taobao/arthas/core/Arthas.java">github</a>。Arthas 4.0 开始支持 <code>premain</code> 方式启动时加载 agent，参见 issue <a href="https://github.com/alibaba/arthas/issues/550">#550</a>。</p>
<hr>
<p>**附注：**本文中提到的代码，可以在 github 上访问得到，<a href="https://github.com/yulewei/javaagent-demo">javaagent-demo</a>。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>2016-08 Java 5 特性 Instrumentation 实践 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/">https://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/</a></li>
<li>2007-05 Java SE 6 新特性：Instrumentation 新功能 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a></li>
<li>2017-08 The Attach API <a href="https://blogs.oracle.com/corejavatechtips/the-attach-api">https://blogs.oracle.com/corejavatechtips/the-attach-api</a></li>
<li>JPLIS: Java programming language agents need instrumentation support (JSR-163) <a href="https://bugs.openjdk.java.net/browse/JDK-4882798">https://bugs.openjdk.java.net/browse/JDK-4882798</a></li>
<li>need an attach mechanism <a href="https://bugs.openjdk.java.net/browse/JDK-6173612">https://bugs.openjdk.java.net/browse/JDK-6173612</a></li>
<li>Difference between redefine and retransform in javaagent <a href="https://stackoverflow.com/q/19009583">https://stackoverflow.com/q/19009583</a></li>
<li>2015-09 JVM源码分析之javaagent原理完全解读 <a href="http://www.infoq.com/cn/articles/javaagent-illustrated">http://www.infoq.com/cn/articles/javaagent-illustrated</a></li>
<li>2016-02 Rafael Winterhalter：通过使用Byte Buddy，便捷地创建Java Agent <a href="http://www.infoq.com/cn/articles/easily-create-java-agents-with-bytebuddy">http://www.infoq.com/cn/articles/easily-create-java-agents-with-bytebuddy</a></li>
<li>2017-01 Rafael Winterhalter: Fixing Bugs in Running Java Code with Dynamic Attach <a href="https://www.sitepoint.com/fixing-bugs-in-running-java-code-with-dynamic-attach/">https://www.sitepoint.com/fixing-bugs-in-running-java-code-with-dynamic-attach/</a></li>
<li>2014-08 Making Java more dynamic: runtime code generation for the JVM <a href="https://www.slideshare.net/RafaelWinterhalter/runtime-code-generation-for-the-jvm">https://www.slideshare.net/RafaelWinterhalter/runtime-code-generation-for-the-jvm</a></li>
<li>2016-04 Implementing a profiler agen with Byte Buddy which automatically attaches #110 <a href="https://github.com/raphw/byte-buddy/issues/110">https://github.com/raphw/byte-buddy/issues/110</a></li>
<li>2016-08 JavaDay Lviv 2016: Making Java more dynamic (Rafael Winterhalter) <a href="https://www.youtube.com/watch?v=jo1v8csBorw">https://www.youtube.com/watch?v=jo1v8csBorw</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字节码</tag>
        <tag>javaagent</tag>
        <tag>byte-buddy</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Executor 框架笔记</title>
    <url>/2017/03/java-executor/</url>
    <content><![CDATA[<p>本文整理 Java 并发框架 Executor 的用法，并对结合 JDK 相关的实现源码作简单分析。</p>
<h1 id="任务与线程池">任务与线程池</h1>
<p>先来看下 Executor 框架的 javadoc 描述 [ <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/package-summary.html#package_description">ref1</a> <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#package.description">ref2</a> ]</p>
<span id="more"></span>
<p>接口：</p>
<ul>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executor.html">Executor</a> 是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。根据所使用的具体 Executor 类的不同，可能在新创建的线程中，现有的任务执行线程中，或者调用 execute() 的线程中执行任务，并且可能顺序或并发执行。</li>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ExecutorService.html">ExecutorService</a> 提供了多个完整的异步任务执行框架。ExecutorService 管理任务的排队和安排，并允许受控制的关闭。<a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Callable.html">Callable</a> 表示的任何函数，结果类似于 Runnable。</li>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Future.html">Future</a> 返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。<a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/RunnableFuture.html">RunnableFuture</a> 是拥有 run 方法的 Future，run 方法执行时将设置其结果。</li>
</ul>
<p>实现：</p>
<ul>
<li>类 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a> 和 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ScheduledThreadPoolExecutor.html">ScheduledThreadPoolExecutor</a> 提供可调的、灵活的线程池。</li>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executors.html">Executors</a> 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。</li>
<li>其他基于 Executor 的实用工具包括具体类 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/FutureTask.html">FutureTask</a>，它提供 Future 的常见可扩展实现，以及 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ExecutorCompletionService.html">ExecutorCompletionService</a>，它有助于协调对异步任务组的处理。</li>
</ul>
<p>涉及到的类与接口的层次结构，如下图所示：</p>
<img width="400" alt="Executor 相关类" src="/media/executor.png">
<img width="400" alt="任务相关类" src="/media/future.png">
<h2 id="线程池">线程池</h2>
<p>Executor，此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。接口只定义唯一一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span></span><br><span class="line">    在未来某个时间执行给定的命令</span><br></pre></td></tr></table></figure>
<p>实现 Executor 接口，就是定义某种运行任务的机制。最简单的运行任务的机制是，在调用者的线程中立即运行已提交的任务，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DirectExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，以下实现将为每个任务生成一个新线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更典型的执行任务的方式是，使用线程池（<a href="https://en.wikipedia.org/wiki/Thread_pool">Thread pool</a>）。</p>
<p>JDK 下的 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executors.html">Executors</a> 类提供创建线程池的静态工厂方法：</p>
<ol>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executors.html#newFixedThreadPool%28int%29">newFixedThreadPool</a>：固定大小线程池，创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</li>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executors.html#newCachedThreadPool%28%29">newCachedThreadPool</a>：无界线程池，创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们</li>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executors.html#newSingleThreadExecutor%28%29">newSingleThreadExecutor</a>：单个后台线程池，创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程</li>
<li><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executors.html#newScheduledThreadPool%28int%29">newScheduledThreadPool</a>：任务调度线程池，创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</li>
</ol>
<p>这 4 个工厂方法返回的类型是 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ExecutorService.html">ExecutorService</a>，该接口扩展自 Executor。ExecutorService 提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Future.html">Future</a> 的方法。</p>
<p>现在让我们来看看创建线程池的静态工厂方法，对应的实现源码 [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/Executors.java">src</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>newFixedThreadPool</code>、<code>newCachedThreadPool</code> 和 <code>newSingleThreadExecutor</code> 内部都是通过类 <code>ThreadPoolExecutor</code> 实现。<a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a> 的构造方法的 javadoc 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span><br><span class="line"></span><br><span class="line">    用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 ThreadPoolExecutor。使用 Executors 工厂方法之一比使用此通用构造方法方便得多。</span><br><span class="line"></span><br><span class="line">    参数：</span><br><span class="line">        corePoolSize - 池中所保存的线程数，包括空闲线程。</span><br><span class="line">        maximumPoolSize - 池中允许的最大线程数。</span><br><span class="line">        keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</span><br><span class="line">        unit - keepAliveTime 参数的时间单位。</span><br><span class="line">        workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。 </span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor 的处理流程如下图所示（参考自《Java并发编程的艺术》第9章 Java中的线程池）：<br>
<img width="700" alt="线程池的主要处理流程" src="/media/ThreadPoolExecutor.jpg"><br>
<img width="500" alt="ThreadPoolExecutor 执行示意图" src="/media/ThreadPoolExecutor%202.jpg"></p>
<p>基本上预定义的三个线程池已经满足常见的使用需求，若有特殊需求也可以，特殊构造 ThreadPoolExecutor 实例。此类提供 protected 的 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread,%20java.lang.Runnable)">beforeExecute</a> 和 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable,%20java.lang.Throwable)">afterExecute</a> 钩子 (hook) 方法，就是预留扩展用的。</p>
<p><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> 类提供的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="type">long</span> delay, TimeUnit unit)</span></span><br><span class="line">    创建并执行在给定延迟后启用的 ScheduledFuture</span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit)</span><br><span class="line">    创建并执行在给定延迟后启用的一次性操作</span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period, TimeUnit unit)</span><br><span class="line">    创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期</span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> delay, TimeUnit unit)</span><br><span class="line">    创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟</span><br></pre></td></tr></table></figure>
<p>用法就如文档所示，不展开描述。</p>
<h2 id="提交任务">提交任务</h2>
<p>若直接使用线程运行任务，则典型的做法是创建 <a href="http://www.cjsdn.net/Doc/JDK60/java/lang/Runnable.html">Runnable</a> 接口实例，然后启动线程，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">worker.start();</span><br><span class="line">worker.join();</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> getSavedValue();</span><br></pre></td></tr></table></figure>
<p>Runnable 实例是没有直接的办法获取运行结果的返回值的，若要获取，需要添加额外的代码，如示例中 <code>getSavedValue</code>。</p>
<p>Executor 框架下，使用 ExecutorService 的 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ExecutorService.html#submit(java.util.concurrent.Callable)">submit</a> 方法提交任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span><br><span class="line">    提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。 </span><br></pre></td></tr></table></figure>
<p>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Callable 会返回结果，并且可以抛出经过检查的异常。 submit 方法也可以接受 Runnable 参数，但阅读内部实现代码的话，就可以看到，最终还是会通过 Executors 类的 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executors.html#callable(java.lang.Runnable)">callable</a> 方法，将 Runnable 转换成 Callable [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/AbstractExecutorService.java#L73">src</a> <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/FutureTask.java#L139">src</a> ]。Runnable 是为线程设计的，Callable 是为任务设计。任务和线程概念上分离，这样线程如何运用任务，即运行任务的机制，就可以按具体情况定义了。</p>
<p>上文提到 ExecutorService 扩展自 Executor 接口，那么现在就看下 submit 方法实现<span id="submit-src">源码</span> [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/AbstractExecutorService.java#L127">src</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到内部实现其实就是调用 execute，但传入参数和返回结果包裹了 Callable 和 Future。execute 方法跟具体实现有关，对于 ThreadPoolExecutor 的实现逻辑，代码会根据线程大小，以及任务队列 <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java#L433">workQueue</a> 和工作线程 <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java#L461">worker</a> 状况，做出相应选择：[ <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ThreadPoolExecutor.html">doc</a> <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java#L1318">src</a> ]：</p>
<ul>
<li>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。</li>
<li>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。</li>
<li>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</li>
</ul>
<h2 id="使用-ExecutorService">使用 ExecutorService</h2>
<p><code>ExecutorService</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        futures.add(pool.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;return 1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">        futures.add(pool.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;return 2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">        futures.add(pool.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;return 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; future : futures) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;get &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">return 2</span><br><span class="line">return 1</span><br><span class="line">get 1</span><br><span class="line">get 2</span><br><span class="line">return 3</span><br><span class="line">get 3</span><br></pre></td></tr></table></figure>
<p>为什么输出结果是这样呢？查文档知道，Future 的 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Future.html#get()">get</a> 方法，若已经完成，则直接返回，否则会等待计算完成，然后获取其结果。在示例代码中，任务1 需要 2 秒完成，任务2 需要 1 秒完成，任务3 需要 3 秒完成。自然，在线程池中完成次序是，任务2 - 任务1 - 任务3。main 主线程，先是获取 get 任务1 的执行结果，需要等待 2 秒，在去获取 get 任务2 的执行结果，此时该任务已经完成，直接返回，接下来是获取 get 任务3 的执行结果，任务3 耗时 3 秒，此时时间线是第 2 秒，所以需等 1 秒，才能获取 get 执行结果。</p>
<p>使用 ExecutorService，若想按任务完成次序获取执行结果，可以将代码中 for 循环，修改为轮询方式，就不断地在调用 get 前，先用 isDone 判断是否任务已经完成。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Iterator&lt;Future&lt;Integer&gt;&gt; iter = futures.iterator();</span><br><span class="line">    <span class="keyword">if</span> (!iter.hasNext()) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Future&lt;Integer&gt; future = iter.next();</span><br><span class="line">        <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;get &quot;</span> + result);</span><br><span class="line">            iter.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">return 2</span><br><span class="line">get 2</span><br><span class="line">return 1</span><br><span class="line">get 1</span><br><span class="line">return 3</span><br><span class="line">get 3</span><br></pre></td></tr></table></figure>
<p>这种实现方式，虽然可行，但相当繁琐。幸运的是，JDK 还提供一种更好的方法，<a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/CompletionService.html">CompletionService</a>。</p>
<h2 id="使用-CompletionService">使用 CompletionService</h2>
<p><a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/CompletionService.html">CompletionService</a> 将 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/Executor.html">Executor</a> 和 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/BlockingQueue.html">BlockingQueue</a> 的功能融合在一起。你可以将 Callable 任务提交给它来执行，然后使用类似于队列操作的 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/CompletionService.html#take()">take</a> 和 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/CompletionService.html#poll()">poll</a> 等方法来获得已完成的结果，而这些结果会在完成时将被封装为 Future。<a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/ExecutorCompletionService.html">ExecutorCompletionService</a> 实现了 CompletionService。ExecutorCompletionService 的实现非常简单。在构造函数中创建一个 BlockingQueue 来保存计算完成的结果。当计算完成时，调用 FutureTask 中的 done 方法。当提交某个任务时，该任务将首先包装为一个 QueueingFuture，这是 FutureTask 一个子类，然后再改写子类的 done 方法，并将结果放入 BlockingQueue 中，take 和 poll 方法委托给了 BlockingQueue，这些方法会在得出结果之前阻塞。[ Goetz 2006, 6.3.5 ]</p>
<p>可以看出整个实现逻辑核心在于重写 FutureTask 的 done 方法，正如这个方法的 javadoc 所述，定义该方法的目的就是如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span></span><br><span class="line">    当此任务转换到状态 isDone（不管是正常地还是通过取消）时，调用受保护的方法。默认实现不执行任何操作。子类可以重写此方法，以调用完成回调或执行簿记</span><br></pre></td></tr></table></figure>
<p>再来看下，BlockingQueue 的实现源码 [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/ExecutorCompletionService.java#L112">src</a> ]，以及 submit 任务是对应的实现源码 [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/ExecutorCompletionService.java#L178">src</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;V&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">QueueingFuture</span>(f));</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QueueingFuture</span> <span class="keyword">extends</span> <span class="title class_">FutureTask</span>&lt;Void&gt; &#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        <span class="built_in">super</span>(task, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123; completionQueue.add(task); &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再看下 ExecutorCompletionService 的 take 和 poll 方法的实现源码 [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/concurrent/ExecutorCompletionService.java#L192">src</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.take();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个实现逻辑正如上面文字所述。</p>
<p>上文示例的 <code>ExecutorMain</code>，现在用 <code>CompletionService</code> 重现实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletionServiceMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        CompletionService&lt;Integer&gt; service = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(pool);</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        futures.add(service.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;return 1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">        futures.add(service.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;return 2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">        futures.add(service.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;return 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; futures.size(); i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> service.take().get();</span><br><span class="line">            System.out.println(<span class="string">&quot;get &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果，就是依次输出，任务2 - 任务1 - 任务3：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">return 2</span><br><span class="line">get 2</span><br><span class="line">return 1</span><br><span class="line">get 1</span><br><span class="line">return 3</span><br><span class="line">get 3</span><br></pre></td></tr></table></figure>
<h2 id="Guava-的-ListenableFuture">Guava 的 ListenableFuture</h2>
<p>CompletionService 的逻辑是，任务完成后，依次添加到完成队列中，然后让主线程主动去获取这些已经完成的任务。其实这种主线程主动模式，也可以修为被动模式，即任务完成后主动以事件回调的形式通知主线程，主动方从主线程换成了任务本身。这种方式就消除了等待任务完成的过程。可惜的是直到 Java 8 新添加的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a> 才支持实现这种机制。在 Java 8 之前，需要借助第三方库，比如 Guava 提供的 <a href="http://google.github.io/guava/releases/20.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html">ListenableFuture</a>。使用 CompletableFuture 需要了解 lambda 以及函数式编程相关知识，本文暂不展开，本文只讨论 ListenableFuture。来看下 Guava 的 ListenableFuture 主要涉及到的类 [ <a href="https://github.com/google/guava/wiki/ListenableFutureExplained">doc</a> ]：</p>
<ul>
<li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListeningExecutorService.html">ListeningExecutorService</a>：扩展自 ExecutorService 接口，但不同的是，提交 <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListeningExecutorService.html#submit-java.util.concurrent.Callable-">submit</a> 过去的任务返回的是 ListenableFuture 实例。</li>
<li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html">ListenableFuture</a>：扩展自 Future 接口，唯一新增的方法是 <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html#addListener-java.lang.Runnable-java.util.concurrent.Executor-">addListener</a>，用于添加 Future 完成后的回调监听器。</li>
<li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/MoreExecutors.html">MoreExecutors</a>：工具类，类似于 JDK 的 Executors，主要提供 Executor 的桥接、转换和构造的工具方法。</li>
<li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html">Futures</a>：工具类，提供 Future 接口相关的静态工具方法，如静态方法 <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#addCallback-com.google.common.util.concurrent.ListenableFuture-com.google.common.util.concurrent.FutureCallback-">addCallback</a> 用于添加任务执行的回调监听器，包括对任务执行成功的 onSuccess 事件和执行失败（抛出异常或<a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/CancellationException.html">被取消</a>）的 onFailure 事件。</li>
<li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFutureTask.html">ListenableFutureTask</a>：实现 ListenableFuture 接口的 FutureTask。</li>
</ul>
<p>这些类如何使用呢？还是先来看下示例代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenableFutureMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListeningExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        ListenableFuture&lt;Integer&gt; task = service.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(task, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(Integer result)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onSuccess &quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onFailure&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释下。MoreExecutors 工具类的 listeningDecorator 方法将 JDK 创建的 ExecutorService 装饰为 ListeningExecutorService。接下来，创建的任务，并提交 submit 到这个 ExecutorService 里。submit 方法返回 ListenableFuture 接口实例（内部实现其实就是 ListenableFutureTask 对象）。Futures 工具类的 addCallback 方法用于添加在任务执行回调的监听器。</p>
<p>类似于 JDK 的 CompletionService，实现 Guava 的 ListeningExecutorService 也是通过重写 FutureTask 的 done 方法完成的。FutureTask 对应的子类就是 ListenableFutureTask（事实上，Guava 版本 19 开始 ListenableFutureTask 类替换成立了 TrustedListenableFutureTask 类 [ <a href="https://github.com/google/guava/commit/99d2816f0a099430f28b69639e9f6f5aae388812">github</a> ]，这里暂不展开分析）。实现 ListenableFutureTask 的核心代码如下 [ <a href="https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/ListenableFutureTask.java">src</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutionList</span> <span class="variable">executionList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionList</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(Runnable listener, Executor exec)</span> &#123;</span><br><span class="line">    executionList.add(listener, exec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123;</span><br><span class="line">    executionList.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前查看 submit 方法实现<a href="#submit-src">源码</a>时，看到该方法内部会调用 newTaskFor 方法创建 FutureTask。相应的 JDK 的 AbstractExecutorService 的 <a href="http://www.cjsdn.net/Doc/JDK60/java/util/concurrent/AbstractExecutorService.html#newTaskFor(java.util.concurrent.Callable)">newTaskFor</a> 也 Guava 的 AbstractListeningExecutorService 被重写为 [ <a href="https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/AbstractListeningExecutorService.java#L45">src</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">final</span> &lt;T&gt; ListenableFutureTask&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ListenableFutureTask.create(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在线程池中运行任务的不再是 FutureTask，而变成了 ListenableFutureTask。任务完成后调用 done 方法，而 done 方法就去执行该任务关联的监听器列表，即 <code>executionList.execute()</code>。</p>
<p>再来看下 Futures 工具类的 addCallback 方法的实现 [ <a href="https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/Futures.java#L1261">src</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="keyword">void</span> <span class="title function_">addCallback</span><span class="params">(<span class="keyword">final</span> ListenableFuture&lt;V&gt; future,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> FutureCallback&lt;? <span class="built_in">super</span> V&gt; callback, Executor executor)</span> &#123;</span><br><span class="line">  Preconditions.checkNotNull(callback);</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">callbackListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> V value;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(user): (Before Guava release), validate that this</span></span><br><span class="line">        <span class="comment">// is the thing for IE.</span></span><br><span class="line">        value = getUninterruptibly(future);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        callback.onFailure(e.getCause());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        callback.onFailure(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        callback.onFailure(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      callback.onSuccess(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  future.addListener(callbackListener, executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ListenableFuture API 功能的完整介绍参见 <a href="https://github.com/google/guava/wiki/ListenableFutureExplained">ListenableFutureExplained</a>，本文不再展开。</p>
<h1 id="Fork-Join-框架">Fork/Join 框架</h1>
<p>一个大的任务可能会由多个子任务组成，比如整个任务A，由任务B 和任务C 组成，而任务B 又可以被分解为任务D 和任务E，如下图所示。任务分解组合问题，利用 ListenableFuture 的回调将子任务组合起来是一种解决办法，但还是不够优雅简洁。Java 7 引入的 Fork/Join 框架，就是以这种方式设计的。Fork/Join 框架编程的风格就是，将任务分解为多个子任务，并行执行，然后将结果组合起来，即分而治之。ExecutorService 适合解决相互独立的任务，而 Fork/Join 框架适合解决任务分解组合的情况 [ <a href="https://stackoverflow.com/q/21156599">ref</a> ]。</p>
<img width="300" alt="任务的分治" src="/media/task.png">
<p>其实整个 java.util.concurrent 包是由 <a href="http://g.oswego.edu/dl/concurrency-interest/">JSR-166</a> <a href="https://www.jcp.org/en/jsr/detail?id=166">规范</a>引入的，Fork/Join 框架就是其中的 jsr166y。JSR-166 由 <a href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a> 主导，是主要设计和代码实现者，而 jsr166y 最初源自他发表于 2000 年的论文“A Java Fork/Join Framework”（<a href="https://academic.microsoft.com/#/detail/1975579741">msa</a> <a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">pdf</a>）。</p>
<h2 id="工作窃取">工作窃取</h2>
<p>Fork/Join 框架采用工作窃取（<a href="https://en.wikipedia.org/wiki/Work_stealing">work stealing</a>）的任务调度机制 [ <a href="http://ifeve.com/a-java-fork-join-framework-3-2/">ref</a> ]：</p>
<ul>
<li>每一个工作线程维护自己的调度队列中的可运行任务。</li>
<li>队列以双端队列 deque 的形式被维护，不仅支持 LIFO（last-in-first-out 后进先出）的 push 和 pop 操作，还支持 FIFO（first-in-first-out 先进先出）的 take 操作。</li>
<li>对于一个给定的工作线程来说，任务所产生的子任务将会被放入到工作者自己的双端队列 deque 中。</li>
<li>工作线程使用 LIFO（最早的优先）的顺序，通过弹出任务来处理队列中的任务。</li>
<li>当一个工作线程的本地没有任务去运行的时候，它将使用 FIFO 的规则尝试随机的从别的工作线程中拿（“窃取 steal”）一个任务去运行。</li>
<li>当一个工作线程触及了 join 操作，如果可能的话它将处理其他任务，直到目标任务被告知已经结束（通过 isDone 方法）。所有的任务都会无阻塞的完成。</li>
<li>当一个工作线程无法再从其他线程中获取任务和失败处理的时候，它就会退出（通过 yields, sleeps, 和/或者优先级调整）并经过一段时间之后再度尝试直到所有的工作线程都被告知他们都处于空闲的状态。在这种情况下，他们都会阻塞直到其他的任务再度被上层调用。</li>
</ul>
<img width="350" alt="work stealing" src="/media/work-stealing.png">
<p>使用 LIFO 规则来处理每个工作线程的自己任务，窃取别的工作线程的任务却使用 FIFO 规则，这是一种被广泛使用的进行递归 fork/join 设计的一种调优手段。这种模式有以下两个优点：它通过窃取工作线程队列反方向的任务减少了竞争。同时，它利用了递归的分治算法越早的产生大任务这一特点。因此，更早期被窃取的任务有可能会提供一个更大的单元任务，从而使得窃取线程能够在将来进行递归分解。</p>
<p>这些规则的结果是，拥有相对细粒度的基本任务，比那些仅仅使用粗粒度划分或没有使用递归分解的任务运行更快。</p>
<h2 id="使用示例">使用示例</h2>
<p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a> 类是用于执行 ForkJoinTask 的 ExecutorService。在构造过程中，可以在构造函数中指定线程池的大小。如果使用的是默认的无参构造函数，那么会创建大小等同于可用处理器数量的线程池。ForkJoinPool 类的典型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span></span><br><span class="line">  异步，不需要等待计算结果，只是将任务提交给线程池</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span><br><span class="line">  同步，等待计算结束，并返回计算结果值</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span><br><span class="line">  异步，不需要等待计算结果，只是将任务提交给线程池</span><br></pre></td></tr></table></figure>
<p>提交到 ForkJoinPool 中的任务由 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a> 抽象类表示。ForkJoinTask 的实现子类有 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html">RecursiveAction</a> 和 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html">RecursiveTask</a>，以及 Java 8 新增的 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountedCompleter.html">CountedCompleter</a>。RecursiveAction 用于没有返回结果的任务，RecursiveTask 用于返回结果的任务。CountedCompleter 用于完成动作会触发另外一个动作的任务 [ <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">javadoc</a> ]。</p>
<p>计算斐波那契数（<a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a>）是一个经典的分而治之的问题。Doug Lea 的论文以及 RecursiveTask 的 javadoc 都以斐波那契数为例进行说明。斐波那契数定义公式为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_{n}=F_{n-1}+F_{n-2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F_{0}=0, F_{1}=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>使用 Fork/Join 框架计算斐波那契数的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">            f1.fork();</span><br><span class="line">            <span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">Fibonacci</span> <span class="variable">fib</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(<span class="number">3</span>);</span><br><span class="line">        pool.invoke(fib); <span class="comment">// 等待计算完成</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> fib.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个计算过程如下图所示：</p>
<p><img src="/media/fork-join.png" alt="fork-join"></p>
<h1 id="参考资料">参考资料</h1>
<ol>
<li>Java 并发编程实战，Goetz，2006；第6章 任务执行 <a href="https://book.douban.com/subject/10484692/">https://book.douban.com/subject/10484692/</a></li>
<li>Java并发编程的艺术，方腾飞，2015 <a href="https://book.douban.com/subject/26591326/">https://book.douban.com/subject/26591326/</a></li>
<li>ExecutorService vs ExecutorCompletionService in Java <a href="https://dzone.com/articles/executorservice-vs">https://dzone.com/articles/executorservice-vs</a></li>
<li>Java's Fork/Join vs ExecutorService - when to use which? <a href="https://stackoverflow.com/q/21156599">https://stackoverflow.com/q/21156599</a></li>
<li>Java Fork Join框架 (三) 设计 <a href="http://ifeve.com/a-java-fork-join-framework-3-2/">http://ifeve.com/a-java-fork-join-framework-3-2/</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 外部函数接口：JNI, JNA, JNR</title>
    <url>/2018/01/java-ffi/</url>
    <content><![CDATA[<h1 id="遇到的问题">遇到的问题</h1>
<p>前段时间开发的时候，遇到一个问题，就是如何用 Java 实现 <code>chdir</code>？网上搜索一番，发现了 <code>JNR-POSIX</code> 项目 [ <a href="https://stackoverflow.com/q/840190">stackoverflow</a> ]。俗话说，好记性不如烂笔头。现在将涉及到的相关知识点总结成笔记。</p>
<span id="more"></span>
<p>其实针对 Java 实现 <code>chdir</code> 问题，官方 20 多年前就存在对应的 bug，即 <a href="https://bugs.openjdk.java.net/browse/JDK-4045688">JDK-4045688</a> 'Add chdir or equivalent notion of changing working directory'。这个 bug 在 1997.04 创建，目前的状态是 <code>Won't Fix</code>（不予解决），理由大致是，若实现与操作系统一样的进程级别的 <code>chdir</code>，将影响 JVM 上的全部线程，这样引入了可变（mutable）的全局状态，这与 Java 的安全性优先原则冲突，现在添加全局可变的进程状态，已经太迟了，对不变性（immutability）的支持才是 Java 要实现的特性。</p>
<p><code>chdir</code> 是平台相关的操作系统接口，POSIX 下对应的 <a href="https://www.mankier.com/2/chdir">API</a> 为 <code>int chdir(const char *path);</code>，而 Windows 下对应的 <a href="https://msdn.microsoft.com/library/aa365530.aspx">API</a> 为 <code>BOOL WINAPI SetCurrentDirectory(_In_ LPCTSTR lpPathName);</code>，另外 Windows 下也可以使用 MSVCRT 中 <a href="https://msdn.microsoft.com/library/bf7fwze1.aspx">API</a> 的 <code>int _chdir(const char *dirname);</code>（MSVCRT 下内部实现其实就是调用 <code>SetCurrentDirectory</code> [ <a href="https://github.com/reactos/reactos/blob/releases/0.4.7/sdk/lib/crt/direct/chdir.c">reactos</a> ] ）。</p>
<p>Java 设计理念是跨平台，&quot;write once, run anywhere&quot;。很平台相关的 API，虽然各个平台都有自己的类似的实现，但存在会差异。除了多数常见功能，Java 并没有对全部操作系统接口提供完整支持，比如很多 POSIX API。除了 <code>chdir</code>，另外一个典型的例子是，在 Java 9 以前 JDK 获取进程 id 一直没有简洁的方法 [ <a href="https://stackoverflow.com/q/35842">stackoverflow</a> ]，最新发布的 Java 9 中的 <a href="http://openjdk.java.net/jeps/102">JEP 102</a>（Process API Updates）才增强了进程 API。获取进程 id 可以使用以下方式 [ <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ProcessHandle.html#pid--">javadoc</a> ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pid</span> <span class="operator">=</span> ProcessHandle.current().pid();</span><br></pre></td></tr></table></figure>
<p>相比其他语言，Pyhon 和 Ruby，对操作系统相关的接口都有更多的原生支持。Pyhon 和 Ruby 实现的相关 API 基本上都带有 POSIX 风格。比如上文提到，<code>chdir</code> 和 <code>getpid</code>，在 Pyhon 和 Ruby 下对应的 API 为：Pyhon 的 os 模块 <a href="https://docs.python.org/3.6/library/os.html#os.chdir">os.chdir(path)</a> 和 <a href="https://docs.python.org/3.6/library/os.html#os.getpid">os.getpid()</a>；Ruby 的 Dir 类的 <a href="https://ruby-doc.org/core-2.2.0/Dir.html#method-c-chdir">Dir.chdir( [ string] )</a> 类方法和 Process 类的 <a href="https://ruby-doc.org/core-2.2.0/Process.html#method-c-pid">Process.pid</a> 类属性。Python 解释器的 <code>chdir</code> 对应源码为 <a href="https://github.com/python/cpython/blob/v3.6.0/Modules/posixmodule.c#L2611">posixmodule.c#L2611</a>，Ruby 解释器的 <code>chdir</code> 对应源码为 <a href="https://github.com/ruby/ruby/blob/v2_2_0/dir.c#L848">dir.c#L848</a> 和 <a href="https://github.com/ruby/ruby/blob/v2_2_0/win32/win32.c#L6741">win32.c#L6741</a>。</p>
<h1 id="JNI-实现-getpid">JNI 实现 getpid</h1>
<p>Java 下要想实现本地方法调用，需要通过 <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">JNI</a>。关于 JNI 的介绍，可以参阅“Java核心技术，卷II：高级特性，第9版2013”的“第12章 本地方法”，或者读当年 Sun 公司 JNI 设计者 Sheng Liang（梁胜）写的“Java Native Interface: Programmer's Guide and Specification”。本文只给出实现 <code>getpid</code> 的一个简单示例。</p>
<p>首先使用 Maven 创建一个简单的脚手架：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate     \</span><br><span class="line">  -DgroupId=com.test       \</span><br><span class="line">  -DartifactId=jni-jnr     \</span><br><span class="line">  -DpackageName=com.test   \</span><br><span class="line">  -DinteractiveMode=<span class="literal">false</span>  </span><br></pre></td></tr></table></figure>
<p>在 <code>com.test</code> 包下添加 <code>GetPidJni</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPidJni</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">getpid</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;getpidjni&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>javac</code> 编译代码 <code>GetPidJNI.java</code>，然后用 <code>javah</code> 生成 JNI 头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir -p target/classes</span><br><span class="line">$ javac src/main/java/com/test/GetPidJni.java -d &quot;target/classes&quot;</span><br><span class="line">$ javah -cp &quot;target/classes&quot; com.test.GetPidJni</span><br></pre></td></tr></table></figure>
<p>生成的 JNI 头文件 <code>com_test_GetPidJni.h</code>，内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_test_GetPidJni */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_com_test_GetPidJni</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_com_test_GetPidJni</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_test_GetPidJni</span></span><br><span class="line"><span class="comment"> * Method:    getpid</span></span><br><span class="line"><span class="comment"> * Signature: ()J</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jlong JNICALL <span class="title">Java_com_test_GetPidJni_getpid</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jclass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>现在有了头文件声明，但还没有实现，手动敲入 <code>com_test_GetPidJni.c</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_test_GetPidJni.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jlong JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_test_GetPidJni_getpid</span> <span class="params">(JNIEnv * env, jclass c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getpid</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译 <code>com_test_GetPidJni.c</code>，生成 <code>libgetpidjni.dylib</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gcc -I <span class="variable">$JAVA_HOME</span>/include -I <span class="variable">$JAVA_HOME</span>/include/darwin -dynamiclib -o libgetpidjni.dylib com_test_GetPidJni.c</span><br></pre></td></tr></table></figure>
<p>生成的 <code>libgetpidjni.dylib</code>，就是 <code>GetPidJni.java</code> 代码中的 <code>System.loadLibrary(&quot;getpidjni&quot;);</code>，需要加载的 lib。</p>
<p>现在运行 <code>GetPidJni</code> 类，就能正确获取 pid：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java -Djava.library.path=`pwd` -cp &quot;target/classes&quot; com.test.GetPidJni</span><br></pre></td></tr></table></figure>
<p>JNI 的问题是，<strong>胶水代码</strong>（黏合 Java 和 C 库的代码）需要程序员手动书写，对不熟悉 C/C++ 的同学是很大的挑战。</p>
<h1 id="JNA-实现-getpid">JNA 实现 getpid</h1>
<p>JNA（Java Native Access, <a href="https://en.wikipedia.org/wiki/Java_Native_Access">wiki</a>, <a href="https://github.com/java-native-access/jna">github</a>, <a href="https://javadoc.io/doc/net.java.dev.jna/jna">javadoc</a>, <a href="https://mvnrepository.com/artifact/net.java.dev.jna/jna">mvn</a>），提供了相对 JNI 更加简洁的调用本地方法的方式。除了 Java 代码外，不再需要额外的胶水代码。这个项目最早可以追溯到 Sun 公司 JNI 设计者 Sheng Liang 在 1999 年 JavaOne 上的分享。2006 年 11月，Todd Fast (也来自 Sun 公司) 首次将 JNA 发布到 <a href="http://dev.java.net">dev.java.net</a> 上。Todd Fast 在发布时提到，自己在这个项目上已经断断续续开发并完善了 6-7 年时间，项目刚刚在 JDK 5 上重构和重设计过，还可能有很多缺陷或缺点，希望其他人能浏览代码并参与进来。Timothy Wall 在 2007 年 2 月重启了这项目，引入了很多重要功能，添加了 Linux 和 OSX 支持（原本只在 Win32 上测试过），加强了 lib 的可用性（而非仅仅基本功能可用）[ <a href="https://web.archive.org/web/20110221190148/http://jna.java.net:80/#history">ref</a> ]。</p>
<p>看下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPidJNA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LibC</span> <span class="keyword">extends</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="title function_">getpid</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LibC</span> <span class="variable">libc</span> <span class="operator">=</span> Native.loadLibrary(<span class="string">&quot;c&quot;</span>, LibC.class);</span><br><span class="line">        System.out.println(libc.getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JNR-实现-getpid">JNR 实现 getpid</h1>
<p>最初，JRuby 的核心开发者 Charles Nutter 在实现 Ruby 的 POSIX 集成时就使用了 JNA [ <a href="https://www.infoq.com/news/2007/09/jna-jruby/">ref</a> ]。但过了一段时候后，开始开发 JNR（Java Native Runtime, <a href="https://github.com/jnr">github</a>, <a href="http://mvnrepository.com/artifact/com.github.jnr">mvn</a>） 替代 JNA。Charles Nutter 在介绍 JNR 的 <a href="http://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf">slides</a> 中阐述了原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Why Not JNA?</span><br><span class="line">- Preprocessor constants?</span><br><span class="line">- Standard API sets out of the box</span><br><span class="line">- C callbacks?</span><br><span class="line">- Performance?!?</span><br></pre></td></tr></table></figure>
<p>即，(1) 预处理器的常量支持（通过 <a href="https://github.com/jnr/jnr-constants">jnr-constants</a> 解决）；(2) 开箱即用的标准 API（作者实现了 <a href="https://github.com/jnr/jnr-posix">jnr-posix</a>, <a href="https://github.com/jnr/jnr-x86asm">jnr-x86asm</a>, <a href="https://github.com/jnr/jnr-enxio">jnr-enxio</a>, <a href="https://github.com/jnr/jnr-unixsocket">jnr-unixsocket</a>）；(3) C 回调 callback 支持；(4) 性能（提升 8-10 倍）。</p>
<img width="600" alt="JNR 各个模块的层次结构" title="JNR 各个模块的层次结构" src="https://static.nullwy.me/jnr-layered-runtime.png">
<p>使用 JNR-FFI（<a href="https://github.com/jnr/jnr-ffi">github</a>, <a href="https://mvnrepository.com/artifact/com.github.jnr/jnr-ffi">mvn</a>）实现 <code>getpid</code>，示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jnr.ffi.LibraryLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPidJnr</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LibC</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="title function_">getpid</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LibC</span> <span class="variable">libc</span> <span class="operator">=</span> LibraryLoader.create(LibC.class).load(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(libc.getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 JNR-POSIX（<a href="https://github.com/jnr/jnr-posix">github</a>, <a href="https://mvnrepository.com/artifact/com.github.jnr/jnr-posix">mvn</a>）实现 <code>chdir</code> 和 <code>getpid</code>，示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jnr.posix.POSIX;</span><br><span class="line"><span class="keyword">import</span> jnr.posix.POSIXFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPidJnrPosix</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">POSIX</span> <span class="variable">posix</span> <span class="operator">=</span> POSIXFactory.getPOSIX();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(posix.getcwd());</span><br><span class="line">        posix.chdir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        System.out.println(posix.getcwd());</span><br><span class="line">        System.out.println(posix.getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JMH-性能比较">JMH 性能比较</h1>
<p>性能测试代码为 <code>BenchmarkFFI.java</code>（<a href="https://github.com/yulewei/java-ffi-demo/blob/master/src/main/java/com/test/BenchmarkFFI.java">github</a>），测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># JMH version: 1.19</span><br><span class="line"># VM version: JDK 1.8.0_144, VM 25.144-b01</span><br><span class="line"></span><br><span class="line">Benchmark                          Mode  Cnt      Score      Error   Units</span><br><span class="line">BenchmarkFFI.testGetPidJna        thrpt   10   8225.209 ±  206.829  ops/ms</span><br><span class="line">BenchmarkFFI.testGetPidJnaDirect  thrpt   10  10257.505 ±  736.135  ops/ms</span><br><span class="line">BenchmarkFFI.testGetPidJni        thrpt   10  77852.899 ± 3167.101  ops/ms</span><br><span class="line">BenchmarkFFI.testGetPidJnr        thrpt   10  58261.657 ± 5187.550  ops/ms</span><br></pre></td></tr></table></figure>
<p><strong>即：JNI &gt; JNR &gt; JNA (Direct Mapping) &gt; JNA (Interface Mapping)</strong>。相对 JNI 的实现性能，其他三种方式，从大到小的性能百分比依次为：74.8% (JNR),  13.2% (JnaDirect),  10.6% (JNA)。在博主电脑上测试，JNR 相比 JNA 将近快了 6-7 倍（JNR 作者 Charles Nutter 针对 <code>getpid</code> 的测试结果是 JNR 比 JNA 快 8-10 倍 [ <a href="https://twitter.com/headius/status/360988359927148545">twitter</a> <a href="http://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf">slides</a> ]）。</p>
<h1 id="实现原理">实现原理</h1>
<h2 id="JNA-源码简析">JNA 源码简析</h2>
<p>先来看下 JNA，JNA 官方文档 <a href="https://github.com/java-native-access/jna/blob/master/www/FunctionalDescription.md">FunctionalDescription.md</a>，对其实现原理有很好的阐述。这里将从源码角度分析实现的核心逻辑。</p>
<p>回顾下代码，我们现实定义了接口 <code>LibC</code>，然后通过 <code>Native.loadLibrary(&quot;c&quot;, LibC.class)</code> 获取了接口实现。这一步是怎么做到的呢？翻下源码 <a href="https://github.com/java-native-access/jna/blob/4.5.X/src/com/sun/jna/Native.java#L547">Native.java#L547</a> 就知道，其实是通过**动态代理（dynamic proxy）**实现的。使用动态代理需要实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/InvocationHandler.html">InvocationHandler</a> 接口，这个接口的实现在 JNA 源码中是类 com.sun.jna.Library.<a href="https://github.com/java-native-access/jna/blob/4.5.X/src/com/sun/jna/Library.java#L115">Handler</a>。示例中的 <code>LibC</code> 接口定义的全部方法，将全部分派到 Handler 的 <a href="https://github.com/java-native-access/jna/blob/4.5.X/src/com/sun/jna/Library.java#L195">invoke</a> 方法下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>
<p>然后根据返回参数的不同，分派到 Native 类的，invokeXxx 本地方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call the native function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function  Present to prevent the GC to collect the Function object</span></span><br><span class="line"><span class="comment"> *                  prematurely</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fp        function pointer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callFlags calling convention to be used</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args      Arguments to pass to the native function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The value returned by the target native function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">invokeInt</span><span class="params">(Function function, <span class="type">long</span> fp, <span class="type">int</span> callFlags, Object[] args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">invokeLong</span><span class="params">(Function function, <span class="type">long</span> fp, <span class="type">int</span> callFlags, Object[] args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invokeObject</span><span class="params">(Function function, <span class="type">long</span> fp, <span class="type">int</span> callFlags, Object[] args)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>比如，<code>long getpid()</code> 会被分派到 invokeLong，而 <code>int chmod(String filename, int mode)</code> 会被分派到 <code>invokeInt</code>。invokeXxx 本地方法参数：</p>
<ul>
<li>参数 <code>Function function</code>，记录了 lib 信息、函数名称、函数指针地址、调用惯例等元信息；</li>
<li>参数 <code>long fp</code>，即函数指针地址，函数指针地址通过 Native#<a href="https://github.com/java-native-access/jna/blob/4.5.X/src/com/sun/jna/Native.java#L2060">findSymbol()</a>获得（底层是 Linux API <a href="https://www.mankier.com/3/dlsym">dlsym</a> 或 Windows API <a href="https://msdn.microsoft.com/en-us/library/ms683212.aspx">GetProcAddress</a> ）。</li>
<li>参数 <code>int callFlags</code>，即调用约定，对应 cdecl 或 stdcall。</li>
<li>参数 <code>int callFlags</code>，即函数入参，若无参数，args 大小为 0，若有多个参数，原本的入参被从左到右依次保存到 args 数组中。</li>
</ul>
<p>再来看下 <code>invokeXxx</code> 本地方法的实现 <a href="https://github.com/java-native-access/jna/blob/4.5.X/native/dispatch.c#L2122">dispatch.c#L2122</a>（<code>invokeInt</code> 或 <code>invokeLong</code> 实现源码类似）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_sun_jna_Native</span></span><br><span class="line"><span class="comment"> * Method:    invokeInt</span></span><br><span class="line"><span class="comment"> * Signature: (Lcom/sun/jna/Function;JI[Ljava/lang/Object;)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_com_sun_jna_Native_invokeInt</span><span class="params">(JNIEnv *env, jclass UNUSED(cls), </span></span><br><span class="line"><span class="params">                                  jobject UNUSED(function), jlong fp, jint callconv,</span></span><br><span class="line"><span class="params">                                  jobjectArray arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ffi_arg result;</span><br><span class="line">    dispatch(env, L2A(fp), callconv, arr, &amp;ffi_type_sint32, &amp;result);</span><br><span class="line">    <span class="keyword">return</span> (jint)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，全部 <code>invokeXxx</code> 本地方法统一被分派到 <code>dispatch</code> 函数 <a href="https://github.com/java-native-access/jna/blob/4.5.X/native/dispatch.c#L439">dispatch.c#L439</a>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch</span><span class="params">(JNIEnv *env, <span class="type">void</span>* func, jint flags, jobjectArray args,</span></span><br><span class="line"><span class="params">ffi_type *return_type, <span class="type">void</span> *presult)</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>dispatch</code> 函数是全部逻辑的核心，实现最终的本地函数调用。</p>
<p>我们知道，发起函数调用，需要构造一个<strong>栈帧</strong>（<a href="https://en.wikipedia.org/wiki/Call_stack#Structure">stack frame</a>）。构造栈帧，涉及到参数压栈次序（参数从左到右压入还是从右到左压入）和清理栈帧（调用者清理还是被调用者清理）等实现细节问题。不同的编译器在不同的 CPU 架构下有不同的选择。构造栈帧的具体实现细节的选择，被称为<strong>调用惯例</strong>（<a href="https://en.wikipedia.org/wiki/X86_calling_conventions">calling convention</a>）。按照调用惯例构造整个栈帧，这个过程由编译器在<strong>编译阶段</strong>完成的。比如要想发起 <code>sum(2, 3)</code> 这个函数调用，编译器可能会生成如下等价汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 调用者清理堆栈（caller clean-up），参数从右到左压入栈</span><br><span class="line">push 3</span><br><span class="line">push 2</span><br><span class="line">call _sum      ; 将返回地址压入栈, 同时 sum 的地址装入 eip</span><br><span class="line">add  esp, 8    ; 清理堆栈, 两个参数占用 8 字节</span><br></pre></td></tr></table></figure>
<p><code>dispatch</code> 函数是，需要调用的函数指针地址、输入参数和返回参数，全部是<strong>运行时确定</strong>。要想完成这个函数调用逻辑，就要运行时构造栈帧，生成参数压栈和清理堆栈的工作。JNA 3.0 之前，实现运行时构造栈帧的逻辑的对应代码 <a href="https://github.com/java-native-access/jna/blob/2.5/jnalib/native/dispatch_i386.c">dispatch_i386.c</a>、<a href="https://github.com/java-native-access/jna/blob/2.5/jnalib/native/dispatch_ppc.c">dispatch_ppc.c</a> 和 <a href="https://github.com/java-native-access/jna/blob/2.5/jnalib/native/dispatch_sparc.s">dispatch_sparc.s</a>，分别实现 Intel x86、PowerPC 和 Sparc 三种 CPU 架构。</p>
<p>运行时函数调用，这个问题其实是一个一般性的通用问题。早在 1996 年 10 月，Cygnus Solutions 的工程师 Anthony Green 等人就开发了 libffi（<a href="https://sourceware.org/libffi/">home</a>, <a href="https://en.wikipedia.org/wiki/Libffi">wiki</a>, <a href="https://github.com/libffi/libffi">github</a>, <a href="http://www.chiark.greenend.org.uk/doc/libffi-dev/html/index.html">doc</a>），解决的正是这个问题。目前，libffi 几乎支持全部常见的 CPU 架构。于是，从 <a href="https://github.com/java-native-access/jna/tree/3.0/jnalib/native">JNA 3.0</a> 开始，摒弃了原先手动构造栈帧的做法，把 libffi 集成进了 JNA。</p>
<p>直接映射（Direct Mapping）<br>
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives</a><br>
<a href="http://www.chiark.greenend.org.uk/doc/libffi-dev/html/The-Closure-API.html">http://www.chiark.greenend.org.uk/doc/libffi-dev/html/The-Closure-API.html</a></p>
<h2 id="JNR-源码简析">JNR 源码简析</h2>
<p>JNR 底层同样也是依赖 libffi，参见 <a href="https://github.com/jnr/jffi">jffi</a>。但 JNR 相比 JNA 性能更好，做了很有优化。比较重要的点是，JNA 使用动态代理生成实现类，而 JNR 使用 ASM 字节码操作库生成直接实现类，去除了每次调用本地方法时额外的动态代理的逻辑。使用 ASM 生成实现类，对应的代码为 <a href="https://github.com/jnr/jnr-ffi/blob/master/src/main/java/jnr/ffi/provider/jffi/AsmLibraryLoader.java">AsmLibraryLoader.java</a>。其他细节，限于文档不全，本人精力有限，不再展开。</p>
<h1 id="Java-9-的-getpid-实现">Java 9 的 getpid 实现</h1>
<p>Java 9 以前 JDK 获取进程 id 没有简洁的方法，最新发布的 Java 9 中的 <a href="http://openjdk.java.net/jeps/102">JEP 102</a>（Process API Updates）增强了进程 API。进程 id 可以使用以下方式 [ <a href="http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#pid--">javadoc</a> ]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pid</span> <span class="operator">=</span> ProcessHandle.current().pid();</span><br></pre></td></tr></table></figure>
<p>翻阅实现源码，可以看到对应的实现就是 JNI 调用：</p>
<p>jdk/src/java.base/share/classes/java/lang/ProcessHandleImpl [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/ProcessHandleImpl.java">src</a> ]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the pid of the current process.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the pid of the  current process</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">getCurrentPid0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>*nix 平台下实现为：</p>
<p>jdk/src/java.base/unix/native/libjava/ProcessHandleImpl_unix.c [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/unix/native/libjava/ProcessHandleImpl_unix.c#L296">src</a> ]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     java_lang_ProcessHandleImpl</span></span><br><span class="line"><span class="comment"> * Method:    getCurrentPid0</span></span><br><span class="line"><span class="comment"> * Signature: ()J</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jlong JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_lang_ProcessHandleImpl_getCurrentPid0</span><span class="params">(JNIEnv *env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="keyword">return</span> (jlong) pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Windows 平台下实现为：</p>
<p>jdk/src/java.base/windows/native/libjava/ProcessHandleImpl_win.c [ <a href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/windows/native/libjava/ProcessHandleImpl_win.c#L137">src</a> ]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Returns the pid of the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Class:     java_lang_ProcessHandleImpl</span></span><br><span class="line"><span class="comment"> * Method:    getCurrentPid0</span></span><br><span class="line"><span class="comment"> * Signature: ()J</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jlong JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_lang_ProcessHandleImpl_getCurrentPid0</span><span class="params">(JNIEnv *env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    DWORD  pid = <span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">    <span class="keyword">return</span> (jlong)pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ol>
<li>Changing the current working directory in Java? <a href="https://stackoverflow.com/q/840190">https://stackoverflow.com/q/840190</a></li>
<li>How can a Java program get its own process ID? <a href="http://stackoverflow.com/q/35842">http://stackoverflow.com/q/35842</a></li>
<li>Java核心技术，卷II：高级特性，第9版2013：第12章 本地方法，<a href="https://book.douban.com/subject/25841326/">豆瓣</a></li>
<li>Java Native Interface: Programmer's Guide and Specification, <em>Sheng Liang</em> (<a href="https://en.wikipedia.org/wiki/Sheng_Liang">wiki</a>，<a href="https://www.linkedin.com/in/shengliang/">linkedin</a>，<a href="https://academic.microsoft.com/#/detail/2131857791">msa</a>), 1999，<a href="https://book.douban.com/subject/3162962/">豆瓣</a>：作者梁胜，中国科技大学少年班83级，并拥有耶鲁大学计算机博士学位（1990-1996），目前 Rancher Labs 创始人兼 CEO [ <a href="https://www.toutiao.com/a6283841554134401282/">ref</a> ]</li>
<li>2013-07 Charles Nutter: Java Native Runtime <a href="http://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf">http://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf</a></li>
<li>JEP 191: Foreign Function Interface <a href="http://openjdk.java.net/jeps/191">http://openjdk.java.net/jeps/191</a> 作者是Charles Nutter</li>
<li>2014-03 Java 外部函数接口 <a href="http://www.infoq.com/cn/news/2014/03/java-foreign-function-interface">http://www.infoq.com/cn/news/2014/03/java-foreign-function-interface</a></li>
<li>2005-08 Brian Goetz：用动态代理进行修饰 <a href="https://www.ibm.com/developerworks/cn/java/j-jtp08305.html">https://www.ibm.com/developerworks/cn/java/j-jtp08305.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JNI</tag>
        <tag>JNA</tag>
        <tag>JNR</tag>
        <tag>FFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 运行时获取方法参数名</title>
    <url>/2017/05/java-method-parameter/</url>
    <content><![CDATA[<p>本文整理 Java 运行时获取方法参数名的两种方法，Java 8 的最新的方法和 Java 8 之前的方法。</p>
<h1 id="Java-8-的新特性">Java 8 的新特性</h1>
<p>翻阅 Java 8 的<a href="http://openjdk.java.net/projects/jdk8/features">新特性</a>，可以看到有这么一条“<a href="http://openjdk.java.net/jeps/118">JEP 118</a>: Access to Parameter Names at Runtime”。这个特性就是为了能运行时获取参数名新加的。这个 <a href="https://en.wikipedia.org/wiki/JDK_Enhancement_Proposal">JEP</a> 只是功能增强的提案，并没有最终实现的 JDK 相关的 API 的介绍。查看“<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/reflection/enhancements.html">Enhancements to the Reflection API</a>” 会看到如下介绍：</p>
<span id="more"></span>
<blockquote>
<p><strong>Enhancements in Java SE 8</strong><br>
Method Parameter Reflection: You can obtain the names of the formal parameters of any method or constructor with the method <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Executable.html#getParameters--">java.lang.reflect.Executable.getParameters</a>. However, <code>.class</code> files do not store formal parameter names by default. To store formal parameter names in a particular <code>.class</code> file, and thus enable the Reflection API to retrieve formal parameter names, compile the source file with the <code>-parameters</code> option of the <code>javac</code> compiler.</p>
</blockquote>
<style>
blockquote {
    font-size: 12px
    font-family: Monaco,Menlo,Consolas,monospace;
}
</style>
<p><code>javac</code> 文档中关于 <code>-parameters</code> 的介绍如下 [ <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/javadoc.html">doc</a> <a href="https://www.mankier.com/1/javac">man</a> ]：</p>
<blockquote>
<p><strong>-parameters</strong><br>
Stores formal parameter names of constructors and methods in the generated class file so that the method <code>java.lang.reflect.Executable.getParameters</code> from the Reflection API can retrieve them.</p>
</blockquote>
<p>现在试验下这个特性。有如下两个文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> TestClass.class.getDeclaredMethod(<span class="string">&quot;sum&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">            System.out.println(parameter.getType().getName() + <span class="string">&quot; &quot;</span> + parameter.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先试试 <code>javac</code> 不加 <code>-parameters</code> 编译，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -d <span class="string">&quot;target/classes&quot;</span> src/main/java/com/test/*.java</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -<span class="built_in">cp</span> <span class="string">&quot;target/classes&quot;</span> com.test.Java8Main</span></span><br><span class="line">int arg0</span><br><span class="line">int arg1</span><br></pre></td></tr></table></figure>
<p>加上 <code>-parameters</code> 后，运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -d <span class="string">&quot;target/classes&quot;</span> -parameters src/main/java/com/test/*.java</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -<span class="built_in">cp</span> <span class="string">&quot;target/classes&quot;</span> com.test.Java8Main</span></span><br><span class="line">int num1</span><br><span class="line">int num2</span><br></pre></td></tr></table></figure>
<p>可以看到，加上 <code>-parameters</code> 后，正确获得了参数名。实际开发中，很少直接用命令行编译 Java 代码，项目一般都会用 maven 管理。在 maven 下，只需修改 pom 文件的 <code>maven-compiler-plugin</code> 插件配置即可，就是加上了 <code>compilerArgs</code> 节点 [ <a href="https://maven.apache.org/plugins/maven-compiler-plugin/examples/pass-compiler-arguments.html">doc</a> ]，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span>&gt;</span>-parameters<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实现原理">实现原理</h2>
<p>“Enhancements in Java SE 8”提到，参数名信息回存储在 class 文件中。现在试试用 <code>javap</code>（<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/javap.html"> doc </a> <a href="https://www.mankier.com/1/javap">man</a>）命令反编译生成的 class 文件。反编译 class 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javap -v -<span class="built_in">cp</span> <span class="string">&quot;target/classes&quot;</span> com.test.TestClass</span></span><br><span class="line">Classfile /Users/yulewei/IdeaProjects/hellojava/target/classes/com/test/TestClass.class</span><br><span class="line">  Last modified 2017-5-2; size 305 bytes</span><br><span class="line">  MD5 checksum 24b99fec7f3062f5de1c3ca4270a1d36</span><br><span class="line">  Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class com.test.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#3.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Class              <span class="comment">#16            // com/test/TestClass</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Class              <span class="comment">#17            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               <span class="built_in">sum</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               (II)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               MethodParameters</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               num1</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               num2</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               TestClass.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = NameAndType        <span class="comment">#4:#5          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               com/test/TestClass</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public com.test.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public int sum(int, int);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=3</span><br><span class="line">         0: iload_1</span><br><span class="line">         1: iload_2</span><br><span class="line">         2: iadd</span><br><span class="line">         3: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      num1</span><br><span class="line">      num2</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;TestClass.java&quot;</span><br></pre></td></tr></table></figure>
<p>在结尾的 <code>MethodParameters</code> 属性就是，实现运行时获取方法参数的核心。这个属性是 Java 8 的 class 文件新加的，具体介绍可以参考官方“Java 虚拟机官方”文档的介绍，“4.7.24. The MethodParameters Attribute”，<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.24">doc</a>。</p>
<h1 id="class-文件中的调试信息">class 文件中的调试信息</h1>
<p>上文介绍了 Java 8 通过新增的反射 API 运行时获取方法参数名。那么在 Java 8 之前，有没有办法呢？或者在编译时没有开启 <code>-parameters</code> 参数，又如何动态获取方法参数名呢？其实 class 文件中保存的调试信息就可以包含方法参数名。</p>
<p><code>javac</code> 的 <code>-g</code> 选项可以在 class 文件中生成调试信息，官方文档介绍如下 [ <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/javac.html#BHCDIFEE">doc</a> <a href="https://www.mankier.com/1/javac#-g">man</a> ]：</p>
<blockquote>
<p><strong>-g</strong><br>
Generates all debugging information, including local variables. By default, only line number and source file information is generated.<br>
<strong>-g:none</strong><br>
Does not generate any debugging information.<br>
<strong>-g:[keyword list]</strong><br>
Generates only some kinds of debugging information, specified by a comma separated list of keywords. Valid keywords are:<br>
   <strong>source</strong><br>
     Source file debugging information.<br>
   <strong>lines</strong><br>
     Line number debugging information.<br>
   <strong>vars</strong><br>
     Local variable debugging information.</p>
</blockquote>
<p>可以看到默认是包含源代码信息和行号信息的。现在试验下不生成调试信息的情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -d <span class="string">&quot;target/classes&quot;</span> src/main/java/com/test/*.java -g:none</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javap -v -<span class="built_in">cp</span> <span class="string">&quot;target/classes&quot;</span> com.test.TestClass</span></span><br><span class="line">Classfile /Users/yulewei/IdeaProjects/hellojava/target/classes/com/test/TestClass.class</span><br><span class="line">  Last modified 2017-5-2; size 177 bytes</span><br><span class="line">  MD5 checksum 559f5448154e4d7dd089f8155d8d0f55</span><br><span class="line">public class com.test.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#3.#9          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Class              <span class="comment">#10            // com/test/TestClass</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Class              <span class="comment">#11            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               <span class="built_in">sum</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               (II)I</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = NameAndType        <span class="comment">#4:#5          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               com/test/TestClass</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public com.test.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line"></span><br><span class="line">  public int sum(int, int);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=3</span><br><span class="line">         0: iload_1</span><br><span class="line">         1: iload_2</span><br><span class="line">         2: iadd</span><br><span class="line">         3: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比上文的反编译结果，可以看到，输出结果中的 <code>Compiled from &quot;TestClass.java&quot;</code> 没了，<code>Constant pool</code> 中也不再有 <code>LineNumberTable</code> 和 <code>SourceFile</code>，<code>code</code> 属性里的 <code>LocalVariableTable</code> 属性也没了（当然，因为编译时没加 <code>-parameters</code> 参数，<code>MethodParameters</code> 属性自然也没了）。若选择不生成这两个属性，对程序运行产生的最主要的影响就是，当抛出异常时，堆栈中将不会显示出错代码所属的文件名和出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -d <span class="string">&quot;target/classes&quot;</span> src/main/java/com/test/*.java -g:vars</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javap -v -<span class="built_in">cp</span> <span class="string">&quot;target/classes&quot;</span> com.test.TestClass</span></span><br><span class="line">Classfile /Users/yulewei/IdeaProjects/hellojava/target/classes/com/test/TestClass.class</span><br><span class="line">  Last modified 2017-5-2; size 302 bytes</span><br><span class="line">  MD5 checksum d430f817e0e2cfafc9095279c67aaa72</span><br><span class="line">public class com.test.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#3.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Class              <span class="comment">#16            // com/test/TestClass</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Class              <span class="comment">#17            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               Lcom/test/TestClass;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               <span class="built_in">sum</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               (II)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               num1</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Utf8               I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               num2</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = NameAndType        <span class="comment">#4:#5          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               com/test/TestClass</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public com.test.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/test/TestClass;</span><br><span class="line"></span><br><span class="line">  public int sum(int, int);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=3</span><br><span class="line">         0: iload_1</span><br><span class="line">         1: iload_2</span><br><span class="line">         2: iadd</span><br><span class="line">         3: ireturn</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       4     0  this   Lcom/test/TestClass;</span><br><span class="line">            0       4     1  num1   I</span><br><span class="line">            0       4     2  num2   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>code</code> 属性里的出现了 <code>LocalVariableTable</code> 属性，这个属性保存的就是方法参数和方法内的本地变量。在演示代码的 <code>sum</code> 方法中没有定义本地变量，若存在的话，也将会保存在 <code>LocalVariableTable</code> 中。</p>
<p><code>javap</code> 的 <code>-v</code> 选项会输出全部反编译信息，若只想看行号和本地变量信息，改用 <code>-l</code> 即可。输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javap -l -<span class="built_in">cp</span> <span class="string">&quot;target/classes&quot;</span> com.test.TestClass</span></span><br><span class="line">public class com.test.TestClass &#123;</span><br><span class="line">  public com.test.TestClass();</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       5     0  this   Lcom/test/TestClass;</span><br><span class="line"></span><br><span class="line">  public int sum(int, int);</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       4     0  this   Lcom/test/TestClass;</span><br><span class="line">          0       4     1  num1   I</span><br><span class="line">          0       4     2  num2   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若要全部生成全部提示信息，编译参数需要改为 <code>-g:source,lines,vars</code>。一般在 IDE 下调试代码都需要调试信息，所以这三个参数默认都会开启。IDEA 下的 javac 默认参数设置，如图：</p>
<p><img src="https://static.nullwy.me/2017-05-06-Jietu20170506-174601.png" alt="IDEA 默认的 javac 设置"></p>
<p>若使用 maven，maven 的默认的编译插件 <code>maven-compiler-plugin</code> 也会<strong>默认开启</strong>这三个参数 [<a href="https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug">doc</a>]，经实际验证也包括了<code>LocalVariableTable</code>。</p>
<p>同样的，gradle <strong>默认也会包含</strong>调试信息 [ <a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:debug">doc</a> ]。</p>
<h1 id="代码如何实现">代码如何实现</h1>
<p>上文中讲了 class 文件中的调试信息中 <code>LocalVariableTable</code> 属性里就包含方法名参数，这就是运行时获取方法参数名的方法。读取这个属性，JDK 并没有提供 API，只能借助第三方库解析 class 文件实现。</p>
<p>要解析 class 文件典型的工具库有 ObjectWeb 的 ASM（<a href="https://en.wikipedia.org/wiki/ObjectWeb_ASM">wiki</a>，<a href="http://asm.ow2.org/">home</a>，<a href="http://mvnrepository.com/artifact/org.ow2.asm/asm">mvn</a>，<a href="https://javadoc.io/doc/org.ow2.asm/asm">javadoc</a>）、Apache 的 Commons BCEL（<a href="https://en.wikipedia.org/wiki/Byte_Code_Engineering_Library">wiki</a>，<a href="http://commons.apache.org/proper/commons-bcel/">home</a>，<a href="http://mvnrepository.com/artifact/org.apache.bcel/bcel">mvn</a>，<a href="http://commons.apache.org/proper/commons-bcel/apidocs/">javadoc</a>）、 日本教授开发的 Javassist（<a href="https://en.wikipedia.org/wiki/Javassist">wiki</a>，<a href="https://github.com/jboss-javassist/javassist">github</a>，<a href="http://mvnrepository.com/artifact/org.javassist/javassist">mvn</a>，<a href="https://javadoc.io/doc/org.javassist/javassist">javadoc</a>）等。其中 ASM 使用最广，使用 ASM 的知名开源项目有，AspectJ, CGLIB, Clojure, Groovy, JRuby, Jython, TopLink等等 [ <a href="http://asm.ow2.org/users.html">ref</a> ]。当然使用 BCEL 的项目也很多 [ <a href="http://commons.apache.org/proper/commons-bcel/projects.html">ref</a> ]。ASM 相对其他库的 jar 更小，运行速度更快 [ <a href="https://static.javadoc.io/org.ow2.asm/asm/5.2/org/objectweb/asm/package-summary.html#package.description">javadoc</a> ]。目前 asm-5.0.1.jar 文件大小 53 KB，BCEL 5.2 版本文件大小 520 KB，javassist-3.20.0-GA.jar 文件大小 751 KB。jar 包文件小，自然意味着代码量更少，提供的功能自然也少了。</p>
<h2 id="BCEL">BCEL</h2>
<p>先来看看用 BCEL 获取方法参数名的写法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.apache.bcel.Repository;</span><br><span class="line"><span class="keyword">import</span> org.apache.bcel.classfile.JavaClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.bcel.classfile.LocalVariable;</span><br><span class="line"><span class="keyword">import</span> org.apache.bcel.classfile.LocalVariableTable;</span><br><span class="line"><span class="keyword">import</span> org.apache.bcel.classfile.Method;</span><br><span class="line"><span class="keyword">import</span> org.apache.bcel.generic.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BcelMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        java.lang.reflect.<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> TestClass.class.getDeclaredMethod(<span class="string">&quot;sum&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> Repository.lookupClass(<span class="string">&quot;com.test.TestClass&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">bcelMethod</span> <span class="operator">=</span> clazz.getMethod(m);</span><br><span class="line">        <span class="type">LocalVariableTable</span> <span class="variable">lvt</span> <span class="operator">=</span> bcelMethod.getLocalVariableTable();</span><br><span class="line">        <span class="keyword">for</span> (LocalVariable lv : lvt.getLocalVariableTable()) &#123;</span><br><span class="line">            System.out.println(lv.getName() + <span class="string">&quot;  &quot;</span> + lv.getSignature() + <span class="string">&quot;  &quot;</span> + Type.getReturnType(lv.getSignature()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">this  Lcom/test/TestClass;  com.test.TestClass</span><br><span class="line">num1  I  int</span><br><span class="line">num2  I  int</span><br></pre></td></tr></table></figure>
<h2 id="ASM">ASM</h2>
<p>ASM 的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsmMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassReader</span> <span class="variable">classReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="string">&quot;com.test.TestClass&quot;</span>);</span><br><span class="line">        classReader.accept(<span class="keyword">new</span> <span class="title class_">ParameterNameDiscoveringVisitor</span>(<span class="string">&quot;sum&quot;</span>, <span class="string">&quot;(II)I&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParameterNameDiscoveringVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String methodName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String methodDesc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ParameterNameDiscoveringVisitor</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(Opcodes.ASM5);</span><br><span class="line">            <span class="built_in">this</span>.methodName = name;</span><br><span class="line">            <span class="built_in">this</span>.methodDesc = desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="built_in">this</span>.methodName) &amp;&amp; desc.equals(methodDesc))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalVariableTableVisitor</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LocalVariableTableVisitor</span> <span class="keyword">extends</span> <span class="title class_">MethodVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LocalVariableTableVisitor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(Opcodes.ASM5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLocalVariable</span><span class="params">(String name, String description, String signature, Label start, Label end, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;  &quot;</span> + description);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-框架">Spring 框架</h2>
<p>若使用 Spring 框架，对于运行时获取参数名，Spring 提供了内建支持，对应的实现类为 <code>DefaultParameterNameDiscoverer</code> （<a href="http://docs.spring.io/spring/docs/4.3.x/javadoc-api/org/springframework/core/DefaultParameterNameDiscoverer.html">javadoc</a>）。该类先尝试用 Java 8 新的反射 API 获取方法参数名，若无法获取，则使用 ASM 库读取 class 文件的 <code>LocalVariableTable</code>，对应的代码分别为 <a href="https://github.com/spring-projects/spring-framework/blob/4.3.x/spring-core/src/main/java/org/springframework/core/StandardReflectionParameterNameDiscoverer.java">StandardReflectionParameterNameDiscoverer</a> 和 <a href="https://github.com/spring-projects/spring-framework/blob/4.3.x/spring-core/src/main/java/org/springframework/core/LocalVariableTableParameterNameDiscoverer.java">LocalVariableTableParameterNameDiscoverer</a>。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>2014-10 Java 8 Named Method Parameters <a href="https://www.beyondjava.net/blog/reading-java-8-method-parameter-named-reflection/">https://www.beyondjava.net/blog/reading-java-8-method-parameter-named-reflection/</a></li>
<li>JEP 118: Access to Parameter Names at Runtime <a href="http://openjdk.java.net/jeps/118">http://openjdk.java.net/jeps/118</a></li>
<li>Enhancements to the Reflection API <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/reflection/enhancements.html">http://docs.oracle.com/javase/8/docs/technotes/guides/reflection/enhancements.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字节码</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 官方文档整理</title>
    <url>/2016/11/java-official-doc/</url>
    <content><![CDATA[<p>本文整理一些学习Java需要翻阅或必须的官方文档资料。</p>
<span id="more"></span>
<h1 id="Java-SE文档">Java SE文档</h1>
<p>Java SE Technologies at a Glance <a href="http://www.oracle.com/technetwork/java/javase/tech/index.html">http://www.oracle.com/technetwork/java/javase/tech/index.html</a></p>
<p><a href="http://docs.oracle.com/javase/8/">http://docs.oracle.com/javase/8/</a><br>
<a href="http://docs.oracle.com/javase/8/docs/index.html">http://docs.oracle.com/javase/8/docs/index.html</a> Platform Overview平台概览图<br>
<a href="http://docs.oracle.com/javase/8/javase-books.htm">http://docs.oracle.com/javase/8/javase-books.htm</a></p>
<p>Java Platform Overview (docs/technotes/<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/">guides</a>)</p>
<ol>
<li>Java Programming Language (guides/<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/index.html">language</a>)</li>
<li>Java Virtual Machine Technology (guides/<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html">vm</a>)</li>
<li>JDK Tools and Utilities (technotes/<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/index.html">tools</a>)</li>
</ol>
<p>Java SE API：</p>
<ol>
<li>Base Libraries (guides/<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/#base">#base</a>):</li>
</ol>
<ul>
<li>Lang and Util Packages: <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/lang/index.html">lang and util</a> (java.lang &amp; java.util), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/math/index.html">Math</a> (java.lang.Math), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html">Collections</a> (java.util), Reference Objects, Regular Expressions (java.util.regex), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/logging/index.html">Logging</a> (java.util.logging), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/management/index.html">Management</a> (java.lang.management), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/instrumentation/index.html">Instrumentation</a> (java.lang.instrument), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/index.html">Concurrency Utilities</a> (java.lang.Thread, java.util.concurrent), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html">Reflection</a> (java.lang.reflect), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/versioning/index.html">Package Versioning</a>, <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/preferences/index.html">Preferences API</a> (java.util.prefs), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/index.html">JAR</a> (java.util.jar), Zip (java.util.zip)</li>
<li>Other Base Packages: <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/beans/index.html">Beans</a> (java.beans), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html">Security</a> (java.security &amp; javax.crypto), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/serialization/index.html">Serialization</a> (<a href="http://java.io">java.io</a>), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/extensions/index.html">Extension Mechanism</a>, <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jmx/index.html">JMX</a>, <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/xml/index.html">XML JAXP</a>, <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/net/index.html">Networking</a> (<a href="http://java.net">java.net</a> &amp; <a href="http://javax.net">javax.net</a>), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/standards/index.html">Override Mechanism</a>, <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jni/index.html">JNI</a>, <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html">Date and Time</a> (java.time), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/io/index.html">Input/Output</a> (<a href="http://java.io">java.io</a> &amp; java.nio), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/intl/index.html">Internationalization</a></li>
</ul>
<ol start="2">
<li>Integration Libraries (guides/<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/#integration">#integration</a>): <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/idl/index.html">IDL</a> (CORBA, org.omg.*), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/index.html">JDBC</a> (java.sql &amp; javax.sql), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/rmi/index.html">RMI</a> (java.rmi), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/rmi-iiop/index.html">RMI-IIOP</a> (org.omg.*) <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html">JNDI</a> (javax.naming), <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/index.html">Scripting</a> (javax.script)</li>
<li>User Interface Libraries (guides/<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/#userinterface">#userinterface</a>): Swing, Java 2D, AWT, Accessibility, Drag and Drop, Input Methods, Image I/O, Print Service, Sound</li>
</ol>
<p><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/">http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/</a></p>
<p><strong>中文API文档：</strong><br>
<a href="http://download.oracle.com/technetwork/java/javase/6/docs/zh/api/">http://download.oracle.com/technetwork/java/javase/6/docs/zh/api/</a><br>
<a href="http://www.cjsdn.net/Doc/JDK60/">http://www.cjsdn.net/Doc/JDK60/</a></p>
<hr>
<h1 id="Java虚拟机">Java虚拟机</h1>
<p><a href="https://en.wikipedia.org/wiki/Template:Java_Virtual_Machine">https://en.wikipedia.org/wiki/Template:Java_Virtual_Machine</a><br>
<a href="https://en.wikipedia.org/wiki/Java_performance">https://en.wikipedia.org/wiki/Java_performance</a></p>
<p><strong>JDK源码</strong>：<br>
<a href="https://github.com/dmlloyd/openjdk">https://github.com/dmlloyd/openjdk</a><br>
<a href="https://github.com/openjdk-mirror/jdk7u-jdk">https://github.com/openjdk-mirror/jdk7u-jdk</a><br>
<a href="https://github.com/openjdk-mirror/jdk7u-hotspot">https://github.com/openjdk-mirror/jdk7u-hotspot</a></p>
<p><strong>虚拟机与性能</strong><br>
<a href="http://en.wikipedia.org/wiki/Template:Java_%28software_platform%29">http://en.wikipedia.org/wiki/Template:Java_%28software_platform%29</a><br>
<a href="http://en.wikipedia.org/wiki/Template:Java_Virtual_Machine">http://en.wikipedia.org/wiki/Template:Java_Virtual_Machine</a><br>
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a><br>
<a href="http://openjdk.java.net/groups/hotspot/">http://openjdk.java.net/groups/hotspot/</a></p>
<p><strong>Java SE HotSpot at a Glance</strong>，<a href="http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html">link</a></p>
<ol>
<li>HotSpot Engine Architecture，<a href="http://www.oracle.com/technetwork/java/whitepaper-135217.html">link</a></li>
<li>HotSpot Thread Implementation (Solaris)，<a href="http://www.oracle.com/technetwork/java/threads-140302.html">link</a></li>
<li>HotSpot Garbage Collection，<a href="http://www.oracle.com/technetwork/java/javase/tech/index-jsp-140228.html">link</a></li>
</ol>
<ul>
<li><strong>Memory Management Whitepaper[pdf]</strong>，<a href="http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">link</a>：最权威、最完整文档</li>
<li>Garbage Collector Ergonomics，<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/vm/gc-ergonomics.html">link</a></li>
<li>Garbage Collection Tuning，<a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">link</a></li>
<li>Garbage First (&quot;G1&quot;) Garbage Collector，<a href="http://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html">link</a></li>
</ul>
<ol start="4">
<li>HotSpot Ergonomics，<a href="http://www.oracle.com/technetwork/java/ergo5-140223.html">link</a></li>
<li>HotSpot Performance and Tuning，<a href="http://www.oracle.com/technetwork/java/performance-138178.html">link</a></li>
</ol>
<ul>
<li>2007.10, Java SE 6.0 Performance White Paper，<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">link</a></li>
<li>2005.03, J2SE 5.0 Performance White Paper，<a href="http://www.oracle.com/technetwork/java/5-136747.html">link</a></li>
</ul>
<ol start="8">
<li>HotSpot Publications，<a href="http://www.oracle.com/technetwork/java/javase/tech/publications-140132.html">link</a></li>
</ol>
<p><strong>Troubleshooting Java SE 8，<a href="http://www.oracle.com/technetwork/java/javase/index-138283.html">link</a> 资料汇总</strong></p>
<ol>
<li>Java Troubleshooting Guide Java SE 8，<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/toc.html">link</a></li>
<li>Troubleshooting Guide for Java SE 6 with HotSpot VM，<a href="http://www.oracle.com/technetwork/java/javase/memleaks-137499.html">link</a></li>
<li>Troubleshooting Guide for HotSpot VM (JDK 7)，<a href="http://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/%0A">link</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务 API 网关 Kong 实践</title>
    <url>/2020/05/kong-gateway/</url>
    <content><![CDATA[<h1 id="Kong-简介">Kong 简介</h1>
<p>Kong 是云原生、高效、可扩展、分布式的微服务抽象层，被称为 API 网关，或者 API 中间件。Kong 在 2015 年 4 月由 Mashape 公司开源，基于 OpenResty 和 Apache Cassandra/PostgreSQL 构建，提供易于使用的 RESTful API 来操作和配置 API 系统<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<span id="more"></span>
<p>Mashape 是 API 集市，是为应用开发者与 API 提供者服务的 API 交易市场，Mashape 让发者能够方便地查找与购买 API，而 API 提供商则能轻松地销售与管理 API<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。随着 Mashape 市场上的 API 越来越多，原先基于 Node.js 实现的 API 代理不再适用，不能处理大流量尖峰，无法快速扩容。于是，寻找处理大流量的方案，同时需要保证可靠性和安全性，成为 Mashape 亟待解决的问题。2013 年，在 CloudFlare（当时 OpenResty 背后的公司）的工程师的建议下，Mashape 开始在 OpenResty 基础上开发 Kong 项目<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。Mashape 公司的名字，MashAPE，有人猿猩猩的含义，公司 logo 也是相应动物。类似的，Kong，对应的是，<a href="https://en.wikipedia.org/wiki/King_Kong">King Kong</a>，就是电影里的金刚<sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup>。在 Mashape 开启 Kong 项目两年后，2015 年 4 月，Mashape 公司开源了 Kong<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>。</p>
<p>2017 年 5月，Mashape 和 RapidAPI 合并，组成全球最大的 API 集市<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。5 个月后，Mashape, Inc. 改名为 <a href="https://en.wikipedia.org/wiki/Kong_Inc%2E">Kong Inc.</a>，新的公司以 Kong 项目为聚焦，把全部工程师投入到 Kong 开发中，并且于此同时他们发布了 <a href="https://konghq.com/products/kong-enterprise/">Kong 企业版</a><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。</p>
<p>Kong，作为微服务的请求的网关，能通过插件提供负载均衡、日志记录、鉴权、限流、转换以及其他等功能。相对与旧的、没有使用网关的方式，Kong 把这些通用功能中心化，让微服务更加专注于业务本身。</p>
<img width="800" alt="The Old way vs. The Kong Way" title="The Old way vs. The Kong Way" src="https://static.nullwy.me/kong-old-way-vs-kong-way.png">
<p>Kong 的整体架构，如下图所示<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>：</p>
<ul>
<li>管理 API：通过 RESTful API 管理 Kong；能自动化集成；管理 API 能通过插件扩展</li>
<li>插件：使用 Lua 脚本创建 Plugins；实现强力的定制化；与第三方服务集成</li>
<li>集群和数据存储：数据存储可选择 PostgreSQL 或 Cassandra；能从单节点扩展为集群；使用内存缓存提高性能</li>
<li>OpenResty：拦截请求/响应生命周期；基于 NGINX 扩展；Lua 脚本化</li>
<li>NGINX：验证过的高性能基础组件；HTTP 和反向代理服务器；处理底层操作</li>
</ul>
<img width="300" alt="Kong Architecture" title="Kong Architecture" src="https://static.nullwy.me/kong-architecture.png">
<h1 id="Kong-安装">Kong 安装</h1>
<p>目前最新的 Kong 版本是 2.0.x，2.0 发布时间是 2020 年 1 月，而 1.0 发布时间是 2018 年 12 月<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>。笔者公司使用的 Kong 版本是 0.14.1，暂时未升级自最新版，所以下文阐述的 Kong 版本主要以 0.14.1 为准，并同时会提及其他版本的特性。</p>
<p>安装 Kong 很简单，参见<a href="https://konghq.com/install/">官方文档</a>即可。在 <a href="https://docs.konghq.com/install/ubuntu/">Ubuntu</a> 18.04 下安装 Kong 0.14.1，可以执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kong 安装</span></span><br><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install openssl libpcre3 procps perl</span><br><span class="line">$ wget -O kong-community-edition-0.14.1.trusty.all.deb https://bintray.com/kong/kong-community-edition-deb/download_file?file_path=dists/kong-community-edition-0.14.1.trusty.all.deb</span><br><span class="line">$ sudo dpkg -i kong-community-edition-0.14.1.trusty.all.deb</span><br><span class="line">$ kong version</span><br><span class="line">0.14.1</span><br></pre></td></tr></table></figure>
<p>Kong 依赖数据库，Postgres 或者 Cassandra，默认依赖 Postgres（kong 1.1 开始支持无数据库声明式配置<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>）。我们预先安装 Postgres：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 postgresql</span></span><br><span class="line">$ sudo apt install postgresql</span><br><span class="line">$ sudo service postgresql start</span><br><span class="line">$ psql --version</span><br><span class="line">psql (PostgreSQL) 10.12 (Ubuntu 10.12-0ubuntu0.18.04.1)</span><br></pre></td></tr></table></figure>
<p>在 Postgres 下添加 Kong 需要的的数据库实例和用户。下面的示例，创建数据库 <code>kong</code>，用户名 <code>kong</code>，密码为 <code>kong</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo -u postgres psql</span><br><span class="line">postgres=<span class="comment"># CREATE USER kong; CREATE DATABASE kong OWNER kong;</span></span><br><span class="line">postgres=<span class="comment"># ALTER USER kong WITH PASSWORD &#x27;kong&#x27;;</span></span><br><span class="line">postgres=<span class="comment"># \q</span></span><br></pre></td></tr></table></figure>
<p>执行完成后，即可使用用户名为 <code>kong</code> 的用户连接 Postgres，<code>psql -h localhost -U kong -d kong</code>。</p>
<p>Kong 安装完成后，默认会创建配置文件 <code>/etc/kong/kong.conf.default</code>，这份配置文件在 <a href="https://github.com/Kong/kong/blob/0.14.1/kong.conf.default">GitHub</a> 上也能找到，被注释掉的配置项，就是默认设置。</p>
<p>在启动 Kong 网关服务器前，我们参考 <code>kong.conf.default</code>，创建自己的 <code>kong.conf</code> 配置文件。我们把配置文件放在 <code>/home/yulewei/kong</code> 目录下，同时也把这目录当作为 Kong 的 <code>prefix</code> 目录。修改这配置 <code>kong.conf</code>，文件末尾添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefix = /home/yulewei/kong/</span><br><span class="line">pg_user=kong</span><br><span class="line">pg_password=kong</span><br><span class="line">pg_database = kong</span><br></pre></td></tr></table></figure>
<p>使用 <a href="https://docs.konghq.com/0.14.x/cli/"><code>kong</code></a> 命令，启动 Kong 网关服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化或迁移数据库数据</span></span><br><span class="line">$ kong migrations up -c /home/yulewei/kong/kong.conf</span><br><span class="line"><span class="comment"># 启动 kong</span></span><br><span class="line">$ kong start -c /home/yulewei/kong/kong.conf</span><br></pre></td></tr></table></figure>
<p>Kong 默认绑定 4 个端口：</p>
<ul>
<li><code>:8000</code> 用来接收来自客户端的 HTTP 流量的请求，并转发到上游服务</li>
<li><code>:8443</code> 用来接收来自客户端的 HTTPS 流量的请求，并转发到上游服务</li>
<li><code>:8001</code> 用来接收访问 <a href="https://docs.konghq.com/0.14.x/admin-api/">Admin API</a> 的 HTTP 流量的请求</li>
<li><code>:8444</code> 用来接收访问 Admin API 的 HTTPS 流量的请求</li>
</ul>
<p>所以，可以执行下面的命令，来确认 Kong 是否正常运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确认 Kong 是否正常运行</span></span><br><span class="line">$ curl -i http://localhost:8000/</span><br><span class="line">$ curl -i http://localhost:8001/</span><br></pre></td></tr></table></figure>
<p>Kong 底层依赖 OpenResty，启动 Kong 后，可以看到 nginx 进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 nginx 进程</span></span><br><span class="line">$ ps -ef | grep nginx</span><br><span class="line">yulewei  19090     1  0 16:05 ?        00:00:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /home/yulewei/kong -c nginx.conf</span><br><span class="line">yulewei  19091 19090  0 16:05 ?        00:00:00 nginx: worker process</span><br><span class="line">yulewei  19092 19090  0 16:05 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure>
<p>安装 Kong 0.14.1，自动安装的 OpenResty 版本是 1.13.6.2，OpenResty 捆绑的安装了 LuaJIT。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/local/openresty/nginx/sbin/nginx -v</span><br><span class="line">nginx version: openresty/1.13.6.2</span><br><span class="line"></span><br><span class="line">$ /usr/local/openresty/bin/resty -V</span><br><span class="line">resty 0.21</span><br><span class="line">nginx version: openresty/1.13.6.2</span><br><span class="line">built by gcc 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.4)</span><br><span class="line">built with OpenSSL 1.0.2n  7 Dec 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: ... 省略 ...</span><br><span class="line"></span><br><span class="line">$ /usr/local/openresty/luajit/bin/luajit -v</span><br><span class="line">LuaJIT 2.1.0-beta3 -- Copyright (C) 2005-2017 Mike Pall. http://luajit.org/</span><br></pre></td></tr></table></figure>
<p>另外，同时也安装了 LuaRocks，LuaRocks 关联的是 OpenResty 捆绑的 LuaJIT。事实上，Kong 就是一个 LuaRocks 的 <a href="https://luarocks.org/modules/kong/kong">rock</a> 包，在Kong 项目的 GitHub 上可以看到 <a href="https://github.com/Kong/kong/blob/0.14.1/kong-0.14.1-0.rockspec">rockspec</a> 文件。Kong 的安装，底层实现上，是通过 <code>luarocks</code> 命令完成的，类似这样的命令，<code>luarocks install kong 0.14.1-0</code><sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>。可以使用 <code>luarocks show</code> 命令查看这个 Kong 的 rcok 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luarocks show kong</span><br><span class="line">kong 0.14.1-0 - Kong is a scalable and customizable API Management Layer built on top of Nginx.</span><br><span class="line"></span><br><span class="line">License: 	MIT</span><br><span class="line">Homepage: 	http://getkong.org</span><br><span class="line">Installed <span class="keyword">in</span>: 	/usr/local</span><br><span class="line"></span><br><span class="line">Modules:</span><br><span class="line">	kong (/usr/local/share/lua/5.1/kong/init.lua)</span><br><span class="line">	kong.api (/usr/local/share/lua/5.1/kong/api/init.lua)</span><br><span class="line">... 省略 ...</span><br></pre></td></tr></table></figure>
<p>有个小细节值得注意，通过 <code>luarocks</code> 看到，Kong 采用的协议是 MIT。但事实上，Kong 0.5.0 开始协议从 MIT <a href="https://github.com/Kong/kong/commit/9faa7f0e0648a037bb6a465bad08d5928a9ca31f">改成了</a> Apache 2.0。此处是一个小 bug，Kong 的 rockspec 文件没有及时更新，这个问题后来修复了，参见 <a href="https://github.com/Kong/kong/pull/4125">#4125</a>。</p>
<h2 id="GUI-管理工具">GUI 管理工具</h2>
<p>管理 Kong 可以直接使用 Admin API，当然也有基于 Admin API 实现 GUI 管理工具。</p>
<p>Kong 官方的企业版提供了 GUI 管理工具，<a href="https://konghq.com/products/kong-enterprise/kong-manager/"><code>Kong Manager</code></a>（Kong EE 0.34 之前称为 <a href="https://docs.konghq.com/enterprise/0.33-x/admin-gui/overview/"><code>Admin GUI</code></a>），Kong 社区版没有提供 GUI 管理工具。</p>
<p>第三方的开源 GUI 工具，比较活跃的就是 <a href="https://github.com/pantsel/konga"><code>Konga</code></a>，值得推荐，如下图。</p>
<img width="800" alt="konga" title="konga" src="https://static.nullwy.me/konga.png">
<p>另外，还有其他的 GUI 工具，比如 <a href="https://github.com/PGBI/kong-dashboard"><code>Kong Dashboard</code></a>，也可以了解下。</p>
<h1 id="Kong-使用">Kong 使用</h1>
<p>Kong 核心概念：</p>
<ul>
<li><code>Service</code>：对应位于 Kong 后方的自身的 <code>Upstream</code> API 或微服务。</li>
<li><code>Route</code>：Kong 的入口点，定义了如何把请求发送到特定 <code>Service</code> 的规则。一个 <code>Service</code> 可以有多个<code>Route</code>。</li>
<li><code>Plugin</code>：插件提供了模块化系统，用来修改或控制 Kong。插件提供了大量功能，比如访问控制、缓存、限流、日志记录等。</li>
<li><code>Consumer</code>：消费者，表示使用 API 的用户，能用来对用户进行访问控制、跟踪等。</li>
</ul>
<p>Kong 网关的请求响应工作流，如下图所示：</p>
<img width="700" alt="Kong Overview" title="Kong Overview" src="https://static.nullwy.me/kong-overview.png">
<h2 id="反向代理">反向代理</h2>
<p>Kong 的核心功能就是对现有的上游服务的 API 作反向代理。反向代理，官方的完整的文档参见<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>。现在我们来试验下 Kong 的反向代理功能，执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 service</span></span><br><span class="line">$ curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;example.service&quot;,&quot;url&quot;:&quot;http://httpbin.org&quot;&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/services/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 service 上添加 route</span></span><br><span class="line">$ curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;paths&quot;:[&quot;/base64&quot;],&quot;strip_path&quot;:false&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/services/example.service/routes</span><br></pre></td></tr></table></figure>
<p>上面的第一条命令，通过调用 Kong 提供的 Admin API，让 Kong 创建了名为 <code>example.service</code> 的 <code>service</code>，<code>service</code> 指向的上游服务是 <code>http://httpbin.org</code>。第二条命令，在 <code>example.service</code> 上添加 <code>route</code> 规则，规则是让请求路径前缀为 <code>/base64</code> 的请求转发到这个 <code>service</code>。来验证下，刚刚的 Kong 的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证 Kong 配置结果</span></span><br><span class="line">$ curl http://httpbin.org/base64/aGVsbG8ga29uZw==</span><br><span class="line">hello kong</span><br><span class="line">$ curl http://localhost:8000/base64/aGVsbG8ga29uZw==</span><br><span class="line">hello kong</span><br></pre></td></tr></table></figure>
<p>上文的 Kong 配置，等价的 <code>nginx.conf</code> 配置文件的写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 8000;</span><br><span class="line">  location /base64 &#123;</span><br><span class="line">    proxy_pass http://httpbin.org/base64;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了前缀外，<code>route</code> 规则的 <code>paths</code> 字段也支持 PCRE <a href="https://docs.konghq.com/0.14.x/proxy/#using-regexes-in-paths">正则表达式</a>，来看下示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;paths&quot;:[&quot;/status/\\d+&quot;],&quot;strip_path&quot;:false&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/services/example.service/routes</span><br></pre></td></tr></table></figure>
<p>上面的命令，添加 <code>route</code> 规则，设置的 <code>paths</code> 字段值为 <code>/status/\d+</code>，让只有请求路径的中包含数字才能匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证 Kong 配置结果</span></span><br><span class="line">$ curl -sI http://httpbin.org/status/418 | <span class="built_in">head</span> -n1</span><br><span class="line">HTTP/1.1 418 I<span class="string">&#x27;M A TEAPOT</span></span><br><span class="line"><span class="string">$ curl -sI http://localhost:8000/status/418 | head -n1</span></span><br><span class="line"><span class="string">HTTP/1.1 418 I&#x27;</span>M A TEAPOT</span><br><span class="line">$ curl -sI http://localhost:8000/status/200 | <span class="built_in">head</span> -n1</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">$ curl http://localhost:8000/status/abc</span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;no route and no API found with those values&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="负载均衡">负载均衡</h2>
<p>上文的反向代理指向的是单台的上游服务器，如果要指向多台上游服务器，实现负载均衡，要如何配置呢？负载均衡，Nginx 可以通过 <code>upstream</code> 指令实现，而类似的，Kong 通过创建 <code>upstream</code> 对象实现。</p>
<p>假设在服务器 <code>192.168.2.100:80</code> 和 <code>192.168.2.101:80</code> 上运行着本地版的 <code>httpbin.org</code> 的 REST API 服务（通过 <code>docker run -p 80:80 kennethreitz/httpbin</code>）。执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 upstream</span></span><br><span class="line">curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;example.upstream&quot;&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/upstreams/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 upstream 上添加 target</span></span><br><span class="line">curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;target&quot;:&quot;192.168.2.100:80&quot;&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/upstreams/example.upstream/targets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 upstream 上添加 target</span></span><br><span class="line">curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;target&quot;:&quot;192.168.2.101:80&quot;&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/upstreams/example.upstream/targets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 service</span></span><br><span class="line">curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;example.service&quot;,&quot;host&quot;:&quot;example.upstream&quot;&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/services/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 service 上添加 route</span></span><br><span class="line">curl -XPOST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;paths&quot;:[&quot;/base64&quot;],&quot;strip_path&quot;:false&#125;&#x27;</span> \</span><br><span class="line">     http://localhost:8001/services/example.service/routes</span><br></pre></td></tr></table></figure>
<p>上面的命令，先创建了 <code>upstream</code> 对象，虚拟主机名（virtual hostname）为 <code>example.upstream</code> 。然后在这个 <code>upstream</code> 上添加 <code>target</code>，<code>192.168.2.100:80</code> 和 <code>192.168.2.101:80</code>。再然后把 <code>service</code> 对象的 <code>host</code> 字段值设置为  <code>example.upstream</code>。这样全部发送到这个 <code>service</code> 的请求都会被转发到 <code>example.upstream</code> 这个 <code>upstream</code>，<code>upstream</code> 再执行负载均衡算法，把请求转发到最终的上游服务器。和 Nginx 一样，默认的负载均衡算法为加权轮询算法（weighted-round-robin）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证 Kong 配置结果</span></span><br><span class="line">$ curl http://localhost:8000/base64/aGVsbG8ga29uZw==</span><br><span class="line">hello kong</span><br></pre></td></tr></table></figure>
<p>上文的 Kong 配置，等价的 <code>nginx.conf</code> 配置文件的写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream example.upstream &#123;</span><br><span class="line">  server 192.168.2.100:80;</span><br><span class="line">  server 192.168.2.101:80;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 8000;</span><br><span class="line">  location /base64 &#123;</span><br><span class="line">    proxy_pass http://example.upstream/base64;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 Kong 负载均衡的更多介绍，可以阅读官方文档<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>，本文不再展开。</p>
<h2 id="开启插件">开启插件</h2>
<p>Kong 提供了很多插件，官方整理维护的全部插件列表，可以在<a href="https://docs.konghq.com/hub/">官网</a>上看到。全部插件分 8 大类：身份认证类插件（Authentication）、安全控制类插件（Security）、流量控制类插件（Traffic Control）、无服务器计算类插件（Serverless）、分析与监控类插件（Analytics &amp; Monitoring）、协议转换类插件（Transformations）、日志记录类插件（Logging）、部署类插件（Deployment）。Kong 0.14.1 社区版默认绑定的预定义插件，全部 31 个，调用下面的 <a href="https://docs.konghq.com/0.14.x/admin-api/#plugin-object">Admin API</a> 可以查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kong 社区版全部默认绑定的插件，共 31 个</span></span><br><span class="line">$ curl http://localhost:8001/plugins/enabled</span><br><span class="line">&#123;<span class="string">&quot;enabled_plugins&quot;</span>:[<span class="string">&quot;response-transformer&quot;</span>,<span class="string">&quot;oauth2&quot;</span>,<span class="string">&quot;acl&quot;</span>,<span class="string">&quot;correlation-id&quot;</span>,<span class="string">&quot;pre-function&quot;</span>,<span class="string">&quot;jwt&quot;</span>,<span class="string">&quot;cors&quot;</span>,<span class="string">&quot;ip-restriction&quot;</span>,<span class="string">&quot;basic-auth&quot;</span>,<span class="string">&quot;key-auth&quot;</span>,<span class="string">&quot;rate-limiting&quot;</span>,<span class="string">&quot;request-transformer&quot;</span>,<span class="string">&quot;http-log&quot;</span>,<span class="string">&quot;file-log&quot;</span>,<span class="string">&quot;hmac-auth&quot;</span>,<span class="string">&quot;ldap-auth&quot;</span>,<span class="string">&quot;datadog&quot;</span>,<span class="string">&quot;tcp-log&quot;</span>,<span class="string">&quot;zipkin&quot;</span>,<span class="string">&quot;post-function&quot;</span>,<span class="string">&quot;request-size-limiting&quot;</span>,<span class="string">&quot;bot-detection&quot;</span>,<span class="string">&quot;syslog&quot;</span>,<span class="string">&quot;loggly&quot;</span>,<span class="string">&quot;azure-functions&quot;</span>,<span class="string">&quot;udp-log&quot;</span>,<span class="string">&quot;response-ratelimiting&quot;</span>,<span class="string">&quot;aws-lambda&quot;</span>,<span class="string">&quot;statsd&quot;</span>,<span class="string">&quot;prometheus&quot;</span>,<span class="string">&quot;request-termination&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来试下 Kong 的 <a href="https://docs.konghq.com/hub/kong-inc/basic-auth/">basic-auth</a> 插件，用来实现 <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic 认证</a>（RFC 7617）。执行下面的命令，在上文的 <code>example.service</code> 的 <code>service</code> 上开启 <code>basic-auth</code> 插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 service 上开启 basic-auth 插件</span></span><br><span class="line">$ curl -XPOST --data <span class="string">&quot;name=basic-auth&quot;</span> \</span><br><span class="line">       http://localhost:8001/services/example.service/plugins</span><br></pre></td></tr></table></figure>
<p>这样全部到 <code>example.service</code> 的请求都需要进行 Basic 认证。再次请求之前的 <code>/base64</code> 接口，返回状态码 <code>401 Unauthorized</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接口 HTTP 状态码返回 401</span></span><br><span class="line">$ curl -i http://localhost:8000/base64/aGVsbG8ga29uZw==</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">... 省略 ...</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Unauthorized&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>添加身份认证的凭证，添加 username/password：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 consumer</span></span><br><span class="line">$ curl -XPOST --data <span class="string">&quot;username=Jason&quot;</span> \</span><br><span class="line">       http://localhost:8001/consumers/</span><br><span class="line"><span class="comment"># 在 consumer 上添加 basic-auth 插件的凭证 username/password</span></span><br><span class="line">$ curl -XPOST --data <span class="string">&quot;username=test&amp;password=123456&quot;</span> \</span><br><span class="line">       http://localhost:8001/consumers/Jason/basic-auth</span><br></pre></td></tr></table></figure>
<p>现在请求头上带上凭证，重新请求 <code>/base64</code> 接口，响应正常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -u <span class="string">&#x27;test:123456&#x27;</span> http://localhost:8000/base64/aGVsbG8ga29uZw==</span><br><span class="line">hello kong</span><br></pre></td></tr></table></figure>
<p>Kong 插件，除了绑定到 <code>service</code> 上外，也可以绑定在 <code>route</code> 和 <code>consumer</code> 上。如果开启插件时，<code>service</code>、<code>route</code> 或 <code>consumer</code> 全部都不关联，就是全局范围开启插件，插件会在全部请求上运行。全局范围上开启 <code>basic-auth</code> 插件，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局范围上开启 basic-auth 插件</span></span><br><span class="line">$ curl -XPOST --data <span class="string">&quot;name=basic-auth&quot;</span> \</span><br><span class="line">       http://localhost:8001/plugins</span><br></pre></td></tr></table></figure>
<p>关于 Kong 插件的更多介绍，可以阅读<a href="https://docs.konghq.com/1.5.x/admin-api/#plugin-object">官方文档</a>，本文不再展开。</p>
<h1 id="Kong-插件开发">Kong 插件开发</h1>
<p>Kong 基于 OpenResty，OpenResty 通过 <a href="https://github.com/openresty/lua-nginx-module"><code>ngx_http_lua_module</code></a> 模块实现了在 Nginx 中内嵌 Lua 脚本的能力。Kong 插件，使用 Lua 脚本实现，全部默认加载的预定义插件对应的 Lua 源码（包括上文提到的 basic-auth 插件），可以在 Kong 项目仓库的 <code>kong/plugins</code> 目录下看到。</p>
<p>除了能使用 Kong 预定义插件，我们可以根据 Kong 插件开发文档<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>，开发自定义插件。</p>
<p>如何开发插件，文本不展开。Kong 官方提供了自定义插件的模板代码，源码参见项目 kong-plugin<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>。另外，有兴趣也可以参考笔者提供的 Kong 自定义插件示例，源码参见 kong-plugin-demo<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>。</p>
<p>值得注意的是，Kong 使用 Lua 的 <a href="https://github.com/rxi/classic"><code>rxi/classic</code></a> 模块来模拟 Lua 中的类，自定义 Kong 的插件时，实现 handler 需要继承 <code>BasePlugin</code> class，目前最新的文档还是采用这种写法。不过，Kong 1.2 开始，Kong 内部的预定义实现的插件，废弃了继承 <code>BasePlugin</code> class 的写法，参见 Pull Request <a href="https://github.com/Kong/kong/pull/4590">#4590</a>，“plugins handlers do not have to inherit from BasePlugin anymore #4590”。去掉对 <code>BasePlugin</code> class 的继承后，在开启单个插件（key-auth）的场景下，压测 Kong 性能提升 6%，开启多个插件的场景，性能提升更高。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>What is Kong? <a href="https://konghq.com/about-kong/">https://konghq.com/about-kong/</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>2015-04 Mashape 开源 API 网关——Kong <a href="https://www.infoq.cn/article/2015/04/kong/">https://www.infoq.cn/article/2015/04/kong/</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2012-07 打造大集市：API交易网站Mashape正式推出 <a href="https://www.csdn.net/article/2012-07-31/2807936">https://www.csdn.net/article/2012-07-31/2807936</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2015-10 How Mashape Manages Over 15,000 APIs &amp; Microservices <a href="https://stackshare.io/kong/how-mashape-manages-over-15000-apis-and-microservices">https://stackshare.io/kong/how-mashape-manages-over-15000-apis-and-microservices</a> <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2017-05 Mashape 和 RapidAPI 合并，组成全球最大的应用编程接口（API）集市！ <a href="https://www.sohu.com/a/144114294_465914">https://www.sohu.com/a/144114294_465914</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>2017-05 The API Marketplace Joins RapidAPI <a href="https://konghq.com/blog/the-api-marketplace-joins-rapidapi/">https://konghq.com/blog/the-api-marketplace-joins-rapidapi/</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2017-10 Welcome Kong Inc. A New Name, a New Product, a New Era. <a href="https://konghq.com/blog/introducing-kong-inc/">https://konghq.com/blog/introducing-kong-inc/</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>2018-12 Kong 1.0 GA <a href="https://konghq.com/blog/kong-1-0-ga/">https://konghq.com/blog/kong-1-0-ga/</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>2020-01 Kong Gateway 2.0 GA <a href="https://konghq.com/blog/kong-gateway-2-0-0-released/">https://konghq.com/blog/kong-gateway-2-0-0-released/</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Documentation for Kong: DB-less and Declarative Configuration <a href="https://docs.konghq.com/1.1.x/db-less-and-declarative-config/">https://docs.konghq.com/1.1.x/db-less-and-declarative-config/</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Kong Installation: Compile Source <a href="https://docs.konghq.com/install/source/">https://docs.konghq.com/install/source/</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Build tools to package and release Kong <a href="https://github.com/Kong/kong-build-tools">https://github.com/Kong/kong-build-tools</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Documentation for Kong: Proxy Reference <a href="https://docs.konghq.com/0.14.x/proxy/">https://docs.konghq.com/0.14.x/proxy/</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Documentation for Kong: Load Balancing Reference <a href="https://docs.konghq.com/0.14.x/loadbalancing/">https://docs.konghq.com/0.14.x/loadbalancing/</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Documentation for Kong: Plugin Development <a href="https://docs.konghq.com/0.14.x/plugin-development/">https://docs.konghq.com/0.14.x/plugin-development/</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Kong 官方自定义插件的模板代码 <a href="https://github.com/Kong/kong-plugin">https://github.com/Kong/kong-plugin</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Kong 自定义插件示例 <a href="https://github.com/yulewei/kong-plugin-demo">https://github.com/yulewei/kong-plugin-demo</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
        <tag>服务器</tag>
        <tag>Kong</tag>
        <tag>Nginx</tag>
        <tag>OpenResty</tag>
        <tag>网关</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言与编译器书籍资料整理</title>
    <url>/2016/11/lang-and-compiler-books/</url>
    <content><![CDATA[<p>本文整理编程语言与编译器相关的经典书籍。</p>
<span id="more"></span>
<p><a href="https://zh.wikipedia.org/wiki/Template:%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">https://zh.wikipedia.org/wiki/Template:程序设计语言</a><br>
<a href="https://en.wikipedia.org/wiki/Template:IPC">https://en.wikipedia.org/wiki/Template:IPC</a><br>
<a href="https://en.wikipedia.org/wiki/Programming_language#Further_reading">https://en.wikipedia.org/wiki/Programming_language#Further_reading</a></p>
<p>Language Books/Tutorials for popular languages <a href="http://stackoverflow.com/q/22873">http://stackoverflow.com/q/22873</a></p>
<p><strong>编程语言、程序分析相关书籍：</strong></p>
<ol>
<li>1999、2005、2009，<a href="http://en.wikipedia.org/wiki/Michael_L._Scott">Michael L. Scott</a>，《<strong>程序设计语言：实践之路</strong>》（Programming Language Pragmatics, <a href="http://amzn.com/1558604421">1st</a> 1999, <a href="http://www.amazon.com/Programming-Language-Pragmatics-Third-Edition/dp/0123745144">3rd</a> 2009），<a href="http://www.cs.rochester.edu/u/scott/pragmatics/">home</a>，第3版<a href="http://book.douban.com/subject/10802357/">豆瓣</a>：全书800多页，内容优于Sebesta版，有16页参考文献，涵盖程序语言、编译原理、计算机体系结构等多个子学科</li>
<li>1993-2012，<a href="http://cs.uccs.edu/~rsebesta/">Robert W. Sebesta</a>，《<strong>程序设计语言概念</strong>》（Concepts of Programming Languages, <a href="http://www.amazon.com/Concepts-Programming-Languages-Robert-Sebesta/dp/0131395319">10th</a> 2012, <a href="http://amzn.com/013394302X">11th</a> 2015），第10版<a href="http://book.douban.com/subject/23055481/">豆瓣</a>：全书600页左右，内容编程语言发展历史概述，以及分别介绍、比较</li>
<li>2002、2004，Benjamin C. Pierce，《类型和程序设计语言》（Types and Programming Languages, <a href="http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091">amazon</a>），<a href="http://www.cis.upenn.edu/~bcpierce/tapl/">home</a>，<a href="http://book.douban.com/subject/1318672/">豆瓣</a></li>
<li>1993，Glynn Winskel，《程序设计语言的形式语义》（The Formal Semantics of Programming Languages, <a href="http://www.amazon.com/Formal-Semantics-Programming-Languages-Winskel/dp/0262731037">amazon</a>），<a href="http://book.douban.com/subject/1144542/">豆瓣</a></li>
<li>2002，<a href="http://en.wikipedia.org/wiki/John_C._Mitchell">John Mitchell</a>，《程序设计语言概念》（Concepts in Programming Languages），<a href="http://theory.stanford.edu/~jcm/books.html">home</a>，<a href="http://book.douban.com/subject/1699662/">豆瓣</a>：作者来自Stanford，<a href="http://theory.stanford.edu/~jcm/books/cpl-courses.html">courses</a>，内容主要讲Lisp及其他</li>
<li>1996，<a href="http://en.wikipedia.org/wiki/John_C._Mitchell">John Mitchell</a>，《程序设计语言理论基础》（Foundations for Programming Languages），<a href="http://book.douban.com/subject/1944729/">豆瓣</a></li>
<li>2004，“Concepts, Techniques, and Models of Computer Programming”，CTM，<a href="http://en.wikipedia.org/wiki/Concepts,_Techniques,_and_Models_of_Computer_Programming">wiki</a>，<a href="http://www.info.ucl.ac.be/~pvr/book.html">home</a></li>
<li>2010，Bruce Tate，《<strong>七周七语言：理解多种编程范型</strong>》（Seven Languages in Seven Weeks, <a href="http://pragprog.com/book/btlang/seven-languages-in-seven-weeks">Pragmatic</a>），<a href="http://book.douban.com/subject/10555435/">豆瓣</a>：书中介绍了Ruby、Io、Prolog、Scala、Erlang、Clojure和Haskell这七种语言</li>
<li>2010，Martin Fowler，《<strong>领域特定语言</strong>》（Domain-Specific Languages, <a href="http://www.amazon.com/Domain-Specific-Languages-Addison-Wesley-Signature-Series/dp/0321712943">amazon</a>），<a href="http://martinfowler.com/books/dsl.html">home</a>，<a href="http://www.infoq.com/cn/minibooks/domain-specific-languages">infoq</a>，<a href="http://book.douban.com/subject/21964984/">豆瓣</a></li>
<li>2010，《<strong>领域专用语言实战</strong>》（DSLs in Action），<a href="http://www.ituring.com.cn/book/836">图灵2013</a>，<a href="http://book.douban.com/subject/25741352/">豆瓣</a></li>
<li>2013，[日]西尾泰和，《代码之髓：编程语言核心概念》，<a href="http://www.ituring.com.cn/book/1233">图灵2014</a>，<a href="http://book.douban.com/subject/25927585/">豆瓣</a></li>
<li>2014，Neal Ford，《函数式编程思维》，<a href="https://book.douban.com/subject/26587213/">豆瓣</a>：涉及Java、Clojure、Scala</li>
</ol>
<hr>
<p><strong>编译器相关书籍：</strong></p>
<ol>
<li>1986、2007，Aho &amp; Sethi &amp; Ullman，龙书《<strong>编译原理</strong>》（<a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Compilers</a>: Principles, Techniques, and Tools, 1st 1986, <a href="http://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811">2nd</a> 2006），<a href="http://dragonbook.stanford.edu/">home</a>，<a href="http://book.douban.com/subject/3296317/">豆瓣</a>：侧重理论</li>
<li>1997、2002，<a href="http://en.wikipedia.org/wiki/Andrew_Appel">Appel</a>，虎书《<strong>现代编译原理</strong>》（Modern Compiler Implementation in Java/C/ML, <a href="http://amzn.com/0521607655">amazon</a>），<a href="http://www.cs.princeton.edu/~appel/modern/">home</a>，C语言，<a href="http://www.ituring.com.cn/book/655">图灵2006</a>，<a href="http://book.douban.com/subject/1806974/">豆瓣</a>；Java语言，<a href="http://book.douban.com/subject/1218871/">豆瓣</a>：作者TOPLAS杂志主编，介于龙书，鲸书之间，算是实践中有理论</li>
<li>2004、2011，<a href="http://www.cs.rice.edu/~keith/">Cooper</a> &amp; <a href="http://www.cs.rice.edu/~linda/">Torczon</a>，《<strong>编译器设计</strong>》（Engineering a Compiler,<a href="http://www.amazon.com/Engineering-Compiler-Second-Edition-Cooper/dp/012088478X">2nd</a> 2011），<a href="http://book.douban.com/subject/20436488/">豆瓣</a>，<a href="http://book.douban.com/review/5693851/">书评</a>：两位作者均来自Rice Univ，博士导师都为Kennedy</li>
<li>1997，<a href="http://en.wikipedia.org/wiki/Steven_Muchnick">Muchnick</a>，鲸书《<strong>高级编译器设计与实现</strong>》（Advanced Compiler Design and Implementation, <a href="http://amzn.com/1558603204">amazon</a>），<a href="http://book.douban.com/subject/1400374/">豆瓣</a>：名气次于龙书和虎书，内容侧重编译器后端优化</li>
<li>1988、1991、2009，《<strong>编译器构造</strong>》（Crafting a Compiler, <a href="http://dl.acm.org/citation.cfm?id=33462">1st</a> 1988, <a href="http://www.amazon.com/Crafting-Compiler-Charles-N-Fischer/dp/0136067050">3rd</a> 2009），<a href="http://book.douban.com/subject/10772776/">豆瓣</a>：该书不是很出名，但<strong>相对“龙书”和“虎书”读性很高</strong></li>
<li>1996、2011，Richard Jones &amp; etc，《<strong>垃圾回收算法手册</strong>》（The Garbage Collection Handbook, <a href="http://www.amazon.com/dp/1420082795/ref=cm_sw_su_dp">amazon</a>），<a href="http://gchandbook.org/">home</a>，第2版<a href="https://book.douban.com/subject/26740958/">豆瓣</a>：GC最佳书籍</li>
<li>2016，中村成洋，《<strong>垃圾回收的算法与实现</strong>》，<a href="https://book.douban.com/subject/26821357/">豆瓣</a></li>
<li>2001，Allen &amp; <a href="http://en.wikipedia.org/wiki/Ken_Kennedy_%28computer_scientist%29">Kennedy</a>，《现代体系结构的优化编译器》（Optimizing Compilers for Modern Architectures, <a href="http://amzn.com/1558602860">amazon</a>），<a href="http://book.douban.com/subject/1171448/">豆瓣</a>：两位作者均来自Rice Univ，其中Kennedy在1999年获得<a href="http://en.wikipedia.org/wiki/SIGPLAN#Awards">ACM SIGPLAN成就奖</a>，该奖项的第3届得主</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>CS</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 编译器 javac 及 Lombok 实现原理解析</title>
    <url>/2017/04/javac-api/</url>
    <content><![CDATA[<p><code>javac</code> 是 Java 代码的编译器<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，初学 Java 的时候就应该接触过。本文整理一些 <code>javac</code> 相关的高级用法。Lombok 库，大家平常一直在使用，但可能并不知道实现原理解析，其实 Lombok 实现上依赖的是 Java 编译器的注解处理 API（<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR-296</a>）<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，本文同时尝试解析 Lombok 的实现原理。</p>
<span id="more"></span>
<p>先来看下 <code>javac</code> 命令行工具。<code>javac</code> 命令行工具，官方文档有完整的使用说明<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，当然也可以，运行 <code>javac -help</code> 或 <code>man javac</code> 查看帮助信息。下面是经典的 <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">hello world</a> 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree   <span class="comment"># 代码目录结构</span></span></span><br><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── example</span><br><span class="line">        │           └── Greeting.java</span><br><span class="line">        └── resources</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p target/classes   <span class="comment"># 创建 class 文件的存放目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -d target/classes src/main/java/com/example/Greeting.java</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -<span class="built_in">cp</span> target/classes com.example.Greeting</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>除了使用命令行工具编译 Java 代码，JDK 6 增加了规范“<a href="https://jcp.org/en/jsr/detail?id=199">JSR-199</a>: Java Compiler API”和“<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR-296</a>: Pluggable Annotation Processing API”，开始还提供相关的 Java 编译器 API。Java 编译器的实现代码和 API 的整体结构如图所示<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：</p>
<p><img src="https://static.nullwy.me/2017-04-24-1492606028088_5.png" alt="Compiler Package Overview"></p>
<p><span style="background-color: #cbe29a">绿色</span>标注的包是官方 API（Official API），即 JSR-199 和 JSR-296，<span style="background-color: #e4e48a;">黄色</span>标注的包为Supported API，<span style="background-color: #ccccff">紫色</span>标注的包代码全部在 <code>com.sun.tools.javac.*</code> 包下，为内部 API（Internal API）和实现类。完整的包说明如下<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">[2:2]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5:1">[5:1]</a></sup><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/package-summary.html">javax.annotation.processing</a> - 注解处理 (<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR-296</a>)</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/package-summary.html">javax.lang.model</a> - 注解处理和编译器 Tree API 使用的语言模型 (<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR-296</a>)
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/package-summary.html">javax.lang.model.element</a> - 语言元素。主要包含 <code>Element</code> 及其子类</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/type/package-summary.html">javax.lang.model.type</a> - 类型。主要包含 <code>TypeMirror</code> 及其子类</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/lang/model/util/package-summary.html">javax.lang.model.util</a> - 语言模型工具。包含 <code>Elements</code>、<code>Types</code> 等类</li>
</ul>
</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/tools/package-summary.html">javax.tools</a> - Java 编译器 API (<a href="https://jcp.org/en/jsr/detail?id=199">JSR-199</a>)</li>
<li><a href="http://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/index.html">com.sun.source.*</a> - 编译器的 Tree API，支持对抽象语法树做<strong>只读访问</strong></li>
<li><a href="https://www.javadoc.io/static/org.kohsuke.sorcerer/sorcerer-javac/0.11/index.html?com/sun/tools/javac/package-summary.html">com.sun.tools.javac.*</a> - 内部 API 和实现类
<ul>
<li><code>com.sun.tools.javac.api</code> - <code>javax.tools</code> 包下的 <code>JavaCompiler</code> 和其他 API 的实现</li>
<li><code>com.sun.tools.javac.code</code> - <code>javax.lang.model.*</code> 包下的 API 的实现</li>
<li><code>com.sun.tools.javac.comp</code> - 编译器主要处理阶段的实现</li>
<li><code>com.sun.tools.javac.file</code> - 实现访问文件系统，包括 <code>javax.tools.StandardFileManager</code> 的实现</li>
<li><code>com.sun.tools.javac.jvm</code> - class 文件的读写，编译器的字节码生成阶段的实现</li>
<li><code>com.sun.tools.javac.main</code> - 代码编译的入口实现</li>
<li><code>com.sun.tools.javac.model</code> - <code>javax.lang.model.*</code> 包的其他实现</li>
<li><code>com.sun.tools.javac.parser</code> - 读取 Java 源代码，并生成语法树</li>
<li><code>com.sun.tools.javac.processing</code> - 注解处理 API 的实现</li>
<li><code>com.sun.tools.javac.resources</code> - 本地化文本和版本号的资源文件</li>
<li><code>com.sun.tools.javac.tree</code> - 编译器语法树相关的表示类和工具类，<code>com.sun.source.*</code> 包下的 API 的实现</li>
<li><code>com.sun.tools.javac.util</code> - 基础工具类</li>
</ul>
</li>
</ul>
<p>全部源码都位于 JDK 源码的 <a href="https://github.com/openjdk/jdk8u/tree/master/langtools">langtools</a> 目录下。对外的 API，被编译到 <code>rt.jar</code>，<code>com.sun.source.*</code> 和 <code>com.sun.tools.javac.*</code> 包，被编译到 <code>tools.jar</code>，在 JDK 下的具体位置是 <code>$JAVA_HOME\lib\tools.jar</code>。值得一提的是，<code>langtools</code> 目录，除了包含 <code>javac</code> 的实现外，还实现了 <code>javadoc</code>、<code>javah</code> 等命令，编译后也是在 <code>tools.jar</code> 下。</p>
<p>另外，由于是内部 API 和实现类，<code>com.sun.tools.javac.*</code> 包下全部代码中都有标注警告：</p>
<blockquote>
<p>This is NOT part of any supported API. If you write code that depends on this, you do so at your own risk. This code and its internal interfaces are subject to change or deletion without notice.</p>
</blockquote>
<h1 id="Java-编译器-API">Java 编译器 API</h1>
<p>首先，看下 <a href="https://jcp.org/en/jsr/detail?id=199">JSR-199</a> 引入的 Java 编译器 API（Java Compiler API）。在没有引入 JSR-199 之前，如果要通过编程方式编译 Java 代码，只能使用 <code>com.sun.tools.javac.*</code> 包下提供内部 API。上文提到的使用命令 <code>javac</code> 编译 <code>Greeting.java</code> 的等价写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.javac.main.Main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavacMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">compiler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>(<span class="string">&quot;javac&quot;</span>);</span><br><span class="line">        compiler.compile(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;src/main/com/example/Greeting.java&quot;</span>, <span class="string">&quot;-d&quot;</span>, <span class="string">&quot;target/classes&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，<code>javac</code> 命令的底层实现就是执行 <a href="https://github.com/openjdk/jdk8u/blob/master/langtools/src/share/classes/com/sun/tools/javac/Main.java">com.sun.tools.javac.Main</a> 类。执行 <code>javac</code> 命令，等价于执行 <code>java -cp $JAVA_HOME/lib/tools.jar com.sun.tools.javac.Main</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接执行 com.sun.tools.javac.Main 类编译 Java 源代码</span></span><br><span class="line">java -<span class="built_in">cp</span> <span class="variable">$JAVA_HOME</span>/lib/tools.jar com.sun.tools.javac.Main -d target/classes src/main/java/com/example/Greeting.java</span><br></pre></td></tr></table></figure>
<p>JSR-199，提供了 Java 编译器 API，对应的是 <code>javax.tools.*</code> 包。阅读包的 <a href="https://docs.oracle.com/javase/8/docs/api/javax/tools/package-summary.html#package.description">javadoc</a> 容易发现，API 最核心是 <a href="https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.html">javax.tools.JavaCompiler</a> 接口，该类的 javadoc 阐述了如何使用该类，可以阅读。使用 Java 编译器 API 编译 Java 源代码，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.tools.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jsr199Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">JavaCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = <span class="keyword">new</span> <span class="title class_">DiagnosticCollector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">StandardJavaFileManager</span> <span class="variable">fileManager</span> <span class="operator">=</span> compiler.getStandardFileManager(diagnostics, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/main/java/com/example/Greeting.java&quot;</span>);</span><br><span class="line">        Iterable&lt;? <span class="keyword">extends</span> <span class="title class_">JavaFileObject</span>&gt; compilationUnits = fileManager.getJavaFileObjectsFromFiles(Arrays.asList(file));</span><br><span class="line">        List&lt;String&gt; options = Arrays.asList(<span class="string">&quot;-d&quot;</span>, <span class="string">&quot;target/classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">        compiler.getTask(<span class="literal">null</span>, fileManager, diagnostics, options, <span class="literal">null</span>, compilationUnits).call();</span><br><span class="line"></span><br><span class="line">        fileManager.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两种编程方式编译 Java 代码的方式，在 <code>javac</code> 命令的 man<sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup> 文档的 “Programmatic Interface” 小节也有提及，有兴趣可以阅读。</p>
<p>在实际开发过程中，我们基本上都是使用 Maven 或 Gradle 编译 Java 代码。Maven 编译 Java 代码，依赖的是 Maven 的 <code>maven-compiler-plugin</code> 插件。那么 <code>maven-compiler-plugin</code> 插件底层实现是否使用了 <code>javax.tools.JavaCompiler</code> 呢？查阅官网文档后，容易发现实际情况和猜想的一样（其实也是显而易见的结论） [<a href="https://maven.apache.org/plugins/maven-compiler-plugin/">doc</a>]：</p>
<blockquote>
<p>The Compiler Plugin is used to compile the sources of your project. Since 3.0, the default compiler is <code>javax.tools.JavaCompiler</code> (if you are using java 1.6) and is used to compile Java sources. If you want to force the plugin using javac, you must configure the plugin option <code>forceJavacCompilerUse</code>.</p>
</blockquote>
<p>类似的，Gradle 编译 Java 代码，底层也使用了 Java 编译器 API，可以参见源码 <code>JdkJavaCompiler</code> [<a href="https://github.com/gradle/gradle/blob/v7.5.0/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/JdkJavaCompiler.java">github</a>]。</p>
<h1 id="javac-的编译过程">javac 的编译过程</h1>
<p>上文提到，<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR-269</a>，可插拔式注解处理 API（Pluggable Annotation Processing API）。注解处理，是编译过程中的其中一个阶段。要理解注解处理，需要先了解 Java 代码的编译过程。完整的编译过程如下图所示<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>：</p>
<p><img src="https://static.nullwy.me/2017-04-24-javac-flow.png" alt="javac-flow.png"></p>
<p>整个过程就是：</p>
<ol>
<li>源代码经过词法解析和语法解析（parse），生成抽象语法树（abstract syntax tree）。然后遍历抽象语法树，将遇到的符号填充入符号表（enter symbol table）。</li>
<li>注解处理（annotation processing），所有注解处理器会被处理，若处理器生成新的代码或 class 文件，编译过程会重新开始，直到没有新的文件生成。每一次循环称为一个 round，也就是上图的回环过程。</li>
<li>语义分析和字节码生成，包括标注（attribute）、数据及控制流分析（flow）、解语法糖（desugar）、字节码生成（generate）。</li>
</ol>
<p>把上述编译过程对应到代码中，javac 编译动作的入口是 <a href="https://www.javadoc.io/static/org.kohsuke.sorcerer/sorcerer-javac/0.11/com/sun/tools/javac/main/JavaCompiler.html">com.sun.tools.javac.main.JavaCompiler</a> 类，上述 3 个过程的代码逻辑集中在这个类的 compile(）和 compile2(）方法，如下图所示，整个编译过程主要的处理由图中标注的 8 个方法来完成<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>：</p>
<img width="700" alt="JavaCompiler compile" title="JavaCompiler compile" src="https://static.nullwy.me/JavaCompiler-compile.png">
<p>具体来看下，词法解析和语法解析。Java 的词法和语法规则，在《Java语言规范》（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html">The Java Language Specification</a>）中定义。从底层实现上来看，<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/parser/Scanner.html">com.sun.tools.javac.parser.Scanner</a> 类，按照单个字符的方式读取 Java 源文件中的关键字和标示符等内容，然后将其转换为符合 Java 语法规范（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html">JLS ch3</a>）的 <a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/parser/Tokens.Token.html">Token</a> 序列。例如，针对语句 <code>int y = x + 1;</code> 的词法解析过程如下图所示<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>：</p>
<img width="700" alt="词法解析" title="词法解析" src="https://static.nullwy.me/javac-scanner.png">
<p>然后，<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/parser/JavacParser.html">com.sun.tools.javac.parser.JavacParser</a> 类，读取 Token 序列，将 Token 序列构造为抽象语法树 <a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/JCTree.html">com.sun.tools.javac.tree.JCTree</a>。语句 <code>int y = x + 1;</code>，生成的抽象语法树，如下图所示<sup class="footnote-ref"><a href="#fn9" id="fnref9:1">[9:1]</a></sup>：</p>
<img width="650" alt="抽象语法树" title="抽象语法树" src="https://static.nullwy.me/javac-syntax-tree.png">
<p>该语句对应的 <code>JCTree.JCVariableDecl</code> 对象，在 IDEA 的 debug 模式下查看，如下图所示：</p>
<img width="400" alt="IDEA debug" title="IDEA debug" src="https://static.nullwy.me/idea-debug-watch.png">
<p>语法树中的每一个语法节点，实际上都直接或者间接地继承了 <code>JCTree</code> 类，并且都以静态内部类的形式定义在 <code>JCTree</code> 类中。Java 源文件的完整的词法解析和语法解析，由 <code>JavacParser</code> 的 <code>parseCompilationUnit</code> 方法完成。解析完成后，方法返回 <code>JCTree.JCCompilationUnit</code> 类。<code>JCTree.JCCompilationUnit</code> 类，为某个 Java 源文件解析后的整个语法树的根节点。</p>
<p>上文提到，<code>com.sun.source.*</code> 包下暴露的 Tree API，提供对语法树只能做只读操作。<code>com.sun.tools.javac.tree</code> 包，是 <code>com.sun.source.*</code> 包下的 API 的实现。<code>com.sun.source.tree.Tree</code> 接口对应的实现类为 <code>JCTree</code>，<code>Tree</code> 的子接口的实现类为 <code>JCTree</code> 的子类，并一一对应，比如，<code>com.sun.source.tree.ClassTree</code> 对应的实现类为 <code>JCTree.JCClassDecl</code>。<code>Tree</code> 接口及其子接口只暴露只读方法，而 <code>JCTree</code> 类及其子类，大部分的内部定义字段都是 <code>public</code>，可以直接读写。</p>
<p>主要的语法树节点 <code>JCTree</code> 子类，如下：</p>
<ul>
<li>JCTree.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/JCTree.JCStatement.html">JCStatement</a>：声明语句的语法树节点。主要的子类包括：
<ul>
<li><code>JCTree.JCBlock</code>：语句块（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.2">JLS 14.2</a>）</li>
<li><code>JCTree.JCClassDecl</code>：类声明（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.1">JLS 8.1</a>）</li>
<li><code>JCTree.JCForLoop</code>：<code>for</code> 语句（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.1">JLS 14.14.1</a>）</li>
<li><code>JCTree.JCEnhancedForLoop</code>：增强for语句（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2">JLS 14.14.2</a>）</li>
<li><code>JCTree.JCIf</code>：<code>if</code> 语句（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.9">JLS 14.9</a>）</li>
<li><code>JCTree.JCReturn</code>：<code>return</code> 语句（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.17">JLS 14.7</a>）</li>
<li><code>JCTree.JCVariableDecl</code>：变量声明，比如 <code>int x = 0</code> 语句（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.4">JLS 14.4</a>）</li>
<li>其他（不一一列举）</li>
</ul>
</li>
<li>JCTree.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/JCTree.JCExpression.html">JCExpression</a>：表达式的语法树节点。主要的子类包括：
<ul>
<li><code>JCAssign</code>：赋值语句表达式，比如 <code>x = 0</code> 语句（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26">JLS 15.26</a>）</li>
<li><code>JCIdent</code>：标识符表达式，比如 <code>x</code> 标识符（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8">JLS 3.8</a>）</li>
<li><code>JCBinary</code>：二元运算符，比如 <code>x + 1</code> 语句（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.18">JLS 15.18</a>）</li>
<li><code>JCLiteral</code>：字面量运算符表达式，比如 <code>1</code> 字面量（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10">JLS 3.10</a>）</li>
<li><code>JCTree.JCPrimitiveTypeTree</code>：基础类型，比如 <code>int</code> 等类型（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2">JLS 4.2</a>）</li>
</ul>
</li>
<li>JCTree.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/JCTree.JCMethodDecl.html">JCMethodDecl</a>：方法声明（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4">JLS 8.4</a>）</li>
<li>JCTree.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/JCTree.JCCompilationUnit.html">JCCompilationUnit</a>：编译单元，对应单个源文件内的全部内容（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-7.html#jls-7.3">JLS 7.3</a>）</li>
</ul>
<p>全部的各个类型的树节点的类定义，可以参见 <code>JCTree</code> 和 <code>Tree</code> 类的 javadoc 或源代码。</p>
<p>在构造抽象语法树后，就是符号表填充阶段。在符号表填充阶段，会扫描 <code>JCTree</code> 语法树，遇到类型、变量、方法定义时，会它们的信息存储到符号表中，方便后续阶段进行快速查询。符号，对应的是 <code>com.sun.tools.javac.code.Symbol</code> 类。而 <code>Symbol</code> 类，是 <code>javax.lang.model</code> 包下 <code>Element</code> 的实现类，<code>Symbol</code> 子类是对应 <code>Element</code> 子类的实现。</p>
<p><code>Element</code> 提供 <code>ElementKind getKind()</code> 方法，能获取元素类型（<code>ElementKind</code>）。全部的 <code>ElementKind</code> 共 17 种：<code>ANNOTATION_TYPE</code>（注解）、<code>CLASS</code>（类）、<code>CONSTRUCTOR</code>（构造方法）、<code>ENUM</code>（枚举）、<code>ENUM_CONSTANT</code>（枚举值）、<code>EXCEPTION_PARAMETER</code>（异常参数）、<code>FIELD</code>（字段）、<code>INSTANCE_INIT</code>（实例初始化语句块）、<code>INTERFACE</code>（接口）、<code>LOCAL_VARIABLE</code>（本地变量）、<code>METHOD</code>（方法）、<code>PACKAGE</code>（包）、<code>PARAMETER</code>（参数）、<code>RESOURCE_VARIABLE</code>（资源变量）、<code>STATIC_INIT</code>（静态初始化语句块）、<code>TYPE_PARAMETER</code>（类型参数） 以及 <code>OTHER</code>（其他）。</p>
<p>全部 <code>Element</code> 子类以及对应的 <code>Symbol</code> 子类，如下：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/PackageElement.html">PackageElement</a>：表示包 package
<ul>
<li>实现类：<code>Symbol.PackageSymbol</code></li>
<li>元素类型 <code>ElementKind</code>：<code>PACKAGE</code>（包）</li>
</ul>
</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/TypeElement.html">TypeElement</a>：表示类 class 或接口 interface 等
<ul>
<li>实现类：<code>Symbol.ClassSymbol</code></li>
<li>元素类型 <code>ElementKind</code>：<code>ANNOTATION_TYPE</code>（注解）、<code>INTERFACE</code>（接口）、<code>ENUM</code>（枚举）、<code>CLASS</code>（类）</li>
</ul>
</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/VariableElement.html">VariableElement</a>：表示字段、枚举值、方法参数、本地变量、资源变量、异常参数
<ul>
<li>实现类：<code>Symbol.VarSymbol</code></li>
<li>元素类型 <code>ElementKind</code>：<code>EXCEPTION_PARAMETER</code>（异常参数）、<code>PARAMETER</code>（参数）、<code>ENUM_CONSTANT</code>（枚举值）、<code>RESOURCE_VARIABLE</code>（资源变量）、<code>LOCAL_VARIABLE</code>（本地变量）、<code>FIELD</code>（字段）</li>
</ul>
</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/ExecutableElement.html">ExecutableElement</a>：表示方法、构造方法、初始化语句块
<ul>
<li>实现类：<code>Symbol.MethodSymbol</code></li>
<li>元素类型 <code>ElementKind</code>：<code>CONSTRUCTOR</code>（构造方法）、<code>STATIC_INIT</code>（静态初始化语句块）、<code>INSTANCE_INIT</code>（实例初始化语句块）、<code>METHOD</code>（方法）</li>
</ul>
</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/TypeParameterElement.html">TypeParameterElement</a>：表示参数化类型，即泛型尖括号内的类型
<ul>
<li>实现类：<code>Symbol.TypeVariableSymbol</code></li>
<li>元素类型 <code>ElementKind</code>：<code>TYPE_PARAMETER</code>（类型参数）</li>
</ul>
</li>
</ul>
<p>在填充符号表后，就是语义分析和代码生成，包括标注（attribute）、数据及控制流分析（flow）、解语法糖（desugar）、字节码生成（generate）阶段。</p>
<p>在实际开发时，比如常见的“找不到符号（cannot find symbol）”编译报错，就是在标注阶段的名称消解（name resolution）时触发的。编译报错示例代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CantResolve</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译错误的提示内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找不到符号</span><br><span class="line">  符号:   变量 bar</span><br><span class="line">  位置: 类 CantResolve</span><br></pre></td></tr></table></figure>
<p>编译过程的各个阶段的更详细的阐述可以阅读书籍<sup class="footnote-ref"><a href="#fn8" id="fnref8:1">[8:1]</a></sup><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>，本文不再展开。</p>
<h1 id="可插拔式注解处理-API">可插拔式注解处理 API</h1>
<p>JSR-296 定义的可插拔式注解处理 API 在 <code>javax.annotation.processing</code> 包下，最核心的接口是 <a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html">javax.annotation.processing.Processor</a>，通过实现这个接口来定义自己的注解处理器。</p>
<p>编译器工具与 <code>Processor</code> 实现类的交互过程是：</p>
<ul>
<li>如果存在没有被使用的 <code>Processor</code> 对象，就调用无参构造方法创建一个 <code>Processor</code> 实例。</li>
<li>然后，编译器工具调用注解处理器的 <a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html#init-javax.annotation.processing.ProcessingEnvironment-">init</a> 方法，初始化注解处理器，方法参数是 <code>ProcessingEnvironment</code> 对象（注解处理的执行环境，从环境中获得相关工具类，比如 <code>Elements</code>）。</li>
<li>之后，编译器工具调用注解处理器的 <a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes--">getSupportedAnnotationTypes</a>（查询该注解处理器支持的注解集合）、<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions--">getSupportedOptions</a>（查询该注解处理器支持的参数选项集合）、<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html#getSupportedSourceVersion--">getSupportedSourceVersion</a>（查询该注解处理器支持的源代码版本）方法。</li>
<li>最后，调用注解处理器的 <a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html#process-java.util.Set-javax.annotation.processing.RoundEnvironment-">process</a> 方法。</li>
</ul>
<p>注解处理会执行多轮（round），每轮都会调用 <code>process</code> 方法，调用时传入在上一轮的源代码和 class 文件中找到的该注解处理器支持的注解子集。在处理注解期间，如果任何注解处理器生成了新的源文件或 class 文件，编译器将回到解析、填充符号表、注解处理的过程，直到没有新的文件生成。</p>
<p><code>init</code> 方法的参数 <code>ProcessingEnvironment</code> 对象，为注解处理的执行环境，从环境中获得相关工具类，比如，<code>Elements</code> 类，用于操作 <code>Element</code> 元素；<code>Filer</code> 类，用于生成新的文件；<code>Messager</code> 类，用于报告编译错误、告警或其他消息。另外，<code>ProcessingEnvironment</code>，也可以获得传递给注解处理器参数选项。</p>
<p><code>AbstractProcessor</code> 抽象类，实现类了 <code>Processor</code> 接口，用于简化实际的注解处理器类的实现。该类通过读取 <code>@SupportedAnnotationTypes</code>、<code>@SupportedOptions</code>、<code>@SupportedSourceVersion</code> 注解值，来实现 <code>Processor</code> 接口对应的三个方法。</p>
<p>用命令行编译代码时，<code>javac</code> 编译器，会搜索可用的注解处理器。搜索路径可以通过参数选项 <code>-processorpath</code> 指定，如果未指定，将使用 <code>classpath</code>。注解处理器，可以通过 <code>-processor</code> 参数选项指定。若未通过 <code>-processor</code> 参数选项指定，注解处理器会使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">SPI</a> 方式定位，在搜索路径查找 <code>META-INF/services/javax.annotation.processing.Processor</code> 文件。文件中填写的是注解处理器类名（多个的话，换行填写），编译器就会自动使用这里填写的注解处理器进行注解处理。另外，编译器 API 的 <code>CompilationTask</code> 的 <code>setProcessors</code> 方法也可以传入注解处理器。</p>
<p>如果注解处理器支持参数选项，编译时，参数选项可以用 <code>-Akey[=value]</code> 的方式传递<sup class="footnote-ref"><a href="#fn4" id="fnref4:2">[4:2]</a></sup>。</p>
<h2 id="扫描语法树">扫描语法树</h2>
<p>JDK 源码的 <code>langtools</code> 目录下，提供了示例注解处理器 <a href="https://github.com/openjdk/jdk8u/blob/master/langtools/src/share/sample/javac/processing/src/CheckNamesProcessor.java">CheckNamesProcessor</a>，一个检查命名的注解处理器。<code>CheckNamesProcessor</code> 注解处理器，内部实现了 <code>javax.lang.model.util</code> 包下 <a href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/util/ElementScanner8.html">ElementScanner</a>，用来扫描 <code>Element</code> 元素符号，然后检查类命名、方法命名、字段命名、参数命名等是否符合命名规范，如果不符合命名规范，就打印编译器告警。</p>
<p><code>javax.lang.model.util.ElementScanner8</code> 类用于扫描 <code>Element</code> 的核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> R <span class="title function_">scan</span><span class="params">(Element e)</span></span><br></pre></td></tr></table></figure>
<p>对语法树的扫描，<code>com.sun.source.util</code> 包下，提供了语法树扫描器 <a href="http://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/TreeScanner.html">TreeScanner</a>，用于扫描语法树上的树节点 <code>Tree</code>。类似的，<code>com.sun.tools.javac.tree.TreeScanner</code>，用于扫描语法树上的树节点 <code>JCTree</code>。</p>
<p><code>com.sun.source.util.TreeScanner</code> 类用于扫描语法树的核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> R <span class="title function_">scan</span><span class="params">(Tree node, P p)</span></span><br></pre></td></tr></table></figure>
<p><code>com.sun.tools.javac.tree.TreeScanner</code> 类用于扫描语法树的核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(JCTree tree)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，注解处理器的 <code>process</code> 方法，传递过来的是 <code>Element</code> 对象，需要先获得 <code>Element</code> 对象关联的 <code>Tree</code> 或 <code>JCTree</code> 对象，才能扫描语法树。工具类 <code>com.sun.source.util.Trees</code> 提供了这样的桥接能力，该类的实现类为 <code>com.sun.tools.javac.api.JavacTrees</code>。<code>Trees</code> 的相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ProcessingEnvironment 获得 Trees 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Trees <span class="title function_">instance</span><span class="params">(ProcessingEnvironment env)</span></span><br><span class="line"><span class="comment">// 通过 Element 获得 Tree</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Tree <span class="title function_">getTree</span><span class="params">(Element element)</span>;</span><br></pre></td></tr></table></figure>
<p>类似的，<code>JavacTrees</code> 的相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ProcessingEnvironment 获得 JavacTrees 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JavacTrees <span class="title function_">instance</span><span class="params">(ProcessingEnvironment env)</span></span><br><span class="line"><span class="comment">// 通过 Element 获得 JCTree</span></span><br><span class="line"><span class="keyword">public</span> JCTree <span class="title function_">getTree</span><span class="params">(Element element)</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>ElementScanner</code> 或 <code>TreeScanner</code> 扫描语法树的示例注解处理器，参见 <a href="https://github.com/yulewei/annotation-processor-demo/blob/master/processor-demo/src/main/java/com/example/visitor/VisitorProcessor.java">VisitProcessor</a>。</p>
<h2 id="修改语法树">修改语法树</h2>
<p>在语法解析时，<code>JavacParser</code> 类，底层实现上利用 <a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/TreeMaker.html">TreeMaker</a> 类构造的语法树各个节点。<code>TreeMaker</code> 类，封装了创建语法树节点的方法，部分常用的方法举例：</p>
<ul>
<li>TreeMaker.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/TreeMaker.html#Assign-com.sun.tools.javac.tree.JCTree.JCExpression-com.sun.tools.javac.tree.JCTree.JCExpression-">Assign</a> 方法：用于生成赋值语句的语法树节点 <code>JCTree.JCAssign</code>。</li>
<li>TreeMaker.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/TreeMaker.html#Binary-com.sun.tools.javac.tree.JCTree.Tag-com.sun.tools.javac.tree.JCTree.JCExpression-com.sun.tools.javac.tree.JCTree.JCExpression-">Binary</a> 方法：用于生成二元操作符的语法树节点 <code>JCTree.JCBinary</code>。</li>
<li>TreeMaker.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/TreeMaker.html#Block-long-com.sun.tools.javac.util.List-">Block</a> 方法：用于生成语句块的语法树节点 <code>JCTree.JCBlock</code>。</li>
<li>TreeMaker.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/TreeMaker.html">VarDef</a> 方法：用于生成变量定义的语法树节点 <code>JCTree.JCVariableDecl</code>。</li>
<li>TreeMaker.<a href="https://www.javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/tree/TreeMaker.html">MethodDef</a> 方法：用于生成方法定义的语法树节点 <code>JCTree.JCMethodDecl</code>。</li>
<li>等等</li>
</ul>
<p>在注解处理阶段，<code>init</code> 方法传入了 <code>ProcessingEnvironment</code> 对象，通过该对象可以获得当前上下文中的 <code>TreeMaker</code> 对象，然后就可以利用 <code>TreeMaker</code> 创建新的语法树节点。</p>
<p>语句 <code>int y = x + 1;</code>，使用 <code>TreeMaker</code> 构造对应的 <code>JCTree.JCVariableDecl</code>，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Name</span> <span class="variable">x</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">Name</span> <span class="variable">y</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="comment">// x + 1</span></span><br><span class="line">JCTree.<span class="type">JCBinary</span> <span class="variable">binary</span> <span class="operator">=</span> maker.Binary(JCTree.Tag.PLUS, maker.Ident(x), maker.Literal(TypeTag.INT, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// int y = x + 1</span></span><br><span class="line">JCTree.<span class="type">JCVariableDecl</span> <span class="variable">decl</span> <span class="operator">=</span> maker.VarDef(maker.Modifiers(<span class="number">0</span>), y, maker.TypeIdent(TypeTag.INT), binary);</span><br></pre></td></tr></table></figure>
<p>因为 <code>JCTree</code> 类及其子类的大部分的内部定义字段都是 <code>public</code>，可以直接读写，所以要想<strong>修改语法树</strong>，可以直接相关字段的值。比如，把 <code>int y = x + 1</code> 语句对应的 <code>JCTree.JCVariableDecl</code> 树节点改为 <code>int y = 42</code>，可以直接修改 <code>JCTree.JCVariableDecl</code> 的 <code>init</code> 字段，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JCTree.<span class="type">JCVariableDecl</span> <span class="variable">decl</span> <span class="operator">=</span> ...</span><br><span class="line">decl.init = maker.Literal(TypeTag.INT, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>修改语法树的示例代码，参见 <a href="https://github.com/yulewei/annotation-processor-demo/blob/master/processor-demo/src/main/java/com/example/maker/PlusProcessor.java">PlusProcessor</a> 注解处理器。该示例注解处理器，修改 <code>@PlusOne</code> 注解标注的方法的内部实现，改造后的方法的逻辑为，返回请求参数值加 1 后的值。比如，修改语法树前，<code>func</code> 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PlusOne</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被 <code>PlusProcessor</code> 注解处理器修改语法树后，<code>func</code> 方法变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改方法内部实现的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">modifyToPlusOneMethod</span><span class="params">(JCTree.JCMethodDecl methodDecl)</span> &#123;</span><br><span class="line">    JCTree.<span class="type">JCVariableDecl</span> <span class="variable">param</span> <span class="operator">=</span> methodDecl.params.head;</span><br><span class="line">    <span class="comment">// x + 1</span></span><br><span class="line">    JCTree.<span class="type">JCBinary</span> <span class="variable">binary</span> <span class="operator">=</span> maker.Binary(JCTree.Tag.PLUS, maker.Ident(param.name), maker.Literal(TypeTag.INT, <span class="number">1</span>));</span><br><span class="line">    JCTree.<span class="type">JCReturn</span> <span class="variable">ret</span> <span class="operator">=</span> maker.Return(binary);</span><br><span class="line">    <span class="comment">// 修改方法内部实现</span></span><br><span class="line">    methodDecl.body.stats = List.of(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解处理器仅仅用于示例，没有其他实际用途。实际开发中，Lombok 库被广泛使用，其底层实现就是利用注解处理器修改由 Lombok 注解（<code>@Data</code>、<code>@Getter</code>、<code>@Setter</code> 等）标注的代码的语法树，自动生成样板代码。针对 Lombok 库实现原理的解析，参见下文。</p>
<h2 id="创建新文件">创建新文件</h2>
<p>可插拔式注解处理 API，定义了 <code>javax.annotation.processing.Filer</code> 接口，这个接口提供了让注解处理器创建新文件的能力。<code>createSourceFile</code> 方法，用于创建新的源代码文件，<code>createClassFile</code>，用于创建新的 class 文件。</p>
<p>来看下示例代码，<a href="https://github.com/yulewei/annotation-processor-demo/blob/master/processor-demo/src/main/java/com/example/filer/GreetingProcessor.java">GreetingProcessor</a> 注解处理器。该注解处理器功能就是基于 <code>Filer</code> 自动生成 <code>Greeting</code> 类（打印 &quot;hello world&quot;）。核心代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">generateGreeting</span><span class="params">(String className)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="built_in">this</span>.getClass().getResource(<span class="string">&quot;/Greeting.tpl&quot;</span>).toURI()));</span><br><span class="line">    <span class="type">String</span> <span class="variable">greetingTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8);</span><br><span class="line">    <span class="type">String</span> <span class="variable">greetingSourceCode</span> <span class="operator">=</span> String.format(greetingTemplate, LocalDateTime.now(), className);</span><br><span class="line">    <span class="type">JavaFileObject</span> <span class="variable">fileObject</span> <span class="operator">=</span> filer.createSourceFile(className);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fileObject.openWriter())) &#123;</span><br><span class="line">        writer.println(greetingSourceCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板文件 <code>Greeting.tpl</code> 的内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Generated;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Generated(value = &quot;by GreetingProcessor&quot;, date = &quot;%s&quot;)</span></span><br><span class="line"><span class="keyword">public</span> class %s &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，<a href="https://mapstruct.org/">MapStruct</a> 是流行的用于 Bean 之间映射的工具库之一，其底层实现就是基于注解处理器 API。阅读源码，容易发现 MapStruct 库内部实现的注解处理器是 <code>org.mapstruct.ap.MappingProcessor</code>（<a href="https://mapstruct.org/documentation/1.5/api/org/mapstruct/ap/MappingProcessor.html">javadoc</a>、<a href="https://github.com/mapstruct/mapstruct/blob/1.5.x/processor/src/main/java/org/mapstruct/ap/MappingProcessor.java">github</a>）。<code>MappingProcessor</code> 注解处理器生成的 Mapper 实现类，底层调用的就是 <code>Filer</code> 接口的 <code>createSourceFile</code> 方法，参见源代码 <a href="https://github.com/mapstruct/mapstruct/blob/1.5.x/processor/src/main/java/org/mapstruct/ap/internal/processor/MapperRenderingProcessor.java">github</a>。另外，MapStruct 库的注解处理器生成源代码文件利用了模板引擎 FreeMarker 库，可以参见 <a href="https://mapstruct.org/documentation/1.5/api/org/mapstruct/ap/MappingProcessor.html">javadoc</a>、<a href="https://github.com/mapstruct/mapstruct/tree/1.5.x/processor/src/main/resources/org/mapstruct/ap/internal/model">github</a>。</p>
<p>另外值得一提的是，除了模板引擎，生成源代码文件也可以使用 <a href="https://github.com/square/javapoet">JavaPoet</a> 工具库，JavaPoet 库提供 Java API 来生成 <code>.java</code> 源文件。笔者基于 JavaPoet 库，实现了能处理类似 Lombok 的 <code>@Builder</code> 注解的 <a href="https://github.com/yulewei/annotation-processor-demo/blob/master/mylombok/src/main/java/com/example/filer/BuilderProcessor.java">BuilderProcessor</a> 注解处理器，有兴趣的话可以查阅（附注：实际的 Lombok 的 <code>@Builder</code> 注解实现原理是修改语法树，并不是生成新的 <code>Builder</code> 类文件）。</p>
<h1 id="Lombok-的实现原理">Lombok 的实现原理</h1>
<p>依赖 JSR-269 实现的第三方工具库有很多<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>，比如代码自动生成的 <a href="https://projectlombok.org/">Lombok</a>、<a href="https://mapstruct.org/">MapStruct</a> 和 Google <a href="https://github.com/google/auto">Auto</a>，代码检查的 <a href="https://checkerframework.org/">Checker</a> 和 Google <a href="http://errorprone.info/">Error Prone</a>，编译阶段完成依赖注入的 Google <a href="https://github.com/google/dagger">Dagger 2</a> 等。笔者在实际开发中就经常使用 Lombok 库和 MapStruct 库。MapStruct 库的实现原理，上文已经做了简单介绍。现在来看下 Lombok 的实现原理。</p>
<p>Lombok <a href="https://projectlombok.org/features/index.html">提供</a> <code>@NonNull</code>、<code>@Getter</code>, <code>@Setter</code>, <code>@ToString</code>, <code>@EqualsAndHashCode</code>, <code>@Data</code> 等注解，自动生成常见样板代码 boilerplate，解放开发效率。Lombok 支持 javac 和 ecj (Eclipse Compiler for Java)。对于 javac 编译器对应的注解处理器是 <a href="https://github.com/rzwitserloot/lombok/blob/v1.16.10/src/core/lombok/javac/apt/LombokProcessor.java">LombokProcessor</a>，然后经过一些处理过程，每个注解都会有特定的 <a href="https://github.com/rzwitserloot/lombok/tree/v1.16.10/src/core/lombok/javac/handlers">handler</a> 来处理，<code>@NonNull</code> 对应 <code>HandleNonNull</code>、<code>@Getter</code> 对应 <code>HandleGetter</code>、<code>@Setter</code> 对应 <code>HandleSetter</code>、<code>@ToString</code> 对应 <code>HandleToString</code>、<code>@EqualsAndHashCode</code> 对应 <code>HandleEqualsAndHashCode</code>、<code>@Data</code> 对应 <code>HandleData</code>。如果想要改造 Lombok 项目，让 Lombok 支持新的注解，其实就是添加新的 handler。关于 Lombok 原理以及如何为 Lombok 贡献代码，文档 “Documentation for lombok developers”<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>，也有简单介绍，可以阅读。</p>
<p>阅读这些 handler 的实现，可以看到样板代码的生成依赖的就是 <code>com.sun.tools.javac.*</code> 包。最新版的 Lombok 源码太繁杂了，可以从早期版本入手，比如 <a href="https://github.com/projectlombok/lombok/tree/v0.8.1">v0.8.1</a> 版本。</p>
<p>现在来看下如何实现 <code>@Getter</code> 注解。<code>@Getter</code> 注解的功能，就是自动生成类字段的 getter 方法，如果注解加到 class 上，就生成类的全部字段的 getter 方法。假设字段名叫 <code>foo</code>，那边生成的 getter 方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFoo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考 Lombok v0.8.1 和 v0.9.3 的 <a href="https://github.com/projectlombok/lombok/blob/v0.9.3/src/core/lombok/javac/handlers/HandleGetter.java">HandleGetter</a> 实现源码（从 v0.9.3 版本开始，<code>@Getter</code> 注解支持加到 class 上，之前只能加到字段上），提取出其中的核心代码，实现 <code>@Getter</code> 的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleGetter</span><span class="params">(JCTree.JCClassDecl classDecl)</span> &#123;</span><br><span class="line">    List&lt;JCTree&gt; methodDecls = List.nil();</span><br><span class="line">    <span class="keyword">for</span> (JCTree tree : classDecl.defs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree <span class="keyword">instanceof</span> JCTree.JCVariableDecl) &#123;</span><br><span class="line">            <span class="comment">// 创建 getter 方法</span></span><br><span class="line">            JCTree.<span class="type">JCVariableDecl</span> <span class="variable">fieldDecl</span> <span class="operator">=</span> (JCTree.JCVariableDecl) tree;</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodGetterName</span> <span class="operator">=</span> Utils.toGetterName(fieldDecl);</span><br><span class="line">            <span class="keyword">if</span> (!Utils.methodExists(methodGetterName, classDecl)) &#123;</span><br><span class="line">                JCTree.<span class="type">JCMethodDecl</span> <span class="variable">methodGetter</span> <span class="operator">=</span> <span class="built_in">this</span>.createGetter(fieldDecl);</span><br><span class="line">                methodDecls = methodDecls.append(methodGetter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    classDecl.defs = classDecl.defs.appendList(methodDecls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 getter 方法</span></span><br><span class="line"><span class="keyword">private</span> JCTree.JCMethodDecl <span class="title function_">createGetter</span><span class="params">(JCTree.JCVariableDecl field)</span> &#123;</span><br><span class="line">    JCTree.<span class="type">JCStatement</span> <span class="variable">returnStatement</span> <span class="operator">=</span> maker.Return(maker.Ident(field));</span><br><span class="line">    JCTree.<span class="type">JCBlock</span> <span class="variable">methodBody</span> <span class="operator">=</span> maker.Block(<span class="number">0</span>, List.of(returnStatement));</span><br><span class="line">    <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> names.fromString(Utils.toGetterName(field));</span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">methodType</span> <span class="operator">=</span> (JCTree.JCExpression) field.getType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maker.MethodDef(maker.Modifiers(Flags.PUBLIC), methodName, methodType,</span><br><span class="line">            List.nil(), List.nil(), List.nil(), methodBody, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易发现，实现 <code>@Getter</code> 注解依赖的 <code>JCTree</code>、<code>TreeMaker</code> 等相关类，这些类在上文都已经提及并介绍，不再复述。</p>
<p>为了加深对 javac 内部 API 的理解，笔者参考 Lombok 的源码，<strong>实现了支持类似 Lombok 的 <code>@Data</code>、<code>@Getter</code>、<code>@Setter</code>、<code>@Slf4j</code> 注解的注解处理器</strong>，<a href="https://github.com/yulewei/annotation-processor-demo/blob/master/mylombok/src/main/java/com/example/processor/MyLombokProcessor.java">MyLombokProcessor</a>，代码参见 GitHub。</p>
<p><strong>附注</strong>：本文的示例代码的完整代码，都可以在 GitHub 的 annotation-processor-demo<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup> 仓库上找到。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>OpenJDK: The Java programming language Compiler Group <a href="http://openjdk.java.net/groups/compiler/">http://openjdk.java.net/groups/compiler/</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>The Java Programming Language Compiler, javac <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javac/">https://docs.oracle.com/javase/8/docs/technotes/guides/javac/</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2011-05 How does lombok work? <a href="http://stackoverflow.com/q/6107197">http://stackoverflow.com/q/6107197</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>javac <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javac.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javac.html</a> <a href="https://www.mankier.com/1/javac">https://www.mankier.com/1/javac</a> <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a> <a href="#fnref4:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>OpenJDK: Compiler Package Overview <a href="https://openjdk.org/groups/compiler/doc/package-overview/index.html">https://openjdk.org/groups/compiler/doc/package-overview/index.html</a> <a href="#fnref5" class="footnote-backref">↩︎</a> <a href="#fnref5:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>OpenJDK: The Hitchhiker's Guide to javac <a href="https://openjdk.org/groups/compiler/doc/hhgtjavac/index.html">https://openjdk.org/groups/compiler/doc/hhgtjavac/index.html</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>OpenJDK: Compilation Overview <a href="https://openjdk.org/groups/compiler/doc/compilation-overview/index.html">https://openjdk.org/groups/compiler/doc/compilation-overview/index.html</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>深入理解Java 7虚拟机，周志明 第2版2013：第10章 早期 (编译期) 优化 <a href="#fnref8" class="footnote-backref">↩︎</a> <a href="#fnref8:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>莫枢 RednaxelaFX ：JVM分享——Java程序的编译、加载与执行 <a href="http://www.valleytalk.org/2011/07/28/java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%EF%BC%8C%E5%8A%A0%E8%BD%BD-%E5%92%8C-%E6%89%A7%E8%A1%8C/">http://www.valleytalk.org/2011/07/28/java-程序的编译，加载-和-执行/</a> <a href="#fnref9" class="footnote-backref">↩︎</a> <a href="#fnref9:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>深入解析Java编译器：源码剖析与实例详解，马智 2019 <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Awesome Java Annotation Processing <a href="https://github.com/gunnarmorling/awesome-annotation-processing">https://github.com/gunnarmorling/awesome-annotation-processing</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Documentation for lombok developers <a href="https://projectlombok.org/contributing/">https://projectlombok.org/contributing/</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>annotation-processor-demo <a href="https://github.com/yulewei/annotation-processor-demo">https://github.com/yulewei/annotation-processor-demo</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>编译器</tag>
        <tag>javac</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 生成器的表注释</title>
    <url>/2016/12/mybatis-generator/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/MyBatis">MyBatis</a>是流行的持久化框架，通过抽象底层的JDBC代码，在类对象和数据库列之间自动映射SQL的参数和结果，以SQL为映射的间接层，实现SQL映射器。<a href="http://www.mybatis.org/generator/">MyBatis Generator</a> (MBG) 是一个Mybatis的代码生成器，内省数据库的表，然后自动生成映射表的实体类，并生成CRUD（插入，查询，更新，删除）操作的样板代码。MyBatis，之前所在的公司在用，生成器也在用。虽然生成器大大提供了开发效率，但生成的代码可读性比较低，尤其是自动生成的实体类，如下：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This field was generated by MyBatis Generator. This field corresponds to the database column author.book_id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@mbggenerated</span>  Tue Jan 19 13:37:24 CST 2016</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Integer bookId;</span><br></pre></td></tr></table></figure>
<p>这些自动生成注释，没有实质性信息，其实真正有用的是，设计表时，该字段的用途，即表字段的注释。</p>
<h1 id="addRemarkComments选项">addRemarkComments选项</h1>
<p>庆幸的是，MyBatis生成器在版本1.3.3中添加了，<code>addRemarkComments</code>选项 [<a href="https://github.com/mybatis/generator/issues/23">github</a>]，可以在生成的实体类中附带表字段的注释。<code>addRemarkComments</code>官方文档的介绍 [<a href="http://www.mybatis.org/generator/configreference/commentGenerator.html">doc</a>]：</p>
<blockquote>
<p>This property is used to specify whether MBG will include table and column remarks from db table in the generated comments. The property supports these values:</p>
<ul>
<li><strong>false</strong>: <em>This is the default value</em> When the property is false or unspecified, all generated comments will <strong>not</strong> include table and column remarks from db table when the element was generated.</li>
<li><strong>true</strong>: When the property is true, table and columns remarks from db table will be added to the generated comments.</li>
</ul>
<p><strong>Warning:</strong> If suppressAllComments option is true, this option will be ignored.</p>
</blockquote>
<p>使用方法很简单，只需将MyBatis生成器的配置文件中的<code>commentGenerator</code>节点修改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addRemarkComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="自定义注释生成器类">自定义注释生成器类</h1>
<p>通过<code>addRemarkComments</code>选项生成的实体类的注释不够精简。于是笔者参考MyBatis的默认的注释生成器<code>DefaultCommentGenerator</code>[<a href="https://github.com/mybatis/generator/blob/master/core/mybatis-generator-core/src/main/java/org/mybatis/generator/internal/DefaultCommentGenerator.java">github</a>]，对其进行改造成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.mbg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.IntrospectedColumn;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.IntrospectedTable;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.dom.java.Field;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.dom.java.JavaElement;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.dom.java.Method;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.dom.java.TopLevelClass;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.MergeConstants;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultCommentGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.util.StringUtility;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 官方类似的功能见，在版本1.3.3中添加的 addRemarkComments &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * http://www.mybatis.org/generator/configreference/commentGenerator.html &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * https://github.com/mybatis/generator/issues/23</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultCommentGenerator#addRemarkComments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemarksCommentGenerator</span> <span class="keyword">extends</span> <span class="title class_">DefaultCommentGenerator</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addModelClassComment</span><span class="params">(TopLevelClass topLevelClass, IntrospectedTable introspectedTable)</span> &#123;</span><br><span class="line">        topLevelClass.addJavaDocLine(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">remarks</span> <span class="operator">=</span> introspectedTable.getRemarks();</span><br><span class="line">        <span class="keyword">if</span> (StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            String[] remarkLines = remarks.split(System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (String remarkLine : remarkLines) &#123;</span><br><span class="line">                topLevelClass.addJavaDocLine(<span class="string">&quot; * &quot;</span> + remarkLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        topLevelClass.addJavaDocLine(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">        sb.append(introspectedTable.getFullyQualifiedTable());</span><br><span class="line">        topLevelClass.addJavaDocLine(sb.toString());</span><br><span class="line">        topLevelClass.addJavaDocLine(<span class="string">&quot; *&quot;</span>);</span><br><span class="line">        addJavadocTag(topLevelClass, <span class="literal">false</span>);</span><br><span class="line">        topLevelClass.addJavaDocLine(<span class="string">&quot; */&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFieldComment</span><span class="params">(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn)</span> &#123;</span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">remarks</span> <span class="operator">=</span> introspectedColumn.getRemarks();</span><br><span class="line">        <span class="keyword">if</span> (StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            String[] remarkLines = remarks.split(System.getProperty(<span class="string">&quot;line.separator&quot;</span>)); </span><br><span class="line">            <span class="keyword">for</span> (String remarkLine : remarkLines) &#123;</span><br><span class="line">                field.addJavaDocLine(<span class="string">&quot; * &quot;</span> + remarkLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot; *&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">        sb.append(introspectedTable.getFullyQualifiedTable());</span><br><span class="line">        sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        sb.append(introspectedColumn.getActualColumnName());</span><br><span class="line">        field.addJavaDocLine(sb.toString());</span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot; *&quot;</span>);</span><br><span class="line">        addJavadocTag(field, <span class="literal">false</span>);</span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot; */&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFieldComment</span><span class="params">(Field field, IntrospectedTable introspectedTable)</span> &#123;</span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        addJavadocTag(field, <span class="literal">false</span>);</span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot; */&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addGetterComment</span><span class="params">(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn)</span> &#123;</span><br><span class="line">        method.addJavaDocLine(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        addJavadocTag(method, <span class="literal">false</span>);</span><br><span class="line">        method.addJavaDocLine(<span class="string">&quot; */&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSetterComment</span><span class="params">(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn)</span> &#123;</span><br><span class="line">        method.addJavaDocLine(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        addJavadocTag(method, <span class="literal">false</span>);</span><br><span class="line">        method.addJavaDocLine(<span class="string">&quot; */&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addJavadocTag</span><span class="params">(JavaElement javaElement, <span class="type">boolean</span> markAsDoNotDelete)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">        sb.append(MergeConstants.NEW_ELEMENT_TAG);</span><br><span class="line">        <span class="keyword">if</span> (markAsDoNotDelete) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot; do_not_delete_during_merge&quot;</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getDateString();</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        javaElement.addJavaDocLine(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getDateString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DateFormatUtils.format(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyBatis的配置文件修改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">commentGenerator</span> <span class="attr">type</span>=<span class="string">&quot;com.test.mbg.RemarksCommentGenerator&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="运行MyBatis生成器">运行MyBatis生成器</h1>
<p>改用自定义的<code>RemarksCommentGenerator</code>后，运行MyBatis插件可能会报错。需要使用Java来运行MyBatis生成器，代码如下 [<a href="http://www.mybatis.org/generator/running/runningWithJava.html">doc</a>]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.mbg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  使用Java运行 MyBatis Generator</span></span><br><span class="line"><span class="comment"> * http://www.mybatis.org/generator/running/runningWithJava.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisGen</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;F:/code/mybatis-generator.xml&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(configFile);</span><br><span class="line">        <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">        <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config, callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL binlog：格式、增量恢复、闪回、Java 解析</title>
    <url>/2018/06/mysql-binlog/</url>
    <content><![CDATA[<p>MySQL 的 <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log.html">binlog</a> 日志文件，记录了数据库表的全部修改操作。本文简单整理 MySQL binlog 相关知识，以及如何使用 binlog 恢复或闪回数据库数据。</p>
<h1 id="STATEMENT-格式的-binlog">STATEMENT 格式的 binlog</h1>
<p>要想开启 binlog，需要在启动 MySQL 时传入 --<a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#option_mysqld_log-bin">log-bin</a> 参数。或者也可以在 MySQL 配置文件 <code>/etc/my.cnf</code>，设置 <code>log_bin</code> 开启 binlog。MySQL 5.7 开始，开启 binlog 后，<code>--server-id</code> 参数也必须指定，否则 MySQL 服务器会启动失败。</p>
<span id="more"></span>
<p><code>binlog_format</code> 支持 <code>STATEMENT</code>, <code>ROW</code>, <code>MIXED</code> 三种格式，MySQL 5.5 和 5.6 默认为 <code>STATEMENT</code>，MySQL 5.7.7 开始默认为 <code>ROW</code>。若 SQL 使用 UUID(), RAND(), VERSION() 等函数，或者使用存储过程、自定义函数，基于 STATEMENT 的主从复时，是不安全的（很多人可能会认为 NOW(), CURRENT_TIMESTAMP 这些函数也是不安全的，事实上是安全的）[ <a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-sbr-rbr.html">doc1</a>, <a href="https://mariadb.com/kb/en/library/unsafe-statements-for-statement-based-replication/">doc2</a> ]。基于 <code>ROW</code> 的主从复制，是最安全的复制方式。</p>
<p>现在先来看下 <code>STATEMENT</code> 格式的 binlog，<code>/etc/my.cnf</code> 文件修改的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_id = 1</span><br><span class="line">log_bin = mysql-bin</span><br><span class="line">binlog_format = STATEMENT</span><br><span class="line">binlog_row_image=FULL</span><br></pre></td></tr></table></figure>
<p>重启 MySQL 后，在数据目录 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_datadir">datadir</a> 下，比如 <code>/var/lib/mysql/</code>，将会生成相应的 binlog 文件，<code>mysql-bin.index</code> 和 <code>mysql-bin.000001</code>。<code>.index</code> 后缀的文件保存全部 binlog 文件名。<code>mysql-bin.000001</code> 文件记录 binlog 内容。每次 MySQL 启动或者 flush 日志，都将按序号创建一个新的日志文件。另外，当日志文件大小超过 <code>max_binlog_size</code> 时，也会创建一个新的日志文件。</p>
<p>现在来试一试 binlog 功能。假设在 <code>testdb</code> 库在有 <code>hello</code> 表，并对其中某行做修改操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hello;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Andy  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Bill  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Candy <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> hello <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;Will&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>binlog 为二进制文件，需要使用 <code>mysqlbinlog</code>（<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog.html">doc</a>, <a href="https://www.mankier.com/1/mysqlbinlog">man</a>）命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mysqlbinlog /var/lib/mysql/mysql-bin.000001  # 直接在 mysql 服务器上读取 binlog 文件</span><br><span class="line">$ mysqlbinlog -R -h192.168.2.107 -uroot -p123456 mysql-bin.000001  # 或者，远程读取 binlog 文件</span><br></pre></td></tr></table></figure>
<p>执行 <code>update</code> 后相应新增的 binlog 文件内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">at</span> <span class="number">154</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">47</span>:<span class="number">49</span> server id <span class="number">1</span>  end_log_pos <span class="number">219</span> CRC32 <span class="number">0x4bd9d69b</span> 	Anonymous_GTID	last_committed<span class="operator">=</span><span class="number">0</span>	sequence_number<span class="operator">=</span><span class="number">1</span>	rbr_only<span class="operator">=</span><span class="keyword">no</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">219</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">47</span>:<span class="number">49</span> server id <span class="number">1</span>  end_log_pos <span class="number">302</span> CRC32 <span class="number">0x476fafc9</span> 	Query	thread_id<span class="operator">=</span><span class="number">2</span>	exec_time<span class="operator">=</span><span class="number">0</span>	error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1529246869</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.pseudo_thread_id<span class="operator">=</span><span class="number">2</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.foreign_key_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.sql_auto_is_null<span class="operator">=</span><span class="number">0</span>, @<span class="variable">@session</span>.unique_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.autocommit<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sql_mode<span class="operator">=</span><span class="number">1075838976</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.auto_increment_increment<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.auto_increment_offset<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!\C utf8 */</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.character_set_client<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collation_connection<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collation_server<span class="operator">=</span><span class="number">33</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.lc_time_names<span class="operator">=</span><span class="number">0</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.collation_database<span class="operator">=</span><span class="keyword">DEFAULT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">302</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">47</span>:<span class="number">49</span> server id <span class="number">1</span>  end_log_pos <span class="number">423</span> CRC32 <span class="number">0x7f2c2c7a</span> 	Query	thread_id<span class="operator">=</span><span class="number">2</span>	exec_time<span class="operator">=</span><span class="number">0</span>	error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line">use `testdb`<span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1529246869</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">update</span> hello <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;Will&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">423</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">47</span>:<span class="number">49</span> server id <span class="number">1</span>  end_log_pos <span class="number">454</span> CRC32 <span class="number">0x68da744a</span> 	Xid <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure>
<h1 id="ROW-格式的-binlog">ROW 格式的 binlog</h1>
<p>修改 <code>/etc/my.cnf</code> 的 <code>binlog_format</code> 为 <code>ROW</code>，再重启 MySQL。格式修改后，会生成一个新的 binlog 文件 <code>mysql-bin.000002</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> hello;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> hello <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `hello` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hello <span class="keyword">where</span> id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Andy <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Lily <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Will <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> hello <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;David&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>查看 <code>ROW</code> 格式的 binlog，需要使用 <code>sudo mysqlbinlog -v --base64-output=DECODE-ROWS /var/lib/mysql/mysql-bin.000002</code> 命令。执行 <code>update</code> 后相应新增的 binlog 内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">at</span> <span class="number">154</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">13</span> server id <span class="number">1</span>  end_log_pos <span class="number">219</span> CRC32 <span class="number">0x2ce70d4d</span> 	Anonymous_GTID	last_committed<span class="operator">=</span><span class="number">0</span>	sequence_number<span class="operator">=</span><span class="number">1</span>	rbr_only<span class="operator">=</span>yes</span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">219</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">13</span> server id <span class="number">1</span>  end_log_pos <span class="number">293</span> CRC32 <span class="number">0x8183fddf</span> 	Query	thread_id<span class="operator">=</span><span class="number">2</span>	exec_time<span class="operator">=</span><span class="number">0</span>	error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1529247253</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.pseudo_thread_id<span class="operator">=</span><span class="number">2</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.foreign_key_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.sql_auto_is_null<span class="operator">=</span><span class="number">0</span>, @<span class="variable">@session</span>.unique_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.autocommit<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sql_mode<span class="operator">=</span><span class="number">1075838976</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.auto_increment_increment<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.auto_increment_offset<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!\C utf8 */</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.character_set_client<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collation_connection<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collation_server<span class="operator">=</span><span class="number">33</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.lc_time_names<span class="operator">=</span><span class="number">0</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.collation_database<span class="operator">=</span><span class="keyword">DEFAULT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">293</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">13</span> server id <span class="number">1</span>  end_log_pos <span class="number">346</span> CRC32 <span class="number">0x0fc7e1a4</span> 	Table_map: `testdb`.`hello` mapped <span class="keyword">to</span> number <span class="number">110</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">346</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">13</span> server id <span class="number">1</span>  end_log_pos <span class="number">411</span> CRC32 <span class="number">0xb58e729d</span> 	Update_rows: <span class="keyword">table</span> id <span class="number">110</span> flags: STMT_END_F</span><br><span class="line">### <span class="keyword">UPDATE</span> `testdb`.`hello`</span><br><span class="line">### <span class="keyword">WHERE</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">3</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;Will&#x27;</span></span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">3</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;David&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">411</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">13</span> server id <span class="number">1</span>  end_log_pos <span class="number">442</span> CRC32 <span class="number">0xef964db8</span> 	Xid <span class="operator">=</span> <span class="number">13</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure>
<p>若执行如下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> hello (name) <span class="keyword">values</span> (<span class="string">&#x27;Frank&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<p>相应生成的 binlog 内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">at</span> <span class="number">442</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">55</span>:<span class="number">47</span> server id <span class="number">1</span>  end_log_pos <span class="number">507</span> CRC32 <span class="number">0x79de08a7</span> 	Anonymous_GTID	last_committed<span class="operator">=</span><span class="number">1</span>	sequence_number<span class="operator">=</span><span class="number">2</span>	rbr_only<span class="operator">=</span>yes</span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">507</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">55</span>:<span class="number">47</span> server id <span class="number">1</span>  end_log_pos <span class="number">581</span> CRC32 <span class="number">0x56f9eb6a</span> 	Query	thread_id<span class="operator">=</span><span class="number">2</span>	exec_time<span class="operator">=</span><span class="number">0</span>	error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1529247347</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">581</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">55</span>:<span class="number">47</span> server id <span class="number">1</span>  end_log_pos <span class="number">634</span> CRC32 <span class="number">0xedb73620</span> 	Table_map: `testdb`.`hello` mapped <span class="keyword">to</span> number <span class="number">110</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">634</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">55</span>:<span class="number">47</span> server id <span class="number">1</span>  end_log_pos <span class="number">684</span> CRC32 <span class="number">0x525a6a70</span> 	Write_rows: <span class="keyword">table</span> id <span class="number">110</span> flags: STMT_END_F</span><br><span class="line">### <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `testdb`.`hello`</span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">4</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;Frank&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">684</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">55</span>:<span class="number">47</span> server id <span class="number">1</span>  end_log_pos <span class="number">715</span> CRC32 <span class="number">0x09a0d4de</span> 	Xid <span class="operator">=</span> <span class="number">14</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure>
<p>若执行如下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> hello <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<p>相应生成的 binlog 内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">at</span> <span class="number">715</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">44</span> server id <span class="number">1</span>  end_log_pos <span class="number">780</span> CRC32 <span class="number">0x9f52450e</span> 	Anonymous_GTID	last_committed<span class="operator">=</span><span class="number">2</span>	sequence_number<span class="operator">=</span><span class="number">3</span>	rbr_only<span class="operator">=</span>yes</span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">780</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">44</span> server id <span class="number">1</span>  end_log_pos <span class="number">854</span> CRC32 <span class="number">0x0959bc8d</span> 	Query	thread_id<span class="operator">=</span><span class="number">2</span>	exec_time<span class="operator">=</span><span class="number">0</span>	error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1529247404</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">854</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">44</span> server id <span class="number">1</span>  end_log_pos <span class="number">907</span> CRC32 <span class="number">0x2945260f</span> 	Table_map: `testdb`.`hello` mapped <span class="keyword">to</span> number <span class="number">110</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">907</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">44</span> server id <span class="number">1</span>  end_log_pos <span class="number">956</span> CRC32 <span class="number">0xc70df255</span> 	Delete_rows: <span class="keyword">table</span> id <span class="number">110</span> flags: STMT_END_F</span><br><span class="line">### <span class="keyword">DELETE</span> <span class="keyword">FROM</span> `testdb`.`hello`</span><br><span class="line">### <span class="keyword">WHERE</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;Bill&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">956</span></span><br><span class="line">#<span class="number">180617</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">44</span> server id <span class="number">1</span>  end_log_pos <span class="number">987</span> CRC32 <span class="number">0x0c98f18e</span> 	Xid <span class="operator">=</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure>
<h1 id="使用-binlog-增量恢复">使用 binlog 增量恢复</h1>
<p>MySQL 逻辑备份通常会结合<strong>全量备份</strong>和<strong>增量备份</strong>，使用 <code>mysqldump</code> 定期全量备份数据库，然后利用 binlog 保存增量数据。恢复数据时，就是用 <code>mysqldump</code> 备份的数据恢复到备份的时间点。数据库在备份时间点到当前时间的增量修改，则通过 <code>mysqlbinlog</code> 将 binlog 中的增量数据恢复到数据库。现在假设已经使用 <code>mysqldump</code> 将数据库还原到：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hello;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Andy <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Lily <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Will <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>之后执行的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> hello <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;David&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">insert</span> hello (name) <span class="keyword">values</span> (<span class="string">&#x27;Frank&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> hello <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>不管是使用 <code>STATEMENT</code> 还是 <code>ROW</code>，<code>mysqlbinlog</code> 命令都可以将 binlog 增量恢复到数据库 [ <a href="https://dev.mysql.com/doc/refman/5.7/en/point-in-time-recovery.html">doc</a> ]。</p>
<p>观察 <code>binlog</code> 可以看到，从最开始的 <code>update hello set name = 'David' where id = 3;</code> 到最终的 <code>delete from hello where id = 2;</code>，时间上从 &quot;2018-06-17 22:54:13&quot; 到 &quot;2018-06-17 22:56:44&quot;，所以基于时间点恢复，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mysqlbinlog --start-datetime=&quot;2018-06-17 22:54:13&quot; --stop-datetime=&quot;2018-06-17 22:56:44&quot; mysql-bin.000002 | mysql -uroot -p123456</span><br></pre></td></tr></table></figure>
<p><code>binlog</code> 的事件位置号是从 &quot;154&quot; 到 &quot;956&quot;，但需要注意的是 用 <code>--start-position</code> 和 <code>--stop-position</code> 指定位置点范围，逻辑上对应的是 <code>start &lt;= position &lt; stop</code>，所以基于时间点恢复，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mysqlbinlog --start-position=154 --stop-position=957 mysql-bin.000002 | mysql -uroot -p123456</span><br></pre></td></tr></table></figure>
<p>两种方式任意执行，都能将数据恢复到：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hello;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Andy  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> David <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> Frank <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="使用-binlog2sql-闪回">使用 binlog2sql 闪回</h1>
<p><a href="https://github.com/danfengcao/binlog2sql">binlog2sql</a>，作者为曹单锋，大众点评 DBA。<code>binlog2sql</code>，从 MySQL binlog 解析出你要的 SQL。根据不同选项，你可以得到原始 SQL、回滚 SQL、去除主键的 INSERT SQL 等。<code>binlog2sql</code>，底层实现依赖 <a href="https://github.com/noplay/python-mysql-replication">python-mysql-replication</a>，由该库完成 MySQL 复制协议和 binlog 格式的解析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python binlog2sql/binlog2sql.py -h192.168.2.107 -uroot -p123456 --start-position=154 --stop-position=957 --start-file=<span class="string">&#x27;mysql-bin.000002&#x27;</span></span></span><br><span class="line">UPDATE `testdb`.`hello` SET `id`=3, `name`=&#x27;David&#x27; WHERE `id`=3 AND `name`=&#x27;Will&#x27; LIMIT 1; #start 4 end 411 time 2018-06-17 22:54:13</span><br><span class="line">INSERT INTO `testdb`.`hello`(`id`, `name`) VALUES (4, &#x27;Frank&#x27;); #start 442 end 684 time 2018-06-17 22:55:47</span><br><span class="line">DELETE FROM `testdb`.`hello` WHERE `id`=2 AND `name`=&#x27;Bill&#x27; LIMIT 1; #start 715 end 956 time 2018-06-17 22:56:44</span><br></pre></td></tr></table></figure>
<p>生成回滚 sql：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python binlog2sql/binlog2sql.py --flashback -h192.168.2.107 -uroot -p123456 --start-position=154 --stop-position=956 --start-file=<span class="string">&#x27;mysql-bin.000002&#x27;</span></span></span><br><span class="line">INSERT INTO `testdb`.`hello`(`id`, `name`) VALUES (2, &#x27;Bill&#x27;); #start 715 end 956 time 2018-06-17 22:56:44</span><br><span class="line">DELETE FROM `testdb`.`hello` WHERE `id`=4 AND `name`=&#x27;Frank&#x27; LIMIT 1; #start 442 end 684 time 2018-06-17 22:55:47</span><br><span class="line">UPDATE `testdb`.`hello` SET `id`=3, `name`=&#x27;Will&#x27; WHERE `id`=3 AND `name`=&#x27;David&#x27; LIMIT 1; #start 154 end 411 time 2018-06-17 22:54:13</span><br></pre></td></tr></table></figure>
<p>闪回的现实原理很简单，先通过 MySQL <a href="https://dev.mysql.com/doc/internals/en/replication-protocol.html">复制协议</a>的 <a href="https://dev.mysql.com/doc/internals/en/com-binlog-dump.html">com-binlog-dump</a> 命令 dump 出 binlog，然后按照 binlog 的<a href="https://dev.mysql.com/doc/internals/en/binary-log.html">格式规范</a>解析 binlog，将 binlog 转换成 SQL，再将这些 SQL 转换反向逻辑的 SQL，最后再倒序执行。具体可以看，<code>binlog2sql</code> 作者的文章 [ <a href="https://github.com/danfengcao/binlog2sql/blob/master/example/mysql-flashback-priciple-and-practice.md">ref</a> ]。</p>
<h1 id="Java-解析-binlog">Java 解析 binlog</h1>
<p>上文中的 <code>binlog2sql</code> 其实底层依赖 <code>python-mysql-replication</code> 库，这是 Python 库。如果想使用 Java 解析 binlog 可以使用 <code>mysql-binlog-connector-java</code>（<a href="https://github.com/shyiko/mysql-binlog-connector-java">github</a>）库。目前开源的 CDC 工具，如 Zendesk <a href="https://github.com/zendesk/maxwell">maxwell</a>、Redhat <a href="https://github.com/debezium/debezium">debezium</a>、LinkedIn <a href="https://github.com/linkedin/databus">Databus</a> 等都底层依赖 <code>mysql-binlog-connector-java</code> 或者其前身 <a href="https://github.com/zendesk/open-replicator">open-replicator</a>。使用 <code>mysql-binlog-connector-java</code> 的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BinaryLogClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryLogClient</span>(<span class="string">&quot;192.168.2.107&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">client.setBinlogFilename(<span class="string">&quot;mysql-bin.000001&quot;</span>);</span><br><span class="line">client.setBinlogPosition(<span class="number">4</span>);</span><br><span class="line">client.setBlocking(<span class="literal">false</span>);</span><br><span class="line">client.registerEventListener(event -&gt; &#123;</span><br><span class="line">    System.out.println(event);</span><br><span class="line">&#125;);</span><br><span class="line">client.connect();</span><br></pre></td></tr></table></figure>
<p>输出（省略部分内容）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=<span class="number">1529247253000</span>, eventType=TABLE_MAP, serverId=<span class="number">1</span>, headerLength=<span class="number">19</span>, dataLength=<span class="number">34</span>, nextPosition=<span class="number">346</span>, flags=<span class="number">0</span>&#125;, data=TableMapEventData&#123;tableId=<span class="number">110</span>, database=<span class="string">&#x27;testdb&#x27;</span>, table=<span class="string">&#x27;hello&#x27;</span>, columnTypes=<span class="number">8</span>, <span class="number">15</span>, columnMetadata=<span class="number">0</span>, <span class="number">40</span>, columnNullability=&#123;<span class="number">1</span>&#125;&#125;&#125;</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=<span class="number">1529247253000</span>, eventType=EXT_UPDATE_ROWS, serverId=<span class="number">1</span>, headerLength=<span class="number">19</span>, dataLength=<span class="number">46</span>, nextPosition=<span class="number">411</span>, flags=<span class="number">0</span>&#125;, data=UpdateRowsEventData&#123;tableId=<span class="number">110</span>, includedColumnsBeforeUpdate=&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, includedColumns=&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, rows=[</span><br><span class="line">    &#123;before=[<span class="number">3</span>, Will], after=[<span class="number">3</span>, David]&#125;</span><br><span class="line">]&#125;&#125;</span><br><span class="line">...</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=<span class="number">1529247347000</span>, eventType=TABLE_MAP, serverId=<span class="number">1</span>, headerLength=<span class="number">19</span>, dataLength=<span class="number">34</span>, nextPosition=<span class="number">634</span>, flags=<span class="number">0</span>&#125;, data=TableMapEventData&#123;tableId=<span class="number">110</span>, database=<span class="string">&#x27;testdb&#x27;</span>, table=<span class="string">&#x27;hello&#x27;</span>, columnTypes=<span class="number">8</span>, <span class="number">15</span>, columnMetadata=<span class="number">0</span>, <span class="number">40</span>, columnNullability=&#123;<span class="number">1</span>&#125;&#125;&#125;</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=<span class="number">1529247347000</span>, eventType=EXT_WRITE_ROWS, serverId=<span class="number">1</span>, headerLength=<span class="number">19</span>, dataLength=<span class="number">31</span>, nextPosition=<span class="number">684</span>, flags=<span class="number">0</span>&#125;, data=WriteRowsEventData&#123;tableId=<span class="number">110</span>, includedColumns=&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, rows=[</span><br><span class="line">    [<span class="number">4</span>, Frank]</span><br><span class="line">]&#125;&#125;</span><br><span class="line">...</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=<span class="number">1529247404000</span>, eventType=TABLE_MAP, serverId=<span class="number">1</span>, headerLength=<span class="number">19</span>, dataLength=<span class="number">34</span>, nextPosition=<span class="number">907</span>, flags=<span class="number">0</span>&#125;, data=TableMapEventData&#123;tableId=<span class="number">110</span>, database=<span class="string">&#x27;testdb&#x27;</span>, table=<span class="string">&#x27;hello&#x27;</span>, columnTypes=<span class="number">8</span>, <span class="number">15</span>, columnMetadata=<span class="number">0</span>, <span class="number">40</span>, columnNullability=&#123;<span class="number">1</span>&#125;&#125;&#125;</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=<span class="number">1529247404000</span>, eventType=EXT_DELETE_ROWS, serverId=<span class="number">1</span>, headerLength=<span class="number">19</span>, dataLength=<span class="number">30</span>, nextPosition=<span class="number">956</span>, flags=<span class="number">0</span>&#125;, data=DeleteRowsEventData&#123;tableId=<span class="number">110</span>, includedColumns=&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, rows=[</span><br><span class="line">    [<span class="number">2</span>, Bill]</span><br><span class="line">]&#125;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ol>
<li>MySQL Replication: 5.1.1 Advantages and Disadvantages of Statement-Based and Row-Based Replication <a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-sbr-rbr.html">https://dev.mysql.com/doc/mysql-replication-excerpt/5.7/en/replication-sbr-rbr.html</a></li>
<li>Unsafe Statements for Statement-based Replication <a href="https://mariadb.com/kb/en/library/unsafe-statements-for-statement-based-replication/">https://mariadb.com/kb/en/library/unsafe-statements-for-statement-based-replication/</a></li>
<li>MySQL 5.7 Reference Manual: 4.6.7 mysqlbinlog <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog.html">https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog.html</a></li>
<li>MySQL Internals Manual: 14.9 Replication Protocol <a href="https://dev.mysql.com/doc/internals/en/replication-protocol.html">https://dev.mysql.com/doc/internals/en/replication-protocol.html</a></li>
<li>MySQL Internals Manual: 20 The Binary Log <a href="https://dev.mysql.com/doc/internals/en/binary-log.html">https://dev.mysql.com/doc/internals/en/binary-log.html</a></li>
<li>MySQL闪回原理与实战 <a href="https://github.com/danfengcao/binlog2sql/blob/master/example/mysql-flashback-priciple-and-practice.md">https://github.com/danfengcao/binlog2sql/blob/master/example/mysql-flashback-priciple-and-practice.md</a></li>
<li><a href="https://dev.mysql.com/doc/dev/mysql-server/8.0.11/classbinary__log_1_1Table__map__event.html#details">https://dev.mysql.com/doc/dev/mysql-server/8.0.11/classbinary__log_1_1Table__map__event.html#details</a></li>
<li><a href="https://dev.mysql.com/doc/dev/mysql-server/8.0.11/classbinary__log_1_1Rows__event.html#details">https://dev.mysql.com/doc/dev/mysql-server/8.0.11/classbinary__log_1_1Rows__event.html#details</a></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库字段类型杂记</title>
    <url>/2017/01/mysql-data-types/</url>
    <content><![CDATA[<p>文本整理MySQL字段类型的常见问题和用法。</p>
<h1 id="数值类型">数值类型</h1>
<h2 id="int和int-3">int和int(3)</h2>
<p>新手在定义整数字段时，常常想当然通过，如<code>int(3)</code>，来限制整数的有效长度，然而这样仅仅只是指定了显示宽度。选择有效长度不同的整数，需要使用<code>tinyint</code>（1个字节）、<code>smallint</code>（2个字节）、<code>mediumint</code>（3个字节）、<code>int</code>（4个字节）或<code>bigint</code>（8个字节）。MySQL的相关文档如下[<a href="http://dev.mysql.com/doc/refman/5.7/en/numeric-type-attributes.html">doc</a>]：</p>
<span id="more"></span>
<blockquote>
<p>MySQL supports an extension for optionally specifying the <em>display width</em> of integer data types in parentheses following the base keyword for the type. For example, <a href="http://dev.mysql.com/doc/refman/5.7/en/integer-types.html">INT(4)</a> specifies an <a href="http://dev.mysql.com/doc/refman/5.7/en/integer-types.html">INT</a> with a display width of four digits.</p>
</blockquote>
<blockquote>
<p>The display width does <em>not</em> constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly. For example, a column specified as <a href="http://dev.mysql.com/doc/refman/5.7/en/integer-types.html">SMALLINT(3)</a> has the usual <a href="http://dev.mysql.com/doc/refman/5.7/en/integer-types.html">SMALLINT</a> range of <code>-32768</code> to <code>32767</code>, and values outside the range permitted by three digits are displayed in full using more than three digits.</p>
</blockquote>
<blockquote>
<p>When used in conjunction with the optional (nonstandard) attribute ZEROFILL, the default padding of spaces is replaced with zeros. For example, for a column declared as <a href="http://dev.mysql.com/doc/refman/5.7/en/integer-types.html">INT(4) ZEROFILL</a>, a value of <code>5</code> is retrieved as <code>0005</code>.</p>
</blockquote>
<p>如下示例，字段<code>bar</code>类型是<code>int(3)</code>，但依然能够正确保存数值<code>12345</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test (foo <span class="type">int</span>(<span class="number">3</span>) zerofill, bar <span class="type">int</span>(<span class="number">3</span>) zerofill, baz <span class="type">int</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.16</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span> (<span class="number">42</span>, <span class="number">12345</span>, <span class="number">12345</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> foo  <span class="operator">|</span> bar   <span class="operator">|</span> baz   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">042</span> <span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="bit和bool">bit和bool</h2>
<p>MySQL同时支持<code>bit</code>和<code>bool</code>类型，但<code>bool</code>仅仅是<code>tinyint(1)</code>的同义词，创建的字段值的范围并不是<code>0</code>和<code>1</code>或<code>true</code>和<code>false</code>，而是<code>-128</code>到<code>127</code>。如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test (foo bool, bar bit);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.10</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> test;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+--------+-------+-----------+---------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type       <span class="operator">|</span> <span class="keyword">Null</span>   <span class="operator">|</span> Key   <span class="operator">|</span>   <span class="keyword">Default</span> <span class="operator">|</span> Extra   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">---------+------------+--------+-------+-----------+---------|</span></span><br><span class="line"><span class="operator">|</span> foo     <span class="operator">|</span> tinyint(<span class="number">1</span>) <span class="operator">|</span> YES    <span class="operator">|</span>       <span class="operator">|</span>    <span class="operator">&lt;</span><span class="keyword">null</span><span class="operator">&gt;</span> <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> bar     <span class="operator">|</span> bit(<span class="number">1</span>)     <span class="operator">|</span> YES    <span class="operator">|</span>       <span class="operator">|</span>    <span class="operator">&lt;</span><span class="keyword">null</span><span class="operator">&gt;</span> <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+--------+-------+-----------+---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="字符串类型">字符串类型</h1>
<h2 id="长度和编码">长度和编码</h2>
<p>从MySQL 4.1开始（2004年10月），用<strong>字符</strong>单位解释在字符列定义中的长度规范。(以前的一些MySQL版本以<strong>字节</strong>解释长度）。官方文档描述如下[<a href="https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/string-type-overview.html">doc</a>]</p>
<blockquote>
<p>In MySQL 4.1 and up , string data types include some features that you may not have encountered in working with versions of MySQL prior to 4.1:</p>
</blockquote>
<blockquote>
<p>MySQL interprets length specifications in character column definitions in character units. (Before MySQL 4.1, column lengths were interpreted in bytes.) This applies to <code>CHAR</code>, <code>VARCHAR</code>, and the <code>TEXT</code> types.</p>
</blockquote>
<p>MySQL服务器默认的<em>字符集</em>是<code>latin1</code>，使用的<em>校对规则</em>是<code>latin1_swedish_ci</code> [<a href="http://dev.mysql.com/doc/refman/5.7/en/charset-server.html">doc</a>]（<em>校对规则</em>是在字符集内用于比较字符的一套规则）。若要保存中文，典型的做法是使用<code>utf8</code>编码。但MySQL的<code>utf8</code>编码最多只能保存使用<code>utf8</code>编码后长度是3个字节的字符，即只支持<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">基本多文种平面</a>。使用MySQL的utf8保存常见的字符基本上没有问题，但对于生僻字或<a href="https://en.wikipedia.org/wiki/Emoji">emoji</a>字符就无能为力了。emoji的中的<code>笑脸（grinning face）</code>的Unicode编码，如下 [<a href="http://www.iemoji.com/view/emoji/885/smileys-people/grinning-face">ref1</a>][<a href="https://en.wikibooks.org/wiki/Unicode/Character_reference/1F000-1FFFF">ref2</a>]：</p>
<table>
<thead>
<tr>
<th>表情</th>
<th>Unicode</th>
<th>UTF-16</th>
<th>UTF8</th>
</tr>
</thead>
<tbody>
<tr>
<td>😀</td>
<td>U+1F604</td>
<td>0xD83D 0xDE04</td>
<td>0xF0 0x9F 0x98 0x84</td>
</tr>
</tbody>
</table>
<p>emoji位于辅助多文种平面，<code>utf8</code>需要4个字节保存。为了解决这个问题，MySQL 5.5.3开始支持<code>utf8mb4</code>，支持辅助多文种平面，每个字符最大4个字节 [<a href="http://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html">doc</a>]。除了<code>utf8</code>，MySQL还支持<code>ucs2</code>、<code>utf16</code>、<code>utf32</code>等，完整列表如下 [<a href="http://dev.mysql.com/doc/refman/5.5/en/charset-unicode.html">ref</a>]</p>
<table>
<thead>
<tr>
<th>字符集</th>
<th>支持的字符</th>
<th>每个字符需要的存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>utf8</code></td>
<td>基本多文种平面</td>
<td>1, 2, 或 3 个字节</td>
</tr>
<tr>
<td><code>ucs2</code></td>
<td>基本多文种平面</td>
<td>2字节</td>
</tr>
<tr>
<td><code>utf8mb4</code></td>
<td>基本多文种平面和辅助多文种平面</td>
<td>1, 2, 3,或4字节</td>
</tr>
<tr>
<td><code>utf16</code></td>
<td>基本多文种平面和辅助多文种平面</td>
<td>2或4字节</td>
</tr>
<tr>
<td><code>utf16le</code></td>
<td>基本多文种平面和辅助多文种平面</td>
<td>2或4字节</td>
</tr>
<tr>
<td><code>utf32</code></td>
<td>基本多文种平面和辅助多文种平面</td>
<td>4字节</td>
</tr>
</tbody>
</table>
<p>##varchar和text</p>
<p>MySQL支持多种字符串类型， 如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最大字节长度</th>
<th>最大<code>utf8</code>字符数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char(M)</code></td>
<td>M，M为0~255之间的整数</td>
<td>85个<code>utf8</code>字符</td>
</tr>
<tr>
<td><code>varchar(M)</code></td>
<td>M，M为0~65,535之间的整数</td>
<td>21,844个<code>utf8</code>字符</td>
</tr>
<tr>
<td><code>tinytext </code></td>
<td>255 (2<sup>8</sup>−1) 字节</td>
<td>85个<code>utf8</code>字符</td>
</tr>
<tr>
<td><code>text</code></td>
<td>65,535 (2<sup>16</sup>−1) 字节 = 64 KB</td>
<td>21,844个<code>utf8</code>字符</td>
</tr>
<tr>
<td><code>mediumtext</code></td>
<td>16,777,215 (2<sup>24</sup>−1) 字节 = 16 MB</td>
<td>5,592,405个<code>utf8</code>字符</td>
</tr>
<tr>
<td><code>longtext</code></td>
<td>4,294,967,295 (2<sup>32</sup>−1) 字节 = 4 GB</td>
<td>1,431,655,765个<code>utf8</code>字符</td>
</tr>
</tbody>
</table>
<p>字符串类型实际支持的最大字符数与编码有关。比如，<code>varchar</code>类型在<code>utf8</code>编码下最大支持保存21,844 (65,535 / 3 = 21,844) 个字符，而<code>utf8mb4</code>编码下最大支持保存16,383 (65,535 / 4 = 16,383) 个字符。</p>
<p>另外，MySQL表行最大总长度为65,535字节 [<a href="http://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html">doc</a>]， 所以<code>varchar</code>类型字段的最大字符数会被表中其他字段所占用的存储空间挤掉。<code>blob</code>或<code>text</code>类型的字段不会受表行总长度的限制，因为字段存储的实际内容和表行是<strong>分离</strong>的，只会占用表行的9到12个字节。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test ( foo <span class="type">varchar</span>(<span class="number">21845</span>) <span class="type">character</span> <span class="keyword">set</span> utf8 );</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. The maximum <span class="type">row</span> size <span class="keyword">for</span> the used <span class="keyword">table</span> type, <span class="keyword">not</span> counting BLOBs, <span class="keyword">is</span> <span class="number">65535.</span> This includes storage overhead, <span class="keyword">check</span> the manual. You have <span class="keyword">to</span> change <span class="keyword">some</span> columns <span class="keyword">to</span> TEXT <span class="keyword">or</span> BLOBs</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test ( foo <span class="type">varchar</span>(<span class="number">21844</span>) <span class="type">character</span> <span class="keyword">set</span> utf8 );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.19</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test2 ( foo <span class="type">varchar</span>(<span class="number">16384</span>) <span class="type">character</span> <span class="keyword">set</span> utf8mb4 );</span><br><span class="line">ERROR <span class="number">1074</span> (<span class="number">42000</span>): <span class="keyword">Column</span> length too big <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;foo&#x27;</span> (max <span class="operator">=</span> <span class="number">16383</span>); use <span class="type">BLOB</span> <span class="keyword">or</span> TEXT instead</span><br></pre></td></tr></table></figure>
<h1 id="日期和时间类型">日期和时间类型</h1>
<p>MySQL支持的日期和时间类型如下表所示 [<a href="http://dev.mysql.com/doc/refman/5.7/en/date-and-time-type-overview.html">doc</a>]：</p>
<table>
<thead>
<tr>
<th>日期和时间类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>date</code></td>
<td>4</td>
<td><code>1000-01-01</code></td>
<td><code>9999-12-31</code></td>
</tr>
<tr>
<td><code>datetime</code></td>
<td>8</td>
<td><code>1000-01-01 00:00:00.000000</code></td>
<td><code>9999-12-31 23:59:59.999999</code></td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>4</td>
<td><code>1970-01-01 00:00:01.000000</code></td>
<td><code>2038-01-19 03:14:07.999999</code></td>
</tr>
<tr>
<td><code>time</code></td>
<td>3</td>
<td><code>-838:59:59.000000</code></td>
<td><code>838:59:59.000000</code></td>
</tr>
<tr>
<td><code>year</code></td>
<td>1</td>
<td><code>1901</code></td>
<td><code>2155</code></td>
</tr>
</tbody>
</table>
<h1 id="参考资料">参考资料</h1>
<ol>
<li>MySQL 5.7 Reference Manual, <em><strong>12 Data Types</strong></em> <a href="http://dev.mysql.com/doc/refman/5.7/en/data-types.html">http://dev.mysql.com/doc/refman/5.7/en/data-types.html</a></li>
<li>MySQL 5.7 Reference Manual, <em><strong>10.1 Character Set Support</strong></em> <a href="http://dev.mysql.com/doc/refman/5.5/en/charset.html">http://dev.mysql.com/doc/refman/5.5/en/charset.html</a></li>
<li>MySQL 5.7 Reference Manual, <em><strong>C.10.4 Limits on Table Column Count and Row Size</strong></em> <a href="http://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html">http://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html</a></li>
<li>Difference between “int” and “int(3)” data types in mysql <a href="http://stackoverflow.com/q/5562322">http://stackoverflow.com/q/5562322</a></li>
<li>Which MySQL Datatype to use for storing boolean values? <a href="http://stackoverflow.com/q/289727">http://stackoverflow.com/q/289727</a></li>
<li>MySQL: Large VARCHAR vs. TEXT? <a href="http://stackoverflow.com/q/2023481">http://stackoverflow.com/q/2023481</a></li>
<li>TINYTEXT, TEXT, MEDIUMTEXT, and LONGTEXT maximum storage sizes <a href="http://stackoverflow.com/q/13932750">http://stackoverflow.com/q/13932750</a></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 5.7 的 JSON 类型</title>
    <url>/2019/06/mysql-5.7-json/</url>
    <content><![CDATA[<p>2015 年 8 月，MySQL 5.7.8 开始提供对 JSON 的原生支持<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。MySQL 对 JSON 的支持可以说是千呼万唤始出来。2009 年开始 NoSQL 逐渐流行起来，相继出现了键值对数据库、文档数据库、列族数据库、图数据库等各类 NoSQL，解决经典关系型数据库无法解决的痛点。其中，对灵活存储半结构化数据的需求，使得类似 MongoDB 这类文档数据库涌现出来。各大主流关系型数据库也在响应趋势，开始支持半结构化数据。早在 2012 年，PostgreSQL 9.2 就已经添加了 JSON 数据类型<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。Oracle 也在 2014 年 7 月发布 12c Release 1 后开始支持 JSON<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。Facebook 在 MySQL 5.7 没发布之前，对 5.6 版本的 MySQL 添加了存储 JSON 功能，这个特性被 Facebook 命名为 DocStore (Document Database for MySQL at Facebook)<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。另外，SQL 标准组织行动也很快，在 2014 年 3 月已经完成了 SQL/JSON 标准草案（SQL/JSON Proposals）<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。完整的草案在 2016 年 12 月正式被采纳为标准，即 SQL:2016。</p>
<span id="more"></span>
<p>浏览 SQL/JSON 标准草案可以发现，全部作者共有 9 人，这些作者来自两个公司，Oracle 和 IBM，而排前面的作者如 Jim Melton, Fred Zemke, Beda Hammerschmidt 都 Oracle 的专家（有兴趣可以看下他们的 LinkedIn）。正因为 SQL:2016 主要就是 Oracle 参与制定的，目前，Oracle 数据库对 SQL:2016 的支持也是最全的<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>。</p>
<p>MySQL 对 JSON 的支持，设计文档主要是  WL#7909: Server side JSON functions<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>，另外还有 WL#8132: JSON datatype and binary storage format<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>、WL#8249: JSON comparator<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>、WL#8607: Inline JSON path expressions in SQL<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup> 等。在 MySQL 开始 WL#7909 之时，SQL/JSON 标准草案已经公开，WL#7909 中也提及了这份标准，但是如果拿 MySQL 提供 JSON 的功能与 SQL:2016 比较，可以发现 MySQL 虽然融入了部分的设计，但并没有完全参考标准，定义的 JSON 函数多数有区别。</p>
<p>回到正题，下面来看下 MySQL 5.7 的 JSON 的用法。</p>
<h1 id="JSON-函数列表">JSON 函数列表</h1>
<p>MySQL 官方列出 JSON 相关的函数，完整列表如下<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>json 创建函数</td>
<td>json_array()</td>
<td>创建 json 数组</td>
</tr>
<tr>
<td></td>
<td>json_object()</td>
<td>创建 json 对象</td>
</tr>
<tr>
<td></td>
<td>json_quote()</td>
<td>用双引号包裹 json 文档</td>
</tr>
<tr>
<td>json 查询函数</td>
<td>json_contains()</td>
<td>判断是否包含某个 json 值</td>
</tr>
<tr>
<td></td>
<td>json_contains_path()</td>
<td>判断某个路径下是否包 json 值</td>
</tr>
<tr>
<td></td>
<td>json_extract()</td>
<td>提取 json 值</td>
</tr>
<tr>
<td></td>
<td>column-&gt;path</td>
<td>json_extract() 的简洁写法，5.7.9 开始支持</td>
</tr>
<tr>
<td></td>
<td>column-&gt;&gt;path</td>
<td>json_unquote(json_extract()) 的简洁写法，5.7.13 开始支持</td>
</tr>
<tr>
<td></td>
<td>json_keys()</td>
<td>把 json 对象的顶层的全部键提取为 json 数组</td>
</tr>
<tr>
<td></td>
<td>json_search()</td>
<td>按给定字符串关键字搜索 json，返回匹配的路径</td>
</tr>
<tr>
<td>json 修改函数</td>
<td><s>json_append()</s></td>
<td>5.7.9 废弃，改名为 json_array_append()</td>
</tr>
<tr>
<td></td>
<td>json_array_append()</td>
<td>在 josn 文档末尾添加数组元素</td>
</tr>
<tr>
<td></td>
<td>json_array_insert()</td>
<td>在 josn 数组中插入元素</td>
</tr>
<tr>
<td></td>
<td>json_insert()</td>
<td>插入值（只插入新值，不替换旧值）</td>
</tr>
<tr>
<td></td>
<td><s>json_merge()</s></td>
<td>5.7.22 废弃，与 json_merge_preserve() 同义</td>
</tr>
<tr>
<td></td>
<td>json_merge_patch()</td>
<td>合并 json 文档，重复键的值将被替换掉</td>
</tr>
<tr>
<td></td>
<td>json_merge_preserve()</td>
<td>合并 json 文档，保留重复键</td>
</tr>
<tr>
<td></td>
<td>json_remove()</td>
<td>删除 json 文档中的数据</td>
</tr>
<tr>
<td></td>
<td>json_replace()</td>
<td>替换值（只替换旧值，不插入新值）</td>
</tr>
<tr>
<td></td>
<td>json_set()</td>
<td>设置值（替换旧值，或插入新值）</td>
</tr>
<tr>
<td></td>
<td>json_unquote()</td>
<td>移除 json 值的双引号包裹</td>
</tr>
<tr>
<td>json 属性函数</td>
<td>json_depth()</td>
<td>返回 json 文档的最大深度</td>
</tr>
<tr>
<td></td>
<td>json_length()</td>
<td>返回 json 文档的长度</td>
</tr>
<tr>
<td></td>
<td>json_type()</td>
<td>返回 json 值的类型</td>
</tr>
<tr>
<td></td>
<td>json_valid()</td>
<td>判断是否为合法 json 文档</td>
</tr>
<tr>
<td>json 工具函数</td>
<td>json_pretty()</td>
<td>美化输出 json 文档，5.7.22 新增</td>
</tr>
<tr>
<td></td>
<td>json_storage_size()</td>
<td>返回 json 文档占用的存储空间，5.7.22 新增</td>
</tr>
</tbody>
</table>
<p>官方文档对全部函数都作了充分解释并提供一定的示例代码。另外，官方博客也有极佳的相关介绍文章<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>。下文挑选了<strong>部分函数</strong>，演示它们的使用方法。</p>
<h1 id="创建与插入-JSON">创建与插入 JSON</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 tbl 表，字段 data 为 json 类型</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> tbl (data JSON);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.17</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入 json 对象</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tbl <span class="keyword">values</span> (<span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Will&quot;&#125;&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入 json 数组</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tbl <span class="keyword">values</span> (<span class="string">&#x27;[1, 42, 1024]&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec) </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 json_object() 创建 json 对象</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tbl <span class="keyword">values</span> (<span class="built_in">json_object</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>));</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 json_array() 创建 json 数组</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tbl <span class="keyword">values</span> (<span class="built_in">json_array</span>(<span class="number">1</span>, &quot;abc&quot;, <span class="keyword">null</span>, <span class="literal">true</span>, curtime()));</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 tbl 表数据</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">1</span>, &quot;name&quot;: &quot;Will&quot;&#125;                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> [<span class="number">1</span>, <span class="number">42</span>, <span class="number">1024</span>]                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;Andy&quot;&#125;                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> [<span class="number">1</span>, &quot;abc&quot;, <span class="keyword">null</span>, <span class="literal">true</span>, &quot;20:27:41.000000&quot;] <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>上面的 SQL 示例简单验演示了创建 JSON 列以及写入并查询 JSON 数据，比较简单，就不做解释了。</p>
<h1 id="查询-JSON">查询 JSON</h1>
<h2 id="json-extract-与-操作符">json_extract() 与 -&gt; 操作符</h2>
<p>如果要查询 JSON 文档中内容，提取 JSON 中的值，可以使用 json_extract() 函数。函数定义如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">json_extract(json_doc, path[, path] ...)</span><br></pre></td></tr></table></figure>
<p>先来看下 SQL 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 json_extract() 函数查询 json 对象</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_extract(<span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Will&quot;&#125;&#x27;</span>, <span class="string">&#x27;$.name&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_extract(<span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Will&quot;&#125;&#x27;</span>, <span class="string">&#x27;$.name&#x27;</span>)   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-------------------------------------------------------|</span></span><br><span class="line"><span class="operator">|</span> &quot;Will&quot;                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>示例中的 <code>$.name</code>，使用的是 JSON 路径语法，用来提取 JSON 文档的内容。JSON 路径语法，源自 Stefan Goessner 的  JsonPath<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>，不过 MySQL 作了简化。路径语法使用 $ 开头来表示整个 JSON 文档。如果要提取部分 JSON 文档，可以在路径后面添加选择符：</p>
<ul>
<li>在路径 <code>path</code> 后上追加对象的键名称，可以获取这个键下成员。如果加键名称后，路径表达式非法，需要对键名称用双引号包裹（比如，键名称中包含空格的情况）</li>
<li>在路径 <code>path</code> 后加上追加 <code>[N]</code>，用于选择数组的第 N 个元素。数组索引从 0 开始。如果 <code>path</code> 下并不是数组，<code>path[0]</code> 获取结果就是 <code>path</code> 本身。</li>
<li>路径可以包含 <code>*</code> 和 <code>**</code> 通配符：
<ul>
<li><code>.[*]</code> 用于获取 JSON 对象的全部成员。</li>
<li><code>[*]</code> 用于获取 JSON 数组的全部元素。</li>
<li><code>prefix**suffix</code> 表示全部以 <code>prefix</code> 开始，以 <code>suffix</code> 结尾的路径。</li>
</ul>
</li>
<li>如果路径在 JSON 文档中不存在数据，将返回 <code>NULL</code>。</li>
</ul>
<p>假设 <code>$</code> 引用的是如下 JSON 数组：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">99</span><span class="punctuation">,</span> <span class="number">100</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p><code>$[0]</code> 获取到的值为 3，<code>$[1]</code> 获取到 <code>&#123;&quot;a&quot;: [5, 6], &quot;b&quot;: 10&#125;</code>，<code>$[2]</code> 获取到 <code>[99, 100]</code>，<code>$[3]</code> 获取到 <code>NULL</code>（因为不存在第 4 个元素）。</p>
<p>因为 <code>$[1]</code> 和 <code>$[2]</code> 获取的并非纯量（nonscalar），它们可以进一步使用路径访问到内嵌的值，比如：<code>$[1].a</code> 获取到 <code>[5, 6]</code>，<code>$[1].a[1]</code> 获取到 <code>6</code>，<code>$[1].b</code> 获取到 <code>10</code>，<code>$[2][0]</code> 获取到 <code>99</code>。</p>
<p>上文提到，如果追加键值名后，路径表达式非法，需要对键名称用双引号包裹。假设 <code>$</code> 引用的是如下 JSON 对象：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name 1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Will&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name 2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Andy&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>两个键都包含空格，需要加上双引号，才能使用路径表达式访问。<code>$.&quot;name 1&quot;</code> 将获取到 <code>Will</code>，而 <code>$.&quot;name 2&quot;</code> 将获取到 <code>Andy</code>。</p>
<p>现在来看下通配符的示例，假设 JSON 对象如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;d&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>$.*</code> 将获取到 <code>[&#123;&quot;b&quot;: 1&#125;, &#123;&quot;b&quot;: 2&#125;, [3, 4, 5]]</code>；<br>
使用 <code>$.d[*]</code> 将获取到 <code>[3, 4, 5]</code>；<br>
使用 <code>$**.b</code>（对应 <code>$.a.b</code> 和 <code>$.c.b</code>）将获取到 <code>[1, 2]</code>。</p>
<p>MySQL 5.7.9 开始，官方支持 <code>json_extract(column, path)</code> 的简洁写法，内联 JSON 路径表达式 <code>column-&gt;path</code>（WL#8607）。示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用内联 json 路径表达式，查询 json 对象</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.id&#x27;</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;Andy&quot;&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>本质上，这种写法是语法糖，<code>column-&gt;path</code> 等价于 <code>json_extract(column, path)</code>，内联 JSON 路径表达式会在语法解析阶段被转换为 json_extract() 调用。另外，<code>column-&gt;path</code>，存在以下限制<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup></p>
<p><img src="https://static.nullwy.me/mysql-5.7-json-limitations.png" alt="限制"></p>
<p>即，1. 数据源必须是表字段，2. 路径表达式必须为字符串，3. SQL 语句中最多只支持一个。</p>
<p>现在来试验下这个限制，如果使用内联 JSON 路径表达式查询 MySQL 变量，将会报语法错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@j</span> <span class="operator">=</span> <span class="string">&#x27;[&quot;a&quot;, &quot;b&quot;]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语法错误</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="variable">@j</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$[0]&#x27;</span>;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;-&gt; &#x27;</span>$[<span class="number">0</span>]<span class="string">&#x27;&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="json-unquote-与-操作符">json_unquote() 与 -&gt;&gt; 操作符</h2>
<p>假设数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">1</span>, &quot;name&quot;: &quot;Will&quot;&#125;                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;printf(\&quot;hello world\&quot;);&quot;&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>来看下使用 <code>-&gt;</code> 提取获得 JSON 值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.id&#x27;</span>, data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span>, substr(data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------------------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.id&#x27;</span> <span class="operator">|</span> data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span>           <span class="operator">|</span> substr(data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------------------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>              <span class="operator">|</span> &quot;Will&quot;                     <span class="operator">|</span> &quot;                              |</span><br><span class="line">| 2              | &quot;printf(\&quot;hello world\&quot;);&quot; | &quot;                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------------------+--------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> tmp (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">50</span>));</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> tmp <span class="keyword">select</span> data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.id&#x27;</span>, data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span> <span class="keyword">from</span> tbl;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span>, substr(name, <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">from</span> tmp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name                       <span class="operator">|</span> substr(name, <span class="number">1</span>, <span class="number">1</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> &quot;Will&quot;                     <span class="operator">|</span> &quot;                  |</span><br><span class="line">|    2 | &quot;printf(\&quot;hello world\&quot;);&quot; | &quot;                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------------+--------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看到，对于 string 类型的 JSON 值，使用 <code>json_extract()</code> 或 <code>-&gt;</code> 获取的都是被双引号包裹的字符串。MySQL 提供 json_unquote() 函数，用于去掉双引号包裹。另外，MySQL 支持 <code>column-&gt;&gt;path</code> 语法，通过 <code>-&gt;&gt;</code> 操作符获取纯量（scalar）。<code>column-&gt;&gt;path</code> 写法等价于 <code>json_unquote( json_extract(column, path) )</code> 或者 <code>json_unquote(column -&gt; path)</code>。来看下 SQL 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;$.id&#x27;</span> <span class="keyword">as</span> id, data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span> <span class="keyword">as</span> name,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;$.name&#x27;</span> <span class="keyword">as</span> name, json_unquote(data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span>) <span class="keyword">as</span> name <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------------+------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name                       <span class="operator">|</span> name                   <span class="operator">|</span> name                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------------+------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> &quot;Will&quot;                     <span class="operator">|</span> Will                   <span class="operator">|</span> Will                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> &quot;printf(\&quot;hello world\&quot;);&quot; <span class="operator">|</span> printf(&quot;hello world&quot;); <span class="operator">|</span> printf(&quot;hello world&quot;); <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------------------------+------------------------+------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>MySQL 这种区分 <code>-&gt;</code> 和 <code>-&gt;&gt;</code> 的写法，怀疑是源自 Postgres。因为 Postgres 也分别提供了 <code>-&gt;</code> 和 <code>-&gt;&gt;</code> 操作符，<code>-&gt;</code> 也是保留双引号（get JSON object field by key），而 <code>-&gt;&gt;</code> 才能获取实际的字符串值（get JSON object field as text）<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup><sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>。</p>
<p>在笔者看来，这种需要通过 json_unquote() 才能获取实际字符串值的写法完全没有必要，因为很难想到有需要保留双引号的使用场景，而就获取实际的字符串值才是多数情况。实际上，SQLite 的开发者也持有相同的想法。2015 年 10 月，SQLite 3.9 发布，开始支持 JSON 类型<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup><sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>。简单对比下，可以发现 SQLite 提供的 JSON 函数和 MySQL 极其相似，很多函数同名并且同语义。SQLite 也提供了 json_extract() 函数，与 MySQL 不同，SQLite 返回的是移除双引号后的字符串（the dequoted text for a JSON string value）。看下示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> json_extract(<span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Will&quot;&#125;&#x27;</span>, <span class="string">&#x27;$.name&#x27;</span>);</span><br><span class="line">Will</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> json_extract(<span class="string">&#x27;&#123;&quot;code&quot;: &quot;printf(\&quot;hello world\&quot;);&quot;&#125;&#x27;</span>, <span class="string">&#x27;$.code&#x27;</span>);</span><br><span class="line">printf(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>
<p>对于提取 JSON 文档中的纯量（scalar），SQL 标准定义了的 json_value() 函数，MySQL 没有支持，但 Oracle、MariaDB、MSSQL 都有支持。MariaDB 在兼容 MySQL 的同时也支持 SQL 标准，json_extract() 和 json_value() 在 MariaDB 下都可用。来看下 SQL 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [testdb]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">1</span>, &quot;name&quot;: &quot;Will&quot;&#125;                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;printf(\&quot;hello world\&quot;);&quot;&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 json_extract() 提取 JSON 值，string 类型的值保留双引号</span></span><br><span class="line">MariaDB [testdb]<span class="operator">&gt;</span> <span class="keyword">select</span> json_extract(data, <span class="string">&#x27;$.id&#x27;</span>), json_extract(data, <span class="string">&#x27;$.name&#x27;</span>) <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_extract(data, <span class="string">&#x27;$.id&#x27;</span>) <span class="operator">|</span> json_extract(data, <span class="string">&#x27;$.name&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>                          <span class="operator">|</span> &quot;Will&quot;                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>                          <span class="operator">|</span> &quot;printf(\&quot;hello world\&quot;);&quot;   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 json_value() 提取 JSON 值，string 类型的值自动移除双引号</span></span><br><span class="line">MariaDB [testdb]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">json_value</span>(data, <span class="string">&#x27;$.id&#x27;</span>), <span class="built_in">json_value</span>(data, <span class="string">&#x27;$.name&#x27;</span>) <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+----------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">json_value</span>(data, <span class="string">&#x27;$.id&#x27;</span>) <span class="operator">|</span> <span class="built_in">json_value</span>(data, <span class="string">&#x27;$.name&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+----------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>                        <span class="operator">|</span> Will                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>                        <span class="operator">|</span> printf(&quot;hello world&quot;);     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+----------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="其他查询函数">其他查询函数</h2>
<p>除了上文的 json_extract() 函数，查询 JSON 文档相关的还有其他函数，如 json_contains()、json_contains_path()、json_keys()、json_search()。示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@j</span> <span class="operator">=</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;d&quot;: 4&#125;&#125;&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 json_contains() 函数判断是否存在某 JSON 值</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_contains(<span class="variable">@j</span>, <span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_contains(<span class="variable">@j</span>, <span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                            <span class="number">1</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 json_contains_path() 函数判断是否存在某 JSON 路径</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_contains_path(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_contains_path(<span class="variable">@j</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>)   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-----------------------------------------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 json_contains_path() 函数判断是否存在某 JSON 路径</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_contains_path(<span class="variable">@j</span>, <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_contains_path(<span class="variable">@j</span>, <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;$.a&#x27;</span>, <span class="string">&#x27;$.e&#x27;</span>)   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-----------------------------------------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>函数的完整定义和用法可以参考官方文档，本文不再一一举例说明。</p>
<h1 id="修改-JSON">修改 JSON</h1>
<p>对于 MySQL 的 JSON 类型的数据，若要修改数据，可以使用类似如下的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;Will&quot;&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对 data 整个字段修改</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> tbl <span class="keyword">set</span> data <span class="operator">=</span> <span class="string">&#x27;&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Andy&quot;&#125;&#x27;</span> <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span><span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;Andy&quot;&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>如果要修改 JSON 内部数据，是否可以通过 JSON 路径表达式直接赋值呢？答案是，不行，MySQL 不支持。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法错误，不支持通过 JSON 路径表达式赋值，修改 JSON 数据</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> tbl <span class="keyword">set</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Andy&#x27;</span> <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;-&gt;&#x27;</span>$.name<span class="string">&#x27; = &#x27;</span>Andy<span class="string">&#x27; where data-&gt;&#x27;</span>$.id<span class="string">&#x27; = 2&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>MySQL 提供了数个函数来修改 JSON 数据。我们先来看看 json_replace()、json_set() 和 json_insert() 这三个函数：</p>
<ul>
<li>json_replace()：替换值。替换旧值，但不插入新值</li>
<li>json_set()：设置值。替换旧值，或插入新值</li>
<li>json_insert()：插入值。只插入新值，不替换旧值</li>
</ul>
<p>json_insert() 只能插入数据， json_replace() 只能更新数据，json_set() 能更新或插入数据。</p>
<p>替换值，json_replace() 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 json_replace() 函数</span></span><br><span class="line"><span class="comment">-- 把 &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Will&quot;&#125; 修改为 &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Andy&quot;&#125;</span></span><br><span class="line"><span class="comment">-- 路径 $.name 指向的值存在，旧值被替换为新值</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> tbl</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">set</span> data <span class="operator">=</span> json_replace(data, <span class="string">&#x27;$.name&#x27;</span>, <span class="string">&#x27;Andy&#x27;</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>设置值，json_set() 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 json_set() 函数</span></span><br><span class="line"><span class="comment">-- 把 &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Will&quot;&#125; 修改为 &#123;&quot;id&quot;: 2, &quot;city&quot;: &quot;北京&quot;, &quot;name&quot;: &quot;Bill&quot;&#125;</span></span><br><span class="line"><span class="comment">-- 路径 $.name 指向的值存在，旧值被替换为新值；路径 $.city 指向的值不存在，将插入新值</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> tbl</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">set</span> data <span class="operator">=</span> json_set(data, <span class="string">&#x27;$.name&#x27;</span>, <span class="string">&#x27;Bill&#x27;</span>, <span class="string">&#x27;$.city&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span><span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span><span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;city&quot;: &quot;北京&quot;, &quot;name&quot;: &quot;Bill&quot;&#125;   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>插入值，json_insert() 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 json_set() 函数</span></span><br><span class="line"><span class="comment">-- 把 &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Will&quot;&#125; 修改为 &#123;&quot;id&quot;: 2, &quot;address&quot;: &quot;故宫&quot;&#125;</span></span><br><span class="line"><span class="comment">-- 路径 $.name 指向的值存在，将不替换这个旧值；路径 $.address 指向的值不存在，将插入新值</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> tbl</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">set</span> data <span class="operator">=</span> json_insert(data, <span class="string">&#x27;$.name&#x27;</span>, <span class="string">&#x27;Bill&#x27;</span>, <span class="string">&#x27;$.address&#x27;</span>, <span class="string">&#x27;故宫&#x27;</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span><span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.id&#x27;</span><span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;Will&quot;, &quot;address&quot;: &quot;故宫&quot;&#125;        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>现在，我们来看下修改 JSON 数组的两个函数，json_array_insert() 和 json_array_append()，函数定义如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">json_array_insert(json_doc, path, val[, path, val] ...)</span><br><span class="line">json_array_append(json_doc, path, val[, path, val] ...)</span><br></pre></td></tr></table></figure>
<p>json_array_insert()，参数 <code>path</code> 必须指向 JSON 数组某个位置的元素，若该位置存在值，将会把 <code>val</code> 插入该位置，然后其他元素向右移动；若该位置超出数组大小范围，将会把 <code>val</code> 插入到数组末尾。SQL 示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@j</span> <span class="operator">=</span> <span class="string">&#x27;[&quot;a&quot;, &#123;&quot;b&quot;: [1, 2]&#125;, [3, 4]]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在数组的索引 1 的位置上插入值 5，原本索引 1 位置上的 &#123;&quot;b&quot;: [1, 2]&#125; 被挤到后边</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_array_insert(<span class="variable">@j</span>, <span class="string">&#x27;$[1]&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_array_insert(<span class="variable">@j</span>, <span class="string">&#x27;$[1]&#x27;</span>, <span class="number">5</span>)   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------------------------------------|</span></span><br><span class="line"><span class="operator">|</span> [&quot;a&quot;, <span class="number">5</span>, &#123;&quot;b&quot;: [<span class="number">1</span>, <span class="number">2</span>]&#125;, [<span class="number">3</span>, <span class="number">4</span>]]    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入位置超出数组大小范围，将会把值插入到数组末尾</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_array_insert(<span class="variable">@j</span>, <span class="string">&#x27;$[100]&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_array_insert(<span class="variable">@j</span>, <span class="string">&#x27;$[100]&#x27;</span>, <span class="number">5</span>)   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">--------------------------------------|</span></span><br><span class="line"><span class="operator">|</span> [&quot;a&quot;, &#123;&quot;b&quot;: [<span class="number">1</span>, <span class="number">2</span>]&#125;, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- path 指向不是 JSON 数组的元素，SQL 执行报错</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_array_insert(<span class="variable">@j</span>, <span class="string">&#x27;$[1].b&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">(<span class="number">3165</span>, <span class="string">&#x27;A path expression is not a path to a cell in an array.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>json_array_append()，如果参数 <code>path</code> 指向的 JSON 是数组，将在数组末尾添加元素；如果参数 <code>path</code> 指向的 JSON 是值或对象，该值或对象将被包裹为数组，然后在这个数组末尾添加元素。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@j</span> <span class="operator">=</span> <span class="string">&#x27;[&quot;a&quot;, &#123;&quot;b&quot;: [1, 2]&#125;, [3, 4]]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- path 指向的 JSON 是数组，将在数组末尾添加元素</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_array_append(<span class="variable">@j</span>, <span class="string">&#x27;$&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_array_append(<span class="variable">@j</span>, <span class="string">&#x27;$&#x27;</span>, <span class="number">5</span>)   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+</span></span><br><span class="line"><span class="operator">|</span> [&quot;a&quot;, &#123;&quot;b&quot;: [<span class="number">1</span>, <span class="number">2</span>]&#125;, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>] <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- path 指向的 JSON 是值或对象，该值或对象将被包裹为数组，然后在这个数组末尾添加元素</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_array_append(<span class="variable">@j</span>, <span class="string">&#x27;$[1]&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_array_append(<span class="variable">@j</span>, <span class="string">&#x27;$[1]&#x27;</span>, <span class="number">5</span>)  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> [&quot;a&quot;, [&#123;&quot;b&quot;: [<span class="number">1</span>, <span class="number">2</span>]&#125;, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>]] <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>除了上文提到的函数，还有 json_merge_patch()、json_merge_preserve()、json_remove() 这个些函数，可以参考官方文档的介绍，本文不再一一举例说明。</p>
<h1 id="索引-JSON：生成列">索引 JSON：生成列</h1>
<p>现在来看下根据 JSON 列查询表数据的执行计划，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> data <span class="operator">-</span><span class="operator">&gt;</span> &quot;$.id&quot; <span class="operator">=</span> <span class="number">1</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tbl</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">2</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看到，因为没有加索引，访问类型是全表扫描 <code>type: ALL</code>。来试下在 JSON 类型的 <code>data</code> 列上添加索引，会提示如下错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> tbl <span class="keyword">add</span> index (data);</span><br><span class="line">ERROR <span class="number">3152</span> (<span class="number">42000</span>): JSON <span class="keyword">column</span> <span class="string">&#x27;data&#x27;</span> cannot be used <span class="keyword">in</span> key specification.</span><br></pre></td></tr></table></figure>
<p>对于索引 JSON 类型列问题，MySQL 文档有如下阐述<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>：</p>
<blockquote>
<p>JSON columns, like columns of other binary types, are not indexed directly; instead, you can create an index on a generated column that extracts a scalar value from the JSON column. See Indexing a Generated Column to Provide a JSON Column Index, for a detailed example.</p>
</blockquote>
<p>就是说，不能直接在 JSON 列上创建索引；替代方式是，先创建提取 JSON 纯量的生成列（generated column），然后在这个生成列上创建索引。回过头来，ERROR 3152，这个报错提示信息其实让人有点困惑，对没仔细阅读文档的人来说，可能会误以为 MySQL 不支持索引 JSON 列（Bug #81364<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>）。于是，在 MySQL 8.0 错误提示信息优化为：</p>
<blockquote>
<p>ERROR 3152 (42000): JSON column '%s' supports indexing only via generated columns on a specified JSON path.</p>
</blockquote>
<p>生成列以及在生成列上创建索引，是 MySQL 5.7 开始支持的新特性。但其实，在 SQL:2003 标准中，生成列就早已经被定义为可选特性，“Optional Features of SQL/Foundation:2003, T175 Generated columns”。这个特性在其他 DBMS 中很早就有支持。2007 年 9 月发布的 Oracle Database 11g 开始支持生成列，不过它们称之为称之为虚拟列（virtual column）。2008 年 8 月发布的 SQL Server 2008 开始支持计算列（computed column），实现的就是 SQL 标准中的生成列。在相近的时间点，MySQL 创建了WL#411: Computed virtual columns as MS SQL server has<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>。之后，MySQL 的社区贡献者 Andrey Zhakov 实现了 WL#411 描述的特性，并发布了实现的代码补丁<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup><sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup><sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>。可惜的是 MySQL 官方很长一段时间都没把这个补丁合并进来，直到 2015 年的 MySQL 5.7（7年后）才官方实现 WL#411<sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>，同时 WL#411 的标题也被更新为符合 SQL 标准术语的 “Generated columns”。与之相对比的是，2010 年 4 月发布的 MariaDB 5.2 就开始支持虚拟列<sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>，实现上同样也是基于 Andrey Zhakov 贡献的代码。关于生成列或虚拟列，Wikipedia 的 <code>Virtual column</code> 词条<sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>总结了各大 DBMS 的支持情况，可以参阅。总结下，标准 SQL 定义生成列的语法和 SQL Server 2008、Oracle 11g、MariaDB、MySQL 的区别<sup class="footnote-ref"><a href="#fn30" id="fnref30:1">[30:1]</a></sup><sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup>：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Standard             MSSQL 2008      Oracle 11g           MariaDB 10.1           MySQL 5.7               </span><br><span class="line">--------             -----------     ----------           ------------           ---------               </span><br><span class="line">column_name          column_name     column_name          column_name            column_name             </span><br><span class="line">[data type]                          [data type]          data_type              data type               </span><br><span class="line">GENERATED ALWAYS AS  AS              GENERATED ALWAYS AS  [GENERATED ALWAYS] AS  [GENERATED ALWAYS] AS   </span><br><span class="line">(expression)         (expression)    (expression)         (expression)           (expression)           </span><br><span class="line">                     [PERSISTENT]    [VIRTUAL]            [VIRTUAL | PERSISTENT] [VIRTUAL | STORED]     </span><br><span class="line">[constraints]        [constraints]   [constraints]        [constraints]          [constraints]          </span><br><span class="line">                                                          [COMMENT &#x27;string&#x27;]     [COMMENT &#x27;string&#x27;]</span><br></pre></td></tr></table></figure>
<p>回到正题，我们现在来试试 MySQL 的生成列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加生成列</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> tbl <span class="keyword">add</span> id <span class="type">int</span> <span class="keyword">as</span> (data <span class="operator">-</span><span class="operator">&gt;</span> &quot;$.id&quot;);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.15</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+------+</span></span><br><span class="line"><span class="operator">|</span> data                                          <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">1</span>, &quot;name&quot;: &quot;Will&quot;&#125;                     <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;id&quot;: <span class="number">2</span>, &quot;name&quot;: &quot;printf(\&quot;hello world\&quot;);&quot;&#125; <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>上面的示例，创建生成列 <code>id</code>，生成列对应的表达式是 <code>data -&gt; &quot;$.id&quot;</code>。现在再试试在生成列 <code>id</code> 上，创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在生成列上创建索引 idx_id</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index idx_id <span class="keyword">on</span> tbl (id);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行计划</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl <span class="keyword">where</span> id  <span class="operator">=</span> <span class="number">1</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tbl</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: idx_id</span><br><span class="line">          key: idx_id</span><br><span class="line">      key_len: <span class="number">5</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行计划</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl  <span class="keyword">where</span> data <span class="operator">-</span><span class="operator">&gt;</span> &quot;$.id&quot; <span class="operator">=</span> <span class="number">1</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tbl</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: idx_id</span><br><span class="line">          key: idx_id</span><br><span class="line">      key_len: <span class="number">5</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>从上面的执行计划可以看到，查询条件用 <code>id</code> 或者 <code>data -&gt; &quot;$.id&quot;</code> 都能使用索引 <code>idx_id</code>。</p>
<h1 id="JSON-二进制格式">JSON 二进制格式</h1>
<p>内部实现上，保存到数据库的 JSON 数据并非以 JSON 文本存储，而是二进制格式，具体可以参见，WL#8132: JSON datatype and binary storage format，当然也可以直接阅读源码 json_binary.h<sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup>、json_binary.cc<sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>或 doxygen<sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup>。</p>
<p>MySQL 的 JSON 二进制格式，其中有一点比较值得注意，WL#8132 提到：</p>
<blockquote>
<p>The keys are sorted, so that lookup can use binary search to locate the key quickly.</p>
</blockquote>
<p>就是，为了能利用二分搜索快速定位键，存入数据库的JSON 对象的键是被排序过的。来看下下面的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">truncate</span> tbl;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tbl <span class="keyword">values</span> (<span class="string">&#x27;&#123;&quot;b&quot;: &quot;c&quot;, &quot;a&quot;: &#123;&quot;y&quot;: 1, &quot;x&quot;: 2&#125;&#125;&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> data                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;&quot;a&quot;: &#123;&quot;x&quot;: <span class="number">2</span>, &quot;y&quot;: <span class="number">1</span>&#125;, &quot;b&quot;: &quot;c&quot;&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>上面的 SQL 可以看到，<code>insert</code> 写入时键并没有按次序排列，而用 <code>select</code> 将 JSON 数据反序列化读出，发现实际保存的键是有序的。排序规则是，先按字符串长度排序，若长度相同按字母排序。同样的，键关联的值，按键排序后的次序排列。对键排序，显然只能针对 JSON 对象，若要存储 JSON 数组，值按索引位置排序。</p>
<p>MySQL 5.7.22 新增 json_storage_size() 函数，用于返回 json 文档二进制表示占用的存储空间。先来看下 SQL 示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_storage_size(<span class="string">&#x27;&quot;abc&quot;&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_storage_size(<span class="string">&#x27;&quot;abc&quot;&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+</span></span><br><span class="line"><span class="operator">|</span>                          <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_storage_size(<span class="string">&#x27;[42, &quot;xy&quot;, &quot;abc&quot;]&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_storage_size(<span class="string">&#x27;[42, &quot;xy&quot;, &quot;abc&quot;]&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                                     <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> json_storage_size(<span class="string">&#x27;&#123;&quot;b&quot;: 42, &quot;a&quot;: &quot;xy&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> json_storage_size(<span class="string">&#x27;&#123;&quot;b&quot;: 42, &quot;a&quot;: &quot;xy&quot;&#125;&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                                        <span class="number">24</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>WL#8132 给出了 JSON 二进制格式的 BNF 语法描述。参考这个语法描述，可以推算出上文示例中的 <code>&quot;abc&quot;</code>、<code>[42, &quot;xy&quot;, &quot;abc&quot;]</code>、<code>&#123;&quot;b&quot;: 42, &quot;a&quot;: &quot;xy&quot;&#125;</code> 对应的二进制表示。先来看下 <code>&quot;abc&quot;</code> 纯量，语法推导过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">doc</span><br><span class="line">  =&gt; type value                     <span class="comment">// 使用产生式 doc ::= type value</span></span><br><span class="line">  =&gt; <span class="number">0x0c</span> value                     <span class="comment">// 使用产生式 type ::= 0x0c (utf8mb4 string 类型)</span></span><br><span class="line">  =&gt; <span class="number">0x0c</span> <span class="built_in">string</span>                    <span class="comment">// 使用产生式 value ::= string</span></span><br><span class="line">  =&gt; <span class="number">0x0c</span> data-length utf8mb4-data  <span class="comment">// 使用产生式 string ::= data-length utf8mb4-data</span></span><br><span class="line">  =&gt; <span class="number">0x0c</span> <span class="number">0x03</span> utf8mb4-data         <span class="comment">// 使用产生式 data-length ::= uint8*</span></span><br><span class="line">  =&gt; <span class="number">0x0c</span> <span class="number">0x03</span> <span class="number">0x61</span> <span class="number">0x62</span> <span class="number">0x63</span></span><br></pre></td></tr></table></figure>
<p>对应的二进制值，共 5 个字节，依次为 <code>0x0c 0x03 0x61 0x62 0x63</code>，其中 <code>0x61 0x62 0x63</code>，就是 16 进制表示的字符串 <code>abc</code>。占用 5个字节，与 json_storage_size() 函数返回的结果一致。相应的语法树如下：</p>
<p><img src="https://static.nullwy.me/mysql-jsonb-syntax-tree.png" alt="mysql-jsonb-syntax-tree-w350"></p>
<p>从二进制的角度看，纯量 <code>&quot;abc&quot;</code> 的 JSON 二进制表示如下：</p>
<p><img src="https://static.nullwy.me/mysql-jsonb-scalar.png" alt="mysql-jsonb-scalar-w350"></p>
<p><code>[42, &quot;xy&quot;, &quot;abc&quot;]</code> 的推导过程，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">doc </span><br><span class="line">  =&gt; type value                          <span class="comment">// 使用产生式 doc ::= type value</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="built_in">array</span>                          <span class="comment">// 使用产生式 type ::= 0x02 (small JSON array 类型)</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> element-count size value-entry* value*  <span class="comment">// 使用产生式 array ::= element-count size value-entry* value*</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> size value-entry* value*  <span class="comment">// 使用产生式 element-count ::= uint16 (使用 little-endian)</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> value-entry* value*  <span class="comment">// 使用产生式 size ::= uint16 (使用 little-endian)</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> type offset-or-inlined-value value-entry* value* <span class="comment">// 使用产生式 value-entry ::= type offset-or-inlined-value</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> offset-or-inlined-value value-entry* value* <span class="comment">// 使用产生式 type ::= 0x06 (uint16 类型)</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x2a</span> <span class="number">0x00</span> value-entry* value*  <span class="comment">// 使用产生式 offset-or-inlined-value ::= uint16</span></span><br><span class="line">  ... 省略</span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x2a</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x10</span> <span class="number">0x00</span> value*</span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x2a</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x10</span> <span class="number">0x00</span> <span class="built_in">string</span> value  <span class="comment">// 使用产生式 value ::= string</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x2a</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x10</span> <span class="number">0x00</span> data-length utf8mb4-data value  <span class="comment">// 使用产生式 string ::= data-length utf8mb4-data</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x2a</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x10</span> <span class="number">0x00</span> <span class="number">0x02</span> utf8mb4-data value <span class="comment">// 使用产生式 data-length ::= uint8*</span></span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x2a</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x10</span> <span class="number">0x00</span> <span class="number">0x02</span> <span class="number">0x78</span> <span class="number">0x78</span> value</span><br><span class="line">  ... 省略</span><br><span class="line">  =&gt; <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x14</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x2a</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x10</span> <span class="number">0x00</span> <span class="number">0x02</span> <span class="number">0x78</span> <span class="number">0x79</span> <span class="number">0x03</span> <span class="number">0x61</span> <span class="number">0x62</span> <span class="number">0x63</span></span><br></pre></td></tr></table></figure>
<p><code>[42, &quot;xy&quot;, &quot;abc&quot;]</code> 对应的二进制表示，共 21 个字节，依次为 <code>0x02 0x03 0x00 0x14 0x00 0x06 0x2a 0x00 0x0c 0x0d 0x00 0x0c 0x10 0x00 0x02 0x78 0x79 0x03 0x61 0x62 0x63</code>。如下图：</p>
<p><img src="https://static.nullwy.me/mysql-jsonb-array.png" alt="mysql-jsonb-array"></p>
<p>相对来说，产生式 <code>array ::= element-count size value-entry* value*</code>，是整个JSON 数组二进制表示语法的核心。<code>element-count</code>，表示元素个数。上图中，第 4、5 个字节是 <code>size</code> 字段，十进制值为 20（0x14），是完整二进制表示去掉开头 <code>type</code> 字段后的大小（文档没有明确这个字段的含义，不过通过源码推断出来）。另外，<code>value-entry</code> 由 <code>type</code> 和 <code>offset-or-inlined-value</code> 字段组成。<code>type</code> 很好理解，不做解释。<code>offset-or-inlined-value</code> 字段，官方文档给出了含义，含义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This field holds either the offset to where the value is stored,</span></span><br><span class="line"><span class="comment">// or the value itself if it is small enough to be inlined (that is,</span></span><br><span class="line"><span class="comment">// if it is a JSON literal or a small enough [u]int).</span></span><br><span class="line">offset-or-inlined-value ::=</span><br><span class="line">uint16 |   <span class="comment">// if used in small JSON object/array</span></span><br><span class="line">uint32     <span class="comment">// if used in large JSON object/array</span></span><br></pre></td></tr></table></figure>
<p>就是说，如果实际要保存的值足够小，将直接内联在这个字段中，否则将保存偏移量（offset），也就是指向实际值的指针。在示例中，保存 <code>xy</code> 对应的 offset 值为 13（0x0d），指向的相对地址是 14。因为这里的 offset 并不是以相对地址 0 为基准地址，是以相对地址 1 为基准地址（图中箭头 B 指向的位置），所以偏移量是 13 而不是 14（这个字段的明确含义也是从源码推断而来）。类似的，保存 <code>abc</code> 对应的 offset 值为 16（0x10），指向的相对地址是 17。</p>
<p>阅读文档容易发现，<code>element-count</code>、<code>size</code>、<code>offset</code> 字段占用的字节大小是固定的，小 JSON（64KB 以内）是 2 字节，大 JSON 是 4 字节。所以，若要查找 JSON 数组的第 <code>pos</code> 个元素的 <code>value-entry</code> 的偏移量，可以使用下面的式子快速定位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry_offset = offset_size * 2 + (1 + offset_size) * pos</span><br></pre></td></tr></table></figure>
<p>JSON 数组二进制表示的其他字段比较容易理解，文档都有解释，就不展开阐述了。</p>
<p>现在来看下，JSON 对象 <code>&#123;&quot;b&quot;: 42, &quot;a&quot;: &quot;xy&quot;&#125;</code> 的二进制表示，如下图：</p>
<p><img src="https://static.nullwy.me/mysql-jsonb-object.png" alt="mysql-jsonb-object"></p>
<p>对于 JSON 对象二进制表示的语法，核心的产生式是 <code>object ::= element-count size key-entry* value-entry* key* value*</code>。<code>element-count</code>、<code>size</code> 和 <code>value-entry</code> 字段，在 JSON 数组中也有，不再赘述。而 <code>key-entry</code> 字段，类似于 <code>value-entry</code>。<code>key-entry</code> 中的 <code>key-offset</code> 保存的是偏移量，是指向键的指针。另外，正如上文提到的 MySQL 会对 JSON 键排序，所以上图示例的第 20 和 21 个字节值分别是 <code>0x61</code>和 <code>0x62</code>，即 <code>a</code> 和 <code>b</code>，而非 <code>b</code> 和 <code>a</code>。同样的，键关联的值，按键排序后的次序排列，依次是 <code>&quot;xy&quot;</code> 和 <code>42</code>。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>MySQL 5.7 Reference Manual, What Is New in MySQL 5.7 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-nutshell.html">https://dev.mysql.com/doc/refman/5.7/en/mysql-nutshell.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>MySQL 5.7 Reference Manual, 12 Data Types, 12.6 The JSON Data Type <a href="http://dev.mysql.com/doc/refman/5.7/en/json.html">http://dev.mysql.com/doc/refman/5.7/en/json.html</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2012-09 PostgreSQL 9.2 released <a href="https://www.postgresql.org/about/news/postgresql-92-released-1415/">https://www.postgresql.org/about/news/postgresql-92-released-1415/</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>JSON Support in Oracle Database 12c Release 1 (12.1.0.2) <a href="https://oracle-base.com/articles/12c/json-support-in-oracle-database-12cr1">https://oracle-base.com/articles/12c/json-support-in-oracle-database-12cr1</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Oracle Database 12c Release 1 (12.1.0.2) New Features, 1.9 JSON Support <a href="https://docs.oracle.com/database/121/NEWFT/chapter12102.htm#NEWFT505">https://docs.oracle.com/database/121/NEWFT/chapter12102.htm#NEWFT505</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Facebook DocStore: Document column type [Deprecated] <a href="https://github.com/facebook/mysql-5.6/wiki/Document-column-type-%5BDeprecated%5D">https://github.com/facebook/mysql-5.6/wiki/Document-column-type-[Deprecated]</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2015-04 DocStore: Document Database for MySQL at Facebook (slides) <a href="https://web.archive.org/web/20161022061349/https://www.percona.com/live/mysql-conference-2015/sites/default/files/slides/Facebook%20DocStore%20Percona%202015.pdf">https://web.archive.org/web/20161022061349/https://www.percona.com/live/mysql-conference-2015/sites/default/files/slides/Facebook DocStore Percona 2015.pdf</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>2014-03 SQL/JSON Proposals, Part 1 <a href="https://www.wiscorp.com/pub/DM32.2-2014-00024R1_JSON-SQL-Proposal-1.pdf">https://www.wiscorp.com/pub/DM32.2-2014-00024R1_JSON-SQL-Proposal-1.pdf</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>2014-03 SQL/JSON Proposals, Part 2 <a href="https://www.wiscorp.com/pub/DM32.2-2014-00025r1-sql-json-part-2.pdf">https://www.wiscorp.com/pub/DM32.2-2014-00025r1-sql-json-part-2.pdf</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>2014-03 SQL Support for JSON (slides) <a href="https://web.archive.org/web/20150919002536/http://jtc1bigdatasg.nist.gov/_workshop/08_SQL_Support_for_JSON_abstract.pdf">https://web.archive.org/web/20150919002536/http://jtc1bigdatasg.nist.gov/_workshop/08_SQL_Support_for_JSON_abstract.pdf</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>2017-06 What’s New in SQL:2016 <a href="https://modern-sql.com/blog/2017-06/whats-new-in-sql-2016">https://modern-sql.com/blog/2017-06/whats-new-in-sql-2016</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>WL#7909: Server side JSON functions <a href="https://dev.mysql.com/worklog/task/?id=7909">https://dev.mysql.com/worklog/task/?id=7909</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>WL#8132: JSON datatype and binary storage format <a href="https://dev.mysql.com/worklog/task/?id=8132">https://dev.mysql.com/worklog/task/?id=8132</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>WL#8249: JSON comparator <a href="https://dev.mysql.com/worklog/task/?id=8249">https://dev.mysql.com/worklog/task/?id=8249</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>WL#8607: Inline JSON path expressions in SQL <a href="https://dev.mysql.com/worklog/task/?id=8607">https://dev.mysql.com/worklog/task/?id=8607</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>MySQL 5.7 Reference Manual, 13 Functions and Operators, 13.16 JSON Functions <a href="https://dev.mysql.com/doc/refman/5.7/en/json-functions.html">https://dev.mysql.com/doc/refman/5.7/en/json-functions.html</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>2015-04 JSON Labs Release: JSON Functions, Part 1 — Manipulation JSON Data <a href="http://mysqlserverteam.com/json-labs-release-json-functions-part-1-manipulation-json-data/">http://mysqlserverteam.com/json-labs-release-json-functions-part-1-manipulation-json-data/</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2015-04 JSON Labs Release: JSON Functions, Part 2 — Querying JSON Data <a href="http://mysqlserverteam.com/mysql-5-7-lab-release-json-functions-part-2-querying-json-data/">http://mysqlserverteam.com/mysql-5-7-lab-release-json-functions-part-2-querying-json-data/</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>JSONPath - XPath for JSON <a href="https://goessner.net/articles/JsonPath/">https://goessner.net/articles/JsonPath/</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>2015-10 Inline JSON Path Expressions in MySQL 5.7 <a href="http://mysqlserverteam.com/inline-json-path-expressions-in-mysql-5-7/">http://mysqlserverteam.com/inline-json-path-expressions-in-mysql-5-7/</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>PostgreSQL 11.10 Documentation, 9.15. JSON Functions and Operators <a href="https://www.postgresql.org/docs/11/functions-json.html">https://www.postgresql.org/docs/11/functions-json.html</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>What is the difference between <code>-&gt;&gt;</code> and <code>-&gt;</code> in Postgres SQL? <a href="https://stackoverflow.com/a/47270495">https://stackoverflow.com/a/47270495</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>2015-10 SQLite Release 3.9.0 <a href="https://sqlite.org/releaselog/3_9_0.html">https://sqlite.org/releaselog/3_9_0.html</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>SQLite: The JSON1 Extension <a href="https://www.sqlite.org/json1.html">https://www.sqlite.org/json1.html</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Bug #81364: Indexing JSON column should suggest generated columns <a href="https://bugs.mysql.com/bug.php?id=81364">https://bugs.mysql.com/bug.php?id=81364</a> <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>WL#411: Computed virtual columns as MS SQL server has <a href="https://web.archive.org/web/20080917094638/http://forge.mysql.com/worklog/task.php?id=411">https://web.archive.org/web/20080917094638/http://forge.mysql.com/worklog/task.php?id=411</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Bug #46491: Patch: Virtual columns (WL#411) <a href="https://bugs.mysql.com/bug.php?id=46491">https://bugs.mysql.com/bug.php?id=46491</a> <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>2008-09 MySQL virtual columns <a href="https://datacharmer.blogspot.com/2008/09/mysql-virtual-columns.html">https://datacharmer.blogspot.com/2008/09/mysql-virtual-columns.html</a> <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>MySQL virtual columns preview <a href="https://web.archive.org/web/20120629093123/http://forge.mysql.com/wiki/MySQL_virtual_columns_preview">https://web.archive.org/web/20120629093123/http://forge.mysql.com/wiki/MySQL_virtual_columns_preview</a> <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>WL#411: Generated columns <a href="https://dev.mysql.com/worklog/task/?id=411">https://dev.mysql.com/worklog/task/?id=411</a> <a href="#fnref30" class="footnote-backref">↩︎</a> <a href="#fnref30:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>MariaDB: Generated (Virtual and Persistent/Stored) Columns <a href="https://mariadb.com/kb/en/generated-columns/">https://mariadb.com/kb/en/generated-columns/</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Virtual column <a href="https://en.wikipedia.org/wiki/Virtual_column">https://en.wikipedia.org/wiki/Virtual_column</a> <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>2016-02 Generated columns in MariaDB and MySQL <a href="https://planet.mysql.com/entry/?id=5994068">https://planet.mysql.com/entry/?id=5994068</a> <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>MySQL 5.7 Source Code: sql/json_binary.h <a href="https://github.com/mysql/mysql-server/blob/5.7/sql/json_binary.h">https://github.com/mysql/mysql-server/blob/5.7/sql/json_binary.h</a> <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>MySQL 5.7 Source Code: sql/json_binary.cc <a href="https://github.com/mysql/mysql-server/blob/5.7/sql/json_binary.cc">https://github.com/mysql/mysql-server/blob/5.7/sql/json_binary.cc</a> <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>MySQL 8.0 Source Code Documentation: json_binary.h File Reference (doxygen) <a href="https://dev.mysql.com/doc/dev/mysql-server/8.0.16/json__binary_8h.html#details">https://dev.mysql.com/doc/dev/mysql-server/8.0.16/json__binary_8h.html#details</a> <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>软件开发书籍资料整理</title>
    <url>/2016/12/software-dev-books/</url>
    <content><![CDATA[<p>本文整理软件开发、项目管理、软件工程相关的书籍。</p>
<span id="more"></span>
<h1 id="开发类书籍">开发类书籍</h1>
<ol>
<li>2011-03 What is the single most influential book every programmer should read? (<a href="http://stackoverflow.com">stackoverflow.com</a>) <a href="https://news.ycombinator.com/item?id=2272722">https://news.ycombinator.com/item?id=2272722</a></li>
<li>2012-08 国外程序员推荐：每个程序员都应读的书 (译SO帖子) <a href="http://blog.jobbole.com/5886/">http://blog.jobbole.com/5886/</a></li>
<li>2011-08 Jurgen Appelo：2011年最热门的敏捷书籍排行榜 <a href="http://www.infoq.com/cn/news/2011/08/top-agile-books">http://www.infoq.com/cn/news/2011/08/top-agile-books</a></li>
</ol>
<h2 id="软件开发综合类书籍">软件开发综合类书籍</h2>
<ol>
<li>1993、2004，Steve McConnell，《代码大全》（<a href="http://en.wikipedia.org/wiki/Code_Complete">Code Complete</a>: A Practical Handbook of Software Construction, Microsoft Press, <a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1386629974&amp;sr=1-1&amp;keywords=Code+Complete">2nd</a> 2004），<a href="http://book.douban.com/subject/1477390/">豆瓣</a>：全书944页，1994年Jolt震撼大奖，1999–2002任<a href="http://en.wikipedia.org/wiki/IEEE_Software">IEEE Software</a>主编</li>
<li>2006，Pete Goodliffe，《编程匠艺》（Code Craft: The Practice of Writing Excellent Code, <a href="http://www.amazon.com/Code-Craft-Practice-Writing-Excellent/dp/1593271190">amazon</a>），<a href="http://book.douban.com/subject/3210669/">豆瓣</a>：全书582页</li>
</ol>
<h2 id="设计模式与重构类书籍（代码组织结构、修改、阅读）">设计模式与重构类书籍（代码组织结构、修改、阅读）</h2>
<ol>
<li>1994，GoF，《设计模式：可复用面向对象软件的基础》（<a href="http://en.wikipedia.org/wiki/Design_Patterns">Design Patterns</a>: Elements of Reusable Object-Oriented Software, <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">amazon</a>），<a href="http://book.douban.com/subject/1052241/">豆瓣</a></li>
<li>2001、2004，Shalloway &amp; Trott，**《**<strong>设计模式解析</strong>》（Design Patterns Explained, <a href="http://www.amazon.com/Design-Patterns-Explained-Perspective-Object-Oriented/dp/0321247140">2nd</a> 2004），<a href="http://www.ituring.com.cn/book/94">图灵2010</a>，<a href="http://book.douban.com/subject/5360960/">豆瓣</a>：全书312页，Java描述</li>
<li>2012，《元素模式》（Elemental Design Patterns, <a href="http://www.amazon.com/Elemental-Design-Patterns-Jason-Smith/dp/0321711920">amazon</a>），<a href="http://book.douban.com/subject/25908396/">豆瓣</a></li>
<li>Martin Fowler， <a href="http://en.wikipedia.org/wiki/Martin_Fowler">wiki</a>：</li>
</ol>
<ul>
<li>1996，《分析模式：可复用的对象模型》（Analysis Patterns: Reusable Object Models, <a href="http://www.amazon.com/Analysis-Patterns-Reusable-Object-Models/dp/0201895420">amazon</a>），<a href="http://book.douban.com/subject/4832380/">豆瓣</a></li>
<li>1999，《重构：改善既有代码的设计》（Refactoring: Improving the Design of Existing Code, <a href="http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672">amazon</a>），<a href="http://www.refactoring.com/catalog/">home</a>，<a href="http://book.douban.com/subject/4262627/">豆瓣</a>：经典，内容类似参考手册形式，可读性不高</li>
<li>2002，《<strong>企业应用架构模式（Po****EAA）</strong>》（Patterns of Enterprise Application Architecture, <a href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420">amazon</a>），<a href="http://www.martinfowler.com/books/eaa.html">home</a>，<a href="http://book.douban.com/subject/4826290/">豆瓣</a></li>
</ul>
<ol start="5">
<li>Robert C. Martin，<a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">wiki</a>：1991年创立Object Mentor公司[<a href="http://www.objectmentor.com/omCompany/omi_company_index.html">ref</a>]</li>
</ol>
<ul>
<li>2002，《<strong>敏捷软件开发：原则、模式与实践（PPP</strong>**）<strong>》（Agile Software Development: Principles, Patterns and Practices, <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445">amazon</a>），<a href="http://book.douban.com/subject/1140457/">豆瓣</a>：全书476页，2003年Jolt震撼大奖，该书面向代码层面，最早整理</strong>汇编<a href="http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29">SOLID</a>原则**</li>
<li>2008，《<strong>代码整洁之道</strong>》（Clean Code: A Handbook of Agile Software Craftsmanship, <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">amazon</a>），<a href="http://book.douban.com/subject/4199741/">豆瓣</a>：全书388页，每个程序员都应读的最具影响力的书排名第13，“虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子”[<a href="http://blog.jobbole.com/5886/">ref</a>]</li>
<li>2011，《<strong>程序员的职业素养</strong>》（The Clean Coder: A Code of Conduct for Professional Programmers, <a href="http://www.amazon.com/The-Clean-Coder-Professional-Programmers/dp/0137081073">amazon</a>），<a href="http://book.douban.com/subject/11614538/">豆瓣</a>：全书178页，内容充斥着作者自己经历故事，大量围绕“我”的文字，不够精简，很难抓到作者阐述要点</li>
</ul>
<ol start="6">
<li>2000，<a href="http://en.wikipedia.org/wiki/Douglas_C._Schmidt">Schmidt</a>, <a href="http://en.wikipedia.org/wiki/Michael_Stal">Stal</a>, Buschmann, Rohnert，《<strong>面向模式的软件体系结构，卷2：用于并发和网络化对象的模式（****POSA）</strong>》（Pattern-Oriented Software Architecture, <a href="http://www.amazon.com/Pattern-Oriented-Software-Architecture-Concurrent-Networked/dp/0471606952">amazon</a>），共5卷<a href="http://www.ituring.com.cn/search?q=%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">图灵</a>，<a href="http://www.ituring.com.cn/book/982">图灵2013</a>，<a href="http://book.douban.com/subject/25755594/">豆瓣</a></li>
</ol>
<h2 id="其他书籍">其他书籍</h2>
<ol>
<li>2004，Joshua Kerievsky，《<strong>重构与模式</strong>》（Refactoring to Patterns, <a href="http://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/dp/0321213351">amazon</a>），<a href="http://book.douban.com/subject/5360962/">豆瓣</a>：2005年Jolt生产力大奖，amazon有评论批评该书例子过于复杂[<a href="http://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/product-reviews/0321213351/">ref</a>]</li>
<li>2004，Michael Feathers，《<strong>修改代码的艺术</strong>》（Working Effectively with Legacy Code, <a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">amazon</a>），<a href="http://book.douban.com/subject/2248759/">豆瓣</a>：作者Object Mentor公司成员，该书更直白的书名应为“遗留代码修改FAQ”，简介“本书是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作，而且从涵盖面和深度上都超过了前两部经典”</li>
<li>2011，Boswell &amp; Foucher，《<strong>编写可读代码的艺术</strong>》（The Art of Readable Code, <a href="http://shop.oreilly.com/product/9780596802301.do">O'Reilly</a>, <a href="http://www.amazon.com/The-Readable-Code-Theory-Practice/dp/0596802293">amazon</a>），<a href="http://book.douban.com/subject/10797189/">豆瓣</a>：全书178页</li>
<li>2003，<a href="http://en.wikipedia.org/wiki/Diomidis_Spinellis">Diomidis Spinellis</a>，《<strong>代码阅读</strong>》（Code Reading: The Open Source Perspective, <a href="http://www.amazon.com/Code-Reading-Open-Source-Perspective/dp/0201799405">amazon</a>），<a href="http://book.douban.com/subject/11509671/">豆瓣</a>：2004年Jolt生产力大奖</li>
<li>2006，<a href="http://en.wikipedia.org/wiki/Diomidis_Spinellis">Diomidis Spinellis</a>，《<strong>代码质量</strong>》（Code Quality: The Open Source Perspective, <a href="http://www.amazon.com/Code-Quality-Open-Source-Perspective/dp/0321166078">amazon</a>），<a href="http://book.douban.com/subject/11509673/">豆瓣</a>：2007年Jolt生产力大奖</li>
<li>1998，《反模式：危机中软件架构和项目的重构》（AntiPatterns, <a href="http://www.amazon.com/AntiPatterns-Refactoring-Software-Architectures-Projects/dp/0471197130">amazon</a>），<a href="http://book.douban.com/subject/2364818/">豆瓣</a>：1999年Jolt生产力大奖</li>
<li>2014，《<strong>软件设计重构</strong>》（Refactoring for Software Design Smells） ，<a href="https://book.douban.com/subject/26854236/">豆瓣</a></li>
</ol>
<h2 id="软件代码实例书籍">软件代码实例书籍</h2>
<ol>
<li>2008，Oram &amp; Wilson，《<strong>开源软件架构 AOSA</strong>》（The Architecture of Open Source Applications, <a href="http://amzn.com/1105571815%20">amazon</a>），<a href="http://www.ituring.com.cn/book/1143">图灵</a>（卷1、卷2均有部分翻译），<a href="http://aosabook.org/en/index.html">home</a>：Oram是O'Reilly Media的编辑，Wilson是Dr. Dobb's 杂志的特约编辑</li>
<li>2010，Oram &amp; Wilson，《<strong>软件之道：软件开发争议问题剖析</strong>》（Making Software: What Really Works, and Why We Believe It, <a href="http://shop.oreilly.com/product/9780596808303.do">O'Reilly</a>, <a href="http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321">amazon</a>），<a href="http://book.douban.com/subject/7564420/">豆瓣</a></li>
<li>2007，Oram &amp; Wilson，《<strong>代码之美：38位大师级程序员解释其思考方式</strong>》（Beautiful Code: Leading Programmers Explain How They Think, O'Reilly, <a href="http://www.amazon.com/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047">amazon</a>），<a href="http://book.douban.com/subject/3224524/">豆瓣</a>：2008年Jolt震撼大奖</li>
<li>2009，<a href="http://en.wikipedia.org/wiki/Diomidis_Spinellis">Diomidis Spinellis</a>，《<strong>架构之美</strong>》（Beautiful Archiecture: Leading Thinkers Reveal the Hidden Beauty in Software Design, O'Reilly, <a href="http://amzn.com/059651798X">amazon</a>），<a href="http://book.douban.com/subject/4086029/">豆瓣</a>：编者是《<strong>代码阅读</strong>》作者</li>
</ol>
<p><strong>AOSA部分译文：</strong></p>
<ol>
<li>AOSA 卷1：NoSQL生态系统 <a href="http://www.oschina.net/translate/the-nosql-ecosystem">http://www.oschina.net/translate/the-nosql-ecosystem</a></li>
<li>AOSA 卷4 <a href="https://github.com/aosabook/500lines">https://github.com/aosabook/500lines</a></li>
<li>2014-07 AOSA: 500 Lines or Less (Early preview) (<a href="http://github.com">github.com</a>) <a href="https://news.ycombinator.com/item?id=8004077">https://news.ycombinator.com/item?id=8004077</a></li>
</ol>
<h2 id="编程实践与ThoughtWorks书籍">编程实践与ThoughtWorks书籍</h2>
<ol>
<li>1999，<a href="http://en.wikipedia.org/wiki/Andy_Hunt_%28author%29">Andy Hunt</a> &amp; <a href="http://en.wikipedia.org/wiki/Dave_Thomas_%28programmer%29">David Thomas</a>，《<strong>注重实效的程序员</strong>》（<a href="http://en.wikipedia.org/wiki/The_Pragmatic_Programmer">The Pragmatic Programmer</a>: From Journeyman to Master,<a href="http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X">amazon</a>），<a href="http://book.douban.com/subject/5387402/">豆瓣</a>：两位作者是敏捷宣言17人，“Pragmatic Bookshelf”系列书籍第1本，两位作者为“Pragmatic Programmers, LLC”公司创立者[<a href="https://pragprog.com/about">ref</a>]</li>
<li>2006，Subramaniam &amp; <a href="http://en.wikipedia.org/wiki/Andy_Hunt_%28author%29">Andy Hunt</a>，《<strong>敏捷开发修炼：高效程序员的45个习惯</strong>》（Practices of an Agile Developer, Pragmatic, <a href="http://www.amazon.com/Practices-Agile-Developer-Pragmatic-Bookshelf/dp/097451408X">amazon</a>），<a href="http://book.douban.com/subject/4164024/">豆瓣</a>：2007年Jolt生产力大奖</li>
<li>2008，<a href="http://en.wikipedia.org/wiki/Andy_Hunt_%28author%29">Andy Hunt</a>，《<strong>程序员的思维修炼：开发认知潜能的九堂课</strong>》（Pragmatic Thinking and Learning, Pragmatic, <a href="http://www.amazon.com/Pragmatic-Thinking-Learning-Refactor-Programmers/dp/1934356050">amazon</a>）：注重实效的思考与学习</li>
<li>2008，Neal Ford，《<strong>卓有成效的程序员</strong>》（The Productive Programmer, O'Reilly, <a href="http://amzn.com/0596519788">amazon</a>），<a href="http://book.douban.com/subject/3558788/">豆瓣</a>：Neal Ford is an Application Architect at ThoughtWorks</li>
<li>2008，《软件开发沉思录：ThoughtWorks文集》（The Thoughtworks Anthology, Pragmatic, <a href="http://amzn.com/193435614X">amazon</a>），<a href="http://book.douban.com/subject/4031959/">豆瓣</a></li>
<li>2012，《软件开发与创新：ThoughtWorks文集》（The ThoughtWorks Anthology, Volume 2, Pragmatic, <a href="http://amzn.com/193435614X">amazon</a>），<a href="http://book.douban.com/subject/25827296/">豆瓣</a></li>
</ol>
<hr>
<ol>
<li>2005，Rothman &amp; Derby，《<strong>门后的秘密</strong>》（Behind Closed Doors: Secrets of Great Management, <a href="http://pragprog.com/book/rdbcd/behind-closed-doors">Pragmatic</a>），<a href="http://book.douban.com/subject/5401859/">豆瓣</a></li>
<li>2005，Richardson &amp; Gwaltney，《<strong>软件项目成功之道</strong>》（Ship it! A Practical Guide to Successful Software Projects, <a href="http://pragprog.com/book/prj/ship-it">Pragmatic</a>, <a href="http://www.amazon.com/Practical-Guide-Successful-Software-Projects/dp/0974514047">amazon</a>），<a href="http://book.douban.com/subject/6748308/">豆瓣</a></li>
<li>2007，Rothman，《<strong>项目管理修炼之道</strong>》，（Manage It!: Your Guide to Modern, Pragmatic Project Management, <a href="http://pragprog.com/book/jrpm/manage-it">Pragmatic</a>），<a href="http://book.douban.com/subject/4058336/">豆瓣</a>：2008年Jolt生产力大奖</li>
<li>2009，Paul Butcher，《<strong>软件调试修炼之道</strong>》（Debug It!: Find, Repair, and Prevent Bugs in Your Code, <a href="http://pragprog.com/book/pbdp/debug-it">Pragmatic</a>）</li>
<li>2009，《软件开发者路线图》（Apprenticeship Patterns: Guidance for the Aspiring Software Craftsman,<a href="http://shop.oreilly.com/product/9780596518387.do">O'Reilly</a>, <a href="http://www.amazon.com/Apprenticeship-Patterns-Guidance-Aspiring-Craftsman/dp/0596518382">amazon</a>），<a href="http://book.douban.com/subject/4924164/">豆瓣</a></li>
</ol>
<h1 id="软件工程项目管理类">软件工程项目管理类</h1>
<p><a href="https://en.wikipedia.org/wiki/Template:Software_engineering">https://en.wikipedia.org/wiki/Template:Software_engineering</a><br>
<a href="https://en.wikipedia.org/wiki/History_of_software_engineering">https://en.wikipedia.org/wiki/History_of_software_engineering</a></p>
<h2 id="综合类书籍">综合类书籍</h2>
<ol>
<li>2002，<a href="http://en.wikipedia.org/wiki/Robert_L._Glass">Robert Glass</a>，<a href="https://academic.microsoft.com/#/detail/2572363743">msa</a>，《<strong>软件工程的事实与谬误</strong>》（Facts and Fallacies of Software Engineering, <a href="http://a.co/5OhARBG">amazon</a>），<a href="http://book.douban.com/subject/1723351/">豆瓣</a></li>
</ol>
<h2 id="轻量级软件开发方法（XP与Scrum）">轻量级软件开发方法（XP与Scrum）</h2>
<ol>
<li>1999、2005，<a href="http://en.wikipedia.org/wiki/Kent_Beck">Kent Beck</a>，《解析极限编程：拥抱变化（XPE）》（Extreme Programming <strong>Explained</strong>: Embrace Change, <a href="http://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0321278658">2nd</a> 2005），<a href="http://book.douban.com/subject/6828074/">豆瓣</a>：2000年Jolt生产力大奖</li>
<li>2000，<a href="http://en.wikipedia.org/wiki/Kent_Beck">Beck</a> &amp; <a href="http://en.wikipedia.org/wiki/Martin_Fowler">Fowler</a>，《规划极限编程》（Planning Extreme Programming, <a href="http://www.amazon.com/Planning-Extreme-Programming-Kent-Beck/dp/0201710919">amazon</a>），<a href="http://book.douban.com/subject/1231825/">豆瓣</a></li>
<li>2001，Pete McBreen，《<strong>软件工艺</strong>》（Software Craftsmanship: The New Imperative, <a href="http://www.amazon.com/Software-Craftsmanship-The-New-Imperative/dp/0201733862">amazon</a>），<a href="http://book.douban.com/subject/1237464/">豆瓣</a>：2002年Jolt生产力大奖</li>
<li>2002，Kent Beck，《测试驱动开发（TDD）》（<a href="http://en.wikipedia.org/wiki/Test-Driven_Development_by_Example">Test-Driven Development</a>: By Example, <a href="http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530">amazon</a>），<a href="http://book.douban.com/subject/1230036/">豆瓣</a>：2003年Jolt生产力大奖</li>
<li>2007，Kent Beck，《实现模式》（Implementation Patterns, AW, <a href="http://www.amazon.com/Implementation-Patterns-Kent-Beck/dp/0321413091">amazon</a>），<a href="http://book.douban.com/subject/20415000/">豆瓣</a></li>
<li>2004，<a href="http://en.wikipedia.org/wiki/Ken_Schwaber">Ken Schwaber</a>，《<strong>Scrum敏捷项目管理</strong>》（Agile Project Management with Scrum. Microsoft Press, <a href="http://www.amazon.com/Agile-Project-Management-Microsoft-Professional/dp/073561993X">amazon</a>），<a href="http://book.douban.com/subject/2327024/">豆瓣</a></li>
<li>2001、2006，<a href="http://en.wikipedia.org/wiki/Alistair_Cockburn">Alistair Cockburn</a>，《<strong>敏捷软件开发</strong>》（Agile Software Development: The Cooperative Game, 2nd 2006, <a href="http://www.amazon.com/Agile-Software-Development-Cooperative-Edition/dp/0321482751">amazon</a>），<a href="http://book.douban.com/subject/3017834/">豆瓣</a>：2002年Jolt生产力大奖、2007年Jolt震撼大奖，该书面向项目管理层面</li>
<li>2007，Shore &amp; Warden，《<strong>敏捷开发的艺术</strong>》（The Art of Agile Development, <a href="http://www.amazon.com/Art-Agile-Development-James-Shore/dp/0596527675">amazon</a>），<a href="http://book.douban.com/subject/4037534/">豆瓣</a></li>
<li>2009，Mike Cohn，《<strong>Scrum敏捷软件开发</strong>》（Succeeding with Agile: Software Development using Scrum），<a href="http://book.douban.com/subject/5334585/">豆瓣</a></li>
<li>2008，Henrik Kniberg，《<strong>硝烟中的Scrum和XP</strong>》，infoq <a href="http://www.infoq.com/cn/minibooks/scrum-xp-from-the-trenches">minibook</a></li>
<li>2011，Henrik Kniberg，《<strong>精益开发实战：用看板管理大型项目</strong>》（Lean from the Trenches: Managing Large-Scale Projects with Kanban, <a href="http://www.amazon.com/Lean-Trenches-Managing-Large-Scale-Projects/dp/1934356859">amazon</a>），<a href="http://book.douban.com/subject/11620809/">豆瓣</a></li>
</ol>
<p>2009-05 敏捷书籍推荐 <a href="http://www.infoq.com/cn/news/2009/05/recommended-agile-books">http://www.infoq.com/cn/news/2009/05/recommended-agile-books</a><br>
2010-09 DZone's Top 10 Agile and Lean Development Books <a href="http://agile.dzone.com/articles/dzones-top-10-agile-and-lean">http://agile.dzone.com/articles/dzones-top-10-agile-and-lean</a><br>
2010-08 最热门的敏捷书籍 <a href="http://www.infoq.com/cn/news/2010/08/top-agile-books">http://www.infoq.com/cn/news/2010/08/top-agile-books</a><br>
2011-08 2011年最热门的敏捷书籍排行榜 <a href="http://www.infoq.com/cn/news/2011/08/top-agile-books">http://www.infoq.com/cn/news/2011/08/top-agile-books</a></p>
<hr>
<h2 id="软件项目管理（Fred-Brooks-Tom-DeMarco）">软件项目管理（Fred Brooks &amp; Tom DeMarco）</h2>
<ol>
<li>1975、1995，Fred Brooks，《<strong>人月神话：大型系统开发管理文集</strong>》（<a href="http://en.wikipedia.org/wiki/The_Mythical_Man-Month">The Mythical Man-Month</a>: Essays on Software Engineering, AW, 2nd 1995, <a href="http://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959">amazon</a>），<a href="http://book.douban.com/subject/2230248/">豆瓣</a></li>
<li>2010，Fred Brooks，《<strong>设计原本：计算机科学巨匠Frederick P.Brooks的思考</strong>》（The Design of Design: Essays from a Computer Scientist, AW, <a href="http://www.amazon.com/Design-Essays-Computer-Scientist/dp/0201362988">amazon</a>），<a href="http://book.douban.com/subject/5406042/">豆瓣</a></li>
<li>1987、1999，Tom DeMarco，《<strong>人件</strong>》（<a href="http://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams">Peopleware</a>: Productive Projects and Teams, <a href="http://www.amazon.com/Peopleware-Productive-Projects-Teams-Second/dp/0932633439">2nd</a> 1999, <a href="http://amzn.com/0321934113">3rd</a> 2013），<a href="http://book.douban.com/subject/1108725/">豆瓣</a>，第3版<a href="http://book.douban.com/subject/25956450/">豆瓣</a></li>
<li>2012，《<strong>进化：从孤胆极客到高效团队</strong>》（Team Geek, <a href="http://amzn.com/1449302440">amazon</a>），<a href="http://book.douban.com/subject/21372237/">豆瓣</a>：2013年Jolt大奖提名，两位作者为Google项目团队的负责人</li>
<li>2007，《软件人才管理的艺术》（Managing Humans, <a href="http://amzn.com/159059844X">amazon</a>），<a href="http://book.douban.com/subject/4999476/">豆瓣</a></li>
<li>1997，Tom DeMarco，《<strong>最后期限</strong>》（The Deadline: A Novel About Project Management, <a href="http://www.amazon.com/Deadline-Novel-About-Project-Management/dp/0932633390">amazon</a>），<a href="http://book.douban.com/subject/1231972/">豆瓣</a>：1998年Jolt生产力大奖</li>
<li>2003，Tom DeMarco，《<strong>与熊共舞：软件项目风险管理</strong>》（Waltzing with Bears, <a href="http://www.amazon.com/Waltzing-Bears-Managing-Software-Projects/dp/0932633609">amazon</a>），<a href="http://book.douban.com/subject/1151462/">豆瓣</a>：2004年Jolt震撼大奖</li>
<li>2008，Tom DeMarco，《<strong>项目百态：深入理解软件项目行为模式</strong>》（Adrenaline Junkies and Template Zombies: Understanding Patterns of Project Behavior, <a href="http://www.amazon.com/Adrenaline-Junkies-Template-Zombies-Understanding/dp/0932633676">amazon</a>），<a href="http://book.douban.com/subject/5954810/">豆瓣</a>：2009年Jolt震撼大奖</li>
<li>2005、2008，Scott Berkun，《<strong>项目管理之美</strong>》（Making Things Happen: Mastering Project Management, O'Reilly, <a href="http://www.amazon.com/Making-Things-Happen-Mastering-Management/dp/0596517718">amazon</a>），<a href="http://book.douban.com/subject/3668161/">豆瓣</a>：2006年Jolt生产力大奖</li>
<li>1999、2003，Edward Yourdon，《<strong>死亡之旅</strong>》（Death March, Prentice Hall, 2nd 2003, <a href="http://www.amazon.com/Death-March-2nd-Edward-Yourdon/dp/013143635X">amazon</a>），<a href="http://book.douban.com/subject/6967574/">豆瓣</a></li>
</ol>
<p><strong>著名软件项目</strong></p>
<ol>
<li>1994，《<strong>观止：微软创建NT和未来的夺命狂奔</strong>》（Show Stopper!, <a href="http://www.amazon.com/Show-Stopper-Breakneck-Generation-Microsoft/dp/0029356717">amazon</a>），<a href="http://book.douban.com/subject/3699395/">豆瓣</a></li>
<li>2008，Scott Rosenberg，《<strong>梦断代码</strong>》（Dreaming In Code, <a href="http://www.amazon.com/Dreaming-Code-Programmers-Transcendent-Software/dp/1400082471">amazon</a>），<a href="http://book.douban.com/subject/6526454/">豆瓣</a></li>
</ol>
<hr>
<p><strong>Steve McConnell，</strong><a href="http://en.wikipedia.org/wiki/Steve_McConnell">wiki</a></p>
<ol>
<li>1993，<a href="http://en.wikipedia.org/wiki/Steve_Maguire">Steve Maguire</a>，《编程精粹：编写高质量C语言代码》（Writing Solid Code, <a href="http://www.amazon.com/Writing-Solid-Microsoft-Programming-Series/dp/1556155514">amazon</a>），<a href="http://book.douban.com/subject/3406939/">豆瓣</a>：与代码大全齐名，1994年Jolt生产力大奖</li>
<li>1996，《<strong>快速软件开发</strong>》（Rapid Development: Taming Wild Software Schedules, Microsoft Press, <a href="http://www.amazon.com/Rapid-Development-Taming-Software-Schedules/dp/1556159005">amazon</a>），<a href="http://book.douban.com/subject/3151486/">豆瓣</a>：1997年Jolt震撼大奖</li>
<li>1997，《微软项目：求生法则》（Software Project Survival Guide, Microsoft Press, <a href="http://www.amazon.com/Software-Project-Survival-Guide-Practices/dp/1572316217">amazon</a>），<a href="http://book.douban.com/subject/1061546/">豆瓣</a></li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 学习笔记</title>
    <url>/2017/11/zookeeper-note/</url>
    <content><![CDATA[<h1 id="ZooKeeper-介绍">ZooKeeper 介绍</h1>
<p>ZooKeeper（<a href="https://en.wikipedia.org/wiki/Apache_ZooKeeper">wiki</a>，<a href="http://zookeeper.apache.org/">home</a>，<a href="https://github.com/apache/zookeeper">github</a>） 是用于分布式应用的开源的分布式协调服务。通过暴露简单的原语，分布式应用能在之上构建更高层的服务，如同步、配置管理和组成员管理等。在设计上易于编程开发，并且数据模型使用了熟知的文件系统目录树结构 [ <a href="http://zookeeper.apache.org/doc/current/zookeeperOver.html">doc</a> ]。</p>
<span id="more"></span>
<h2 id="共识与-Paxos">共识与 Paxos</h2>
<p>在介绍 ZooKeeper 之前，有必要了解下 Paxos 和 Chubby。2006 年 Google 在 OSDI 发表关于 <a href="https://academic.microsoft.com/paper/2624304035">Bigtable</a> 和 <a href="https://academic.microsoft.com/paper/1992479210">Chubby</a> 的两篇会议论文，之后再在 2007 年 PODC 会议上发表了论文“<a href="https://academic.microsoft.com/paper/2143149536">Paxos Made Live</a>”，介绍 Chubby 底层实现的共识（<a href="https://en.wikipedia.org/wiki/Consensus_%28computer_science%29">consensus</a>）协议 Multi-Paxos，该协议对 Lamport 的原始 Paxos 算法做了改进，提高了运行效率 [ <a href="https://zhuanlan.zhihu.com/p/21466932">ref</a> ]。Chubby 作为锁服务被 Google 应用在 GFS 和 Bigtable 中。受 Chubby 的影响，来自 Yahoo 研究院的 Benjamin Reed 和 Flavio Junqueira 等人开发了被业界称为开源版的 Chubby 的 ZooKeeper（内部实现事实上稍有不同 [ <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab+vs.+Paxos">ref</a> ]），底层的共识协议为 ZAB。Lamport 的 Paxos 算法出了名的难懂，如何让算法更加可理解（understandable），便成了 Stanford 博士生 Diego Ongaro 的研究课题。Diego Ongaro 在 2014 年发表了介绍 <a href="https://academic.microsoft.com/paper/2156580773">Raft</a> 算法的论文，“In search of an understandable consensus algorithm”。Raft 是可理解版的 Paxos，很快就成为解决共识问题的流行协议之一。这些类 Paxos 协议和 Paxos 系统之间的关系，如下 [ <a href="https://academic.microsoft.com/paper/2414647798">Ailijiang2016</a> ]：</p>
<img width="500" alt="Paxos 协议和 Paxos 系统" title="Paxos 协议和 Paxos 系统" src="https://static.nullwy.me/paxos-protocols-vs-paxos-systems.png">
<p>Google 的 Chubby 没有开源，在云计算和大数据技术的风口下，Yahoo 开源的 ZooKeeper 便在工业界流行起来。ZooKeeper 重要的时间线如下：</p>
<ul>
<li>2007 年 11 月 ZooKeeper 1.0 在 SourceForge 上发布 [ <a href="https://sourceforge.net/p/zookeeper/news/">ref</a> ]</li>
<li>2008 年 6 月开始从 SourceForge 迁移到 Apache [ <a href="https://issues.apache.org/jira/browse/ZOOKEEPER-1">ref</a> ]，在 10 月 Zookeeper 3.0 发布，并成为 Hadoop 的子项目 [ <a href="https://sourceforge.net/p/zookeeper/mailman/message/20659436/">ref1</a> <a href="https://issues.apache.org/jira/projects/ZOOKEEPER/versions/12313216">ref2</a> ]</li>
</ul>
<p>关于 ZooKeeper 名字的来源，Flavio Junqueira 和 Benjamin Reed 在介绍 <a href="https://book.douban.com/subject/26766807/">ZooKeeper 的书</a>中有如下阐述：</p>
<blockquote>
<p>ZooKeeper 由雅虎研究院开发。我们小组在进行 ZooKeeper 的开发一段时间之后，开始推荐给其他小组，因此我们需要为我们的项目起一个名字。与此同时，小组也一同致力于 Hadoop 项目，参与了很多动物命名的项目，其中有广为人知的 Apache Pig 项目（<a href="http://pig.apache.org">http://pig.apache.org</a>）。我们在讨论各种各样的名字时，一位团队成员提到我们不能再使用动物的名字了，因为我们的主管觉得这样下去会觉得我们生活在动物园中。大家对此产生了共鸣，分布式系统就像一个动物园，混乱且难以管理，而 ZooKeeper 就是将这一切变得可控。</p>
</blockquote>
<h2 id="体系结构">体系结构</h2>
<p>ZooKeeper 服务由若干台服务器构成，其中的一台通过 ZAB 原子广播协议选举作为主控服务器（leader），其他的作为从属服务器（follower）。客户端可以通过 TCP 协议连接任意一台服务器。如果客户端是读操作请求，则任意一个服务器都可以直接响应请求；如果是更新数据操作（写数据或者更新数据）。则只能由主控服务器来协调更新操作；如果客户端连接的是从属服务器，则从属服务器会将更新据请求转发到主控服务器，由其完成更新操作。主控服务器将所有更新操作序列化，利用 ZAB 协议将数据更新请求通知所有从属服务器，ZAB 保证更新操作。</p>
<p><img src="https://static.nullwy.me/zookeeper-service.png" alt="zookeeper-service" title="ZooKeeper 架构图"></p>
<p>读和写操作，如下图所示 [ <a href="https://book.douban.com/subject/26336214/">Haloi2015</a> ]：<br>
<img width="600" alt="ZooKeeper 读和写操作" title="ZooKeeper 读和写操作" src="https://static.nullwy.me/zookeeper-read-write.png"></p>
<p>ZooKeeper 的任意一台服务器都可以响应客户端的读操作，这样可以提高吞吐量。Chubby 在这点上与 ZooKeeper 不同，所有读/写操作都由主控服务器完成，从属服务器只是为了提高整个协调系统的可用性，即主控服务器发生故障后能够在从属服务器中快速选举出新的主控服务器。在带来高吞吐量优势的同时，ZooKeeper 这样做也带来潜在的问题：客户端可能会读到过期数据，因为即使主控服务器已经更新了某个内存数据，但是 ZAB 协议还未能将其广播到从属服务器。为了解决这一问题，在 ZooKeeper 的接口 API 函数中提供了 sync 操作，应用可以根据需要在读数据前调用该操作，其含义是：接收到 sync 命令的从属服务器从主控服务器同步状态信息，保证两者完全一致。这样如果在读操作前调用 sync 操作，则可以保证客户端一定可以读取到最新状态的数据。</p>
<h2 id="数据模型">数据模型</h2>
<p>ZooKeeper 所提供的命名空间跟标准文件系统很相似。路径中一系列元素是用斜杠（/）分隔的。每个节点在 ZooKeper 命名空间中是用路径来识别的。在 ZooKeeper 术语下，节点被称为 znode。默认每个 znode 最大只能存储 1M 数据（可以通过配置参数修改），这与 Chubby 一样是出于避免应用将协调系统当作存储系统来用。znode 只能使用绝对路径，相对路径不能被 ZooKeeper 识别。znode 命名可以是任意 Unicode 字符。唯一的例外是，名称&quot;/zookeeper&quot;。命名为&quot;/zookeeper&quot;的 znode，由 ZooKeeper 系统自动生成，用配额（quota）管理。</p>
<img width="300" alt="ZooKeeper 数据模型" title="ZooKeeper 数据模型" src="https://static.nullwy.me/zookeeper-data-model.jpg">
<h1 id="ZooKeeper-使用">ZooKeeper 使用</h1>
<h2 id="安装与配置">安装与配置</h2>
<p>ZooKeeper 安装与启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ brew info zookeeper</span><br><span class="line">zookeeper: stable 3.4.10 (bottled), HEAD</span><br><span class="line">Centralized server <span class="keyword">for</span> distributed coordination of services</span><br><span class="line">https://zookeeper.apache.org/</span><br><span class="line">... 省略</span><br><span class="line">$ brew install zookeeper</span><br><span class="line">$ zkServer start  <span class="comment"># 启动</span></span><br><span class="line">$ zkServer stop   <span class="comment"># 终止</span></span><br><span class="line">$ zkServer <span class="built_in">help</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/etc/zookeeper/zoo.cfg</span><br><span class="line">Usage: ./zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125;</span><br></pre></td></tr></table></figure>
<p>若不修改配置文件，默认是<strong>单机模式</strong>启动。若要使用<strong>集群模式</strong>，需要修改 <code>/usr/local/etc/zookeeper/zoo.cfg</code>（默认路径）。示例 <code>zoo.cfg</code> [ <a href="http://zookeeper.apache.org/doc/current/zookeeperStarted.html#sc_RunningReplicatedZooKeeper">doc</a> ]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=192.168.211.11:2888:3888</span><br><span class="line">server.2=192.168.211.12:2888:3888</span><br><span class="line">server.3=192.168.211.13:2888:3888</span><br></pre></td></tr></table></figure>
<p><code>clientPort</code>：客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。<br>
<code>server.X=YYY:A:B</code></p>
<ul>
<li>X：表示的服务器编号；</li>
<li>YYY：表示服务器的ip地址；</li>
<li>A：表示服务器节点间的通信端口，用于 follower 和 leader 节点的通信；</li>
<li>B：表示选举端口，表示选举新 leader 时服务器间相互通信的端口，当 leader 挂掉时，其余服务器会相互通信，选择出新的 leader。</li>
</ul>
<p>若想在单台主机上试验集群模式，可以将 <code>YYY</code> 都修改为 <code>localhost</code>，并且让两个端口 <code>A:B</code> 也相互不同（比如：2888:3888, 2889:3889, 2890:3890），即可实现<strong>伪集群模式</strong>。示例 <code>zoo.cfg</code> 如下 [ <a href="http://zookeeper.apache.org/doc/current/zookeeperStarted.html#sc_RunningReplicatedZooKeeper">doc</a> ]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.1=localhost:2888:3888</span><br><span class="line">server.2=localhost:2889:3889</span><br><span class="line">server.3=localhost:2890:3890</span><br></pre></td></tr></table></figure>
<p>zkCli 支持的全部命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ zkCli <span class="built_in">help</span></span><br><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">	<span class="built_in">stat</span> path [watch]</span><br><span class="line">	<span class="built_in">set</span> path data [version]</span><br><span class="line">	<span class="built_in">ls</span> path [watch]</span><br><span class="line">	delquota [-n|-b] path</span><br><span class="line">	ls2 path [watch]</span><br><span class="line">	setAcl path acl</span><br><span class="line">	setquota -n|-b val path</span><br><span class="line">	<span class="built_in">history</span></span><br><span class="line">	redo cmdno</span><br><span class="line">	printwatches on|off</span><br><span class="line">	delete path [version]</span><br><span class="line">	<span class="built_in">sync</span> path</span><br><span class="line">	listquota path</span><br><span class="line">	rmr path</span><br><span class="line">	get path [watch]</span><br><span class="line">	create [-s] [-e] path data acl</span><br><span class="line">	addauth scheme auth</span><br><span class="line">	quit</span><br><span class="line">	getAcl path</span><br><span class="line">	close</span><br><span class="line">	connect host:port</span><br></pre></td></tr></table></figure>
<h2 id="节点类型及其操作">节点类型及其操作</h2>
<p>Zookeeper 支持两种类型节点：持久节点（persistent znode）和临时节点（ephemeral znode）。持久节点不论客户端会话情况，一直存在，只有当客户端显式调用删除操作才会消失。而临时节点则不同，会在客户端会话结束或者发生故障的时候被 ZooKeeper 系统自动清除。另外，这两种类型的节点都可以添加是否是顺序（sequential）的特性，这样就有了：持久顺序节点和临时顺序节点。</p>
<p><strong>(1) 持久节点（persistent znode）</strong></p>
<p>使用 <code>create</code> 创建节点（默认持久节点），以及使用 <code>get</code> 查看该节点：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ zkCli -server 127.0.0.1  <span class="comment"># 启动客户端</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] create /zoo <span class="string">&#x27;hello zookeeper&#x27;</span></span><br><span class="line">Created /zoo</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] get /zoo</span><br><span class="line">hello zookeeper</span><br><span class="line">cZxid = 0x8d</span><br><span class="line">ctime = Thu Nov 08 20:42:55 CST 2017</span><br><span class="line">mZxid = 0x8d</span><br><span class="line">mtime = Thu Nov 08 20:42:55 CST 2017</span><br><span class="line">pZxid = 0x8d</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 15</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p><code>create</code> 创建子节点，以及使用 <code>ls</code> 查看全部子节点：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] create /zoo/duck <span class="string">&#x27;&#x27;</span></span><br><span class="line">Created /zoo/duck</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create /zoo/goat <span class="string">&#x27;&#x27;</span></span><br><span class="line">Created /zoo/goat</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] create /zoo/cow <span class="string">&#x27;&#x27;</span></span><br><span class="line">Created /zoo/cow</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] <span class="built_in">ls</span> /zoo</span><br><span class="line">[cow, goat, duck]</span><br></pre></td></tr></table></figure>
<p><code>delete</code> 删除节点，以及使用 <code>rmr</code> 递归删除：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] delete /zoo/duck</span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] <span class="built_in">ls</span> /zoo</span><br><span class="line">[cow, goat]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] delete /zoo</span><br><span class="line">Node not empty: /zoo</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] rmr /zoo</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] <span class="built_in">ls</span> /zoo</span><br><span class="line">Node does not exist: /zoo</span><br></pre></td></tr></table></figure>
<p><strong>(2) 临时节点（ephemeral znode）</strong></p>
<p>和持久节点不同，临时节点不能创建子节点：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ zkCli  <span class="comment"># 启动第1个客户端</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] create -e /node <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">Created /node</span><br><span class="line">[zk: localhost:2181(CONNECTED) 40] get /node</span><br><span class="line">hello</span><br><span class="line">cZxid = 0x97</span><br><span class="line">ctime = Thu Nov 08 21:01:25 CST 2017</span><br><span class="line">mZxid = 0x97</span><br><span class="line">mtime = Thu Nov 08 21:01:25 CST 2017</span><br><span class="line">pZxid = 0x97</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x161092a0ff30000</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] create /node/child <span class="string">&#x27;&#x27;</span></span><br><span class="line">Ephemerals cannot have children: /node/child</span><br></pre></td></tr></table></figure>
<p>临时节点在客户端会话结束或者发生故障的时候被 ZooKeeper 系统自动清除。现在试验下的针对临时节点自动清除的监视：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ zkCli  <span class="comment"># 启动第2个客户端</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] create -e /node <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">Node already exists: /node</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] <span class="built_in">stat</span> /node <span class="literal">true</span></span><br><span class="line">cZxid = 0x97</span><br><span class="line">ctime = Thu Nov 08 21:01:25 CST 2017</span><br><span class="line">mZxid = 0x97</span><br><span class="line">mtime = Thu Nov 08 21:01:25 CST 2017</span><br><span class="line">pZxid = 0x97</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x161092a0ff30000</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p>若客户端1，退出 <code>quit</code> 或崩溃，客户端2将收到监视事件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2]</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDeleted path:/node</span><br></pre></td></tr></table></figure>
<p><strong>(3) 顺序节点（sequential znode）</strong></p>
<p>顺序节点在其创建时 ZooKeeper 会自动在 znode 名称上附加上顺序编号。顺序编号，由父 znode 维护，并且单调递增。顺序编号，由 4 字节的有符号整数组成，并被格式化为 0 填充的 10 位数字。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /test <span class="string">&#x27;&#x27;</span></span><br><span class="line">Created /test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -s /test/seq <span class="string">&#x27;&#x27;</span></span><br><span class="line">Created /test/seq0000000000</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create -s /test/seq <span class="string">&#x27;&#x27;</span></span><br><span class="line">Created /test/seq0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create -s /test/seq <span class="string">&#x27;&#x27;</span></span><br><span class="line">Created /test/seq0000000002</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] <span class="built_in">ls</span> /test</span><br><span class="line">[seq0000000000, seq0000000001, seq0000000002]</span><br></pre></td></tr></table></figure>
<h2 id="客户端-API">客户端 API</h2>
<style>
  table {
    font-family: consolas, Menlo
  }
</style>
<p>ZooKeeper 提供的主要 znode 操作 API 如下表所示：</p>
<table>
<thead>
<tr>
<th>API 操作</th>
<th>描述</th>
<th>CLI 命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>创建 znode</td>
<td>create</td>
</tr>
<tr>
<td>delete</td>
<td>删除 znode</td>
<td>delete/rmr/delquota</td>
</tr>
<tr>
<td>exists</td>
<td>检查 znode 是否存在</td>
<td>stat</td>
</tr>
<tr>
<td>getChildren</td>
<td>读取 znode 全部的子节点</td>
<td>ls/ls2</td>
</tr>
<tr>
<td>getData</td>
<td>读取 znode 数据</td>
<td>get/listquota</td>
</tr>
<tr>
<td>setData</td>
<td>设置 znode 数据</td>
<td>set/setquota</td>
</tr>
<tr>
<td>getACL</td>
<td>读取 znode 的 ACL</td>
<td>getACL</td>
</tr>
<tr>
<td>setACL</td>
<td>设置 znode 的 ACL</td>
<td>setACL</td>
</tr>
<tr>
<td>sync</td>
<td>同步</td>
<td>sync</td>
</tr>
</tbody>
</table>
<p>Java 的 <a href="https://static.javadoc.io/org.apache.zookeeper/zookeeper/3.4.11/org/apache/zookeeper/ZooKeeper.html">ZooKeeper</a> 类实现了上述提供的 API。</p>
<p>Zookeeper 底层是 Java 实现，<code>zkCli</code> 命令行工具底层也是 Java 实现，对应的 Java 实现类为 <code>org.apache.zookeeper.ZooKeeperMain</code> [ <a href="https://github.com/apache/zookeeper/blob/release-3.5.3/bin/zkCli.sh">src1</a> <a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/ZooKeeperMain.java">src2</a> ]。ZooKeeper 3.5.x 下，CLI 命令与底层实现 API 对应关系：</p>
<table>
<thead>
<tr>
<th>命名 CLI</th>
<th>Java API (<a href="https://static.javadoc.io/org.apache.zookeeper/zookeeper/3.4.11/org/apache/zookeeper/ZooKeeper.html">ZooKeeper</a> 类)</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/AddAuthCommand.java">addauth</a> scheme auth</td>
<td>public void addAuthInfo(String scheme, byte[] auth)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/CloseCommand.java">close</a></td>
<td>public void close()</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/CreateCommand.java">create</a> [-s] [-e] path data acl</td>
<td>public String create(final String path, byte data[], List<ACL> acl, CreateMode createMode)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java">delete</a> path [version]</td>
<td>public void delete(String path, int version)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/DelQuotaCommand.java">delquota</a> [-n|-b] path</td>
<td>public void delete(String path, int version)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/GetCommand.java">get</a> path [watch]</td>
<td>public byte[] getData(String path, boolean watch, Stat stat)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/GetAclCommand.java">getAcl</a> path</td>
<td>public List<ACL> getACL(final String path, Stat stat)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/ListQuotaCommand.java">listquota</a> path</td>
<td>public byte[] getData(String path, boolean watch, Stat stat)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/LsCommand.java">ls</a> path [watch]</td>
<td>public List<String> getChildren(String path, Watcher watcher, Stat stat)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/Ls2Command.java">ls2</a> path [watch]</td>
<td>-</td>
</tr>
<tr>
<td>quit</td>
<td>public void close()</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/DeleteAllCommand.java">rmr</a> path</td>
<td>public void delete(final String path, int version)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/SetCommand.java">set</a> path data [version]</td>
<td>public Stat setData(String path, byte[] data, int version)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/SetAclCommand.java">setAcl</a> path acl</td>
<td>public Stat setACL(final String path, List<ACL> acl, int aclVersion)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/SetQuotaCommand.java">setquota</a> -n|-b val path</td>
<td>public Stat setData(String path, byte[] data, int version)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/StatCommand.java">stat</a> path [watch]</td>
<td>public Stat exists(String path, boolean watch)</td>
</tr>
<tr>
<td><a href="https://github.com/apache/zookeeper/blob/release-3.5.3/src/java/main/org/apache/zookeeper/cli/SyncCommand.java">sync</a> path</td>
<td>public void sync(String path, AsyncCallback.VoidCallback cb, Object ctx)</td>
</tr>
</tbody>
</table>
<h2 id="监视点（watch）">监视点（watch）</h2>
<p>ZooKeeper 提供了处理变化的重要机制一一监视点（watch）。通过监视点，客户端可以对指定的 znode 节点注册一个通知请求，在发生变化时就会收到一个单次的通知。当应用程序注册了一个监视点来接收通知，匹配该监视点条件的第一个事件会触发监视点的通知，并且最多只触发一次。例如，当 znode 节点也被删除，客户端需要知道该变化，客户端在 /z 节点执行 exists 操作并设置监视点标志位，等待通知，客户端会以回调函数的形式收到通知。</p>
<p>ZooKeeper 的 API 中的读操作：getData、getChildren 和 exists，均可以选择在读取的 znode 节点上设置监视点。使用监视点机制，我们需要实现 <a href="https://static.javadoc.io/org.apache.zookeeper/zookeeper/3.4.11/org/apache/zookeeper/Watcher.html">Watcher</a> 接口类，该接口唯一方法为 process：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span></span><br></pre></td></tr></table></figure>
<p><a href="https://static.javadoc.io/org.apache.zookeeper/zookeeper/3.4.11/org/apache/zookeeper/WatchedEvent.html">WatchedEvent</a> 数据结构包括以下信息：</p>
<ul>
<li>ZooKeeper会话状态（KeeperState)：Disconnected、SyncConnected、AuthFailed、ConnectedReadOnly 、SaslAuthenticated、Expired。</li>
<li>事件类型（EventType)：NodeCreated 、NodeDeleted 、NodeDataChanged、NodeChildrenChanged 和 None 。</li>
<li>若事件类型不是 None，还包括 znode 路径。</li>
</ul>
<p>若收到 WatchedEvent， 在 zkCli 中会输出类似如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WatchedEvent state:SyncConnected type:NodeDeleted path:/node</span><br></pre></td></tr></table></figure>
<p>监视点有两种类型：数据监视点和子节点监视点。创建、删除或设置一个 znode 节点的数据都会触发数据监视点，exists 和 getData 这两个操作可以设置数据监视点。只有 getChildren 操作可以设置子节点监视点，这种监视点只有在 znode 子节点创建或删除时才被触发。对于每种事件类型，我们通过以下调用设置监视点：</p>
<p>NodeCreated<br>
   通过 exists 调用设置一个监视点。<br>
NodeDeleted<br>
   通过 exists 或 getData 调用设置监视点。<br>
NodeDataChanged<br>
   通过 exists 或getData 调用设置监视点。<br>
NodeChildrenChanged<br>
   通过 getChildren 调用设置监视点。</p>
<h2 id="Java-示例代码">Java 示例代码</h2>
<p>在 Java 下使用 ZooKeeper 需要先添加如下 <a href="http://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper">maven</a> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>ZookeeperDemo</code> 示例，展示了建立连接会话，以及对 znode 的创建、读取、修改、删除和设置监视点等操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> KeeperException, InterruptedException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建服务器连接</span></span><br><span class="line">        <span class="type">ZooKeeper</span> <span class="variable">zk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;127.0.0.1:2181&quot;</span>, <span class="number">100</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="comment">// 监控所有被触发的事件</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;WatchedEvent state:%s type:%s path:%s\n&quot;</span>, event.getState(), event.getType(), event.getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        zk.create(<span class="string">&quot;/zoo&quot;</span>, <span class="string">&quot;hello ZooKeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        <span class="comment">// 读取节点数据</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(zk.getData(<span class="string">&quot;/zoo&quot;</span>, <span class="literal">false</span>, stat)));</span><br><span class="line">        printStat(stat);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子节点</span></span><br><span class="line">        zk.create(<span class="string">&quot;/zoo/duck&quot;</span>, <span class="string">&quot;hello duck&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        zk.create(<span class="string">&quot;/zoo/goat&quot;</span>, <span class="string">&quot;hello goat&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        zk.create(<span class="string">&quot;/zoo/cow&quot;</span>, <span class="string">&quot;hello cow&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取子节点列表，并设置监视点</span></span><br><span class="line">        System.out.println(zk.getChildren(<span class="string">&quot;/zoo&quot;</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取子节点数据，并设置监视点</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(zk.getData(<span class="string">&quot;/zoo/duck&quot;</span>, <span class="literal">true</span>, <span class="literal">null</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改子节点数据</span></span><br><span class="line">        zk.setData(<span class="string">&quot;/zoo/duck&quot;</span>, <span class="string">&quot;hi duck&quot;</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取修改后的子节点数据</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(zk.getData(<span class="string">&quot;/zoo/duck&quot;</span>, <span class="literal">true</span>, <span class="literal">null</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除子节点</span></span><br><span class="line">        zk.delete(<span class="string">&quot;/zoo/duck&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        zk.delete(<span class="string">&quot;/zoo/goat&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        zk.delete(<span class="string">&quot;/zoo/cow&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 删除父节点</span></span><br><span class="line">        zk.delete(<span class="string">&quot;/zoo&quot;</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        zk.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printStat</span><span class="params">(Stat stat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cZxid = 0x&quot;</span> + Long.toHexString(stat.getCzxid()));</span><br><span class="line">        System.out.println(<span class="string">&quot;ctime = &quot;</span> + DateFormatUtils.format(stat.getCtime(), <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;mZxid = 0x&quot;</span> + Long.toHexString(stat.getMzxid()));</span><br><span class="line">        System.out.println(<span class="string">&quot;mtime = &quot;</span> + DateFormatUtils.format(stat.getMtime(), <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;pZxid = 0x&quot;</span> + Long.toHexString(stat.getPzxid()));</span><br><span class="line">        System.out.println(<span class="string">&quot;cversion = &quot;</span> + stat.getCversion());</span><br><span class="line">        System.out.println(<span class="string">&quot;dataVersion = &quot;</span> + stat.getVersion());</span><br><span class="line">        System.out.println(<span class="string">&quot;aclVersion = &quot;</span> + stat.getAversion());</span><br><span class="line">        System.out.println(<span class="string">&quot;ephemeralOwner = 0x&quot;</span> + Long.toHexString(stat.getEphemeralOwner()));</span><br><span class="line">        System.out.println(<span class="string">&quot;dataLength = &quot;</span> + stat.getDataLength());</span><br><span class="line">        System.out.println(<span class="string">&quot;numChildren = &quot;</span> + stat.getNumChildren());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br><span class="line">hello ZooKeeper</span><br><span class="line">cZxid = 0x1e1</span><br><span class="line">ctime = 2017-11-20 12:18:36</span><br><span class="line">mZxid = 0x1e1</span><br><span class="line">mtime = 2017-11-20 12:18:36</span><br><span class="line">pZxid = 0x1e1</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 15</span><br><span class="line">numChildren = 0</span><br><span class="line">[cow, goat, duck]</span><br><span class="line">hello duck</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/zoo/duck</span><br><span class="line">hi duck</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDeleted path:/zoo/duck</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/zoo</span><br></pre></td></tr></table></figure>
<h2 id="ZooInspector">ZooInspector</h2>
<p>ZooInspector 是 ZooKeeper 3.3.0 开始官方提供的可视化查看和编辑 ZooKeeper 实例的工具 [ <a href="https://issues.apache.org/jira/browse/ZOOKEEPER-678">ZOOKEEPER-678</a> ]。源码位于目录 <code>src/contrib/zooinspector</code> 下，GitHub 地址为：<a href="https://github.com/apache/zookeeper/tree/master/src/contrib/zooinspector">link</a>。可以根据 <code>README.txt</code> 的说明运行使用。或者可以直接用 ZOOKEEPER-678 下提供的可执行 jar 包。</p>
<img width="500" alt="ZooInspector" title="ZooInspector" src="https://static.nullwy.me/zookeeper-ZooInspector.png">
<h1 id="参考资料">参考资料</h1>
<ol>
<li>官方文档：ZooKeeper <a href="http://zookeeper.apache.org/doc/current/index.html">http://zookeeper.apache.org/doc/current/index.html</a></li>
<li>2010-11 许令波：分布式服务框架 Zookeeper <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></li>
<li>ZooKeeper：分布式过程协同技术详解，Benjamin Reed &amp; Flavio Junqueira，2013，<a href="https://book.douban.com/subject/26766807/">豆瓣</a></li>
<li>Apache ZooKeeper Essentials, Haloi 2015，<a href="https://book.douban.com/subject/26336214/">豆瓣</a></li>
<li>从Paxos到Zookeeper，阿里倪超 2015，<a href="https://book.douban.com/subject/26292004/">豆瓣</a></li>
<li>大数据日知录：架构与算法，张俊林 2014，第5章 分布式协调系统，<a href="https://book.douban.com/subject/25984046/">豆瓣</a></li>
<li>2010，Patrick Hunt, Mahadev Konar, Flavio Paiva Junqueira, Benjamin Reed: <strong>ZooKeeper: Wait-free Coordination for Internet-scale Systems</strong>. USENIX ATC 2010，<a href="http://dblp.org/rec/conf/usenix/HuntKJR10">dblp</a>，<a href="https://academic.microsoft.com/paper/192446467">msa</a>，<a href="https://www.usenix.org/conference/usenix-atc-10/zookeeper-wait-free-coordination-internet-scale-systems">usenix</a></li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>共识</tag>
        <tag>Paxos</tag>
      </tags>
  </entry>
  <entry>
    <title>栈帧与调用惯例</title>
    <url>/2018/01/stack-frame-calling-convention/</url>
    <content><![CDATA[<h1 id="栈与栈帧">栈与栈帧</h1>
<p>要想知道函数是怎么被调用的，需要了解栈帧和调用惯例相关知识。<a href="https://book.douban.com/subject/3652388/">俞甲子2009</a> 的“<strong>第10章 内存: 栈与堆</strong>”对相关概念有很好的介绍。本文是对相关知识的学习笔记。</p>
<span id="more"></span>
<img width="600" alt="栈与栈帧布局" title="栈与栈帧布局" src="https://static.nullwy.me/stack-frame-layout-zh.png">
<p>附注，栈帧之间的划分边界，其实有两种不一样说法。在有些资料中 [ <a href="https://en.wikipedia.org/wiki/Call_stack#Structure">wikipedia</a>; <a href="https://book.douban.com/subject/3652388/">俞甲子2009</a> ]，callee 参数被划分在 callee 栈帧，但在 Intel 官方一些权威文档中 [ Intel ASDM, <a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html">Vol.1</a>, Ch.6; Intel <a href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI">X86-psABI</a> ]，callee 参数被划分在 caller 栈帧。</p>
<h1 id="调用惯例">调用惯例</h1>
<p>调用惯例，规定以下内容：(1) 函数参数的传递顺序和方式；(2) 栈的清理方式；(3) 名称修饰（<a href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a>）。常见的 x86 调用惯例列表有：cdecl（C 语言默认）、stdcall（Win32 API 标准）、fastcall、pascal。这些调用惯例如下下表所示（更加全面的列表参见 <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions">wikipedia</a>）：</p>
<table>
<thead>
<tr>
<th>调用惯例</th>
<th>栈帧清理</th>
<th>参数传递</th>
<th>名称修饰</th>
</tr>
</thead>
<tbody>
<tr>
<td>cdel</td>
<td>调用者 caller</td>
<td>从右至左入栈 RTL</td>
<td>下划线+函数名，如 _sum</td>
</tr>
<tr>
<td>stdcall</td>
<td>被调用者 callee</td>
<td>从右至左入栈 RTL</td>
<td>下划线+函数名+@+参数字节数，如 _sum@8</td>
</tr>
<tr>
<td>fastcall</td>
<td>被调用者 callee</td>
<td>头两参数存入寄存器 ECX 和 EDX，其余参数从右至左入栈 RTL</td>
<td>@+函数名+@+参数字节数，如 @sum@8</td>
</tr>
<tr>
<td>pascal</td>
<td>被调用者 callee</td>
<td>从左至右入栈 LTR</td>
<td>较为复杂，参见 pascal 文档</td>
</tr>
</tbody>
</table>
<p>下面举例说明，cdecl 和 stdcall 两种调用惯例。</p>
<h2 id="cdecl-调用惯例">cdecl 调用惯例</h2>
<p>cdecl，调用者负责清理堆栈（caller clean-up），参数从右至左（Right-to-Left，RTL）压入栈。举例说明 [ <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">ref1</a> <a href="https://www.codeproject.com/Articles/1388/Calling-Conventions-Demystified">ref2</a> ]：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cdecl 调用惯例</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">int</span> c = sum(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>编译器生成的等价汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 调用者清理堆栈（caller clean-up），参数 RTL 入栈</span><br><span class="line">push 3</span><br><span class="line">push 2</span><br><span class="line">call _sum      ; 将返回地址压入栈, 同时 sum 的地址装入 eip</span><br><span class="line">add  esp, 8    ; 清理堆栈, 两个参数占用 8 字节</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; sum 函数等价汇编代码</span><br><span class="line">; // function prolog</span><br><span class="line">push ebp  </span><br><span class="line">mov  ebp, esp</span><br><span class="line">; // return a + b;</span><br><span class="line">mov  eax, [ebp + 12] </span><br><span class="line">add  eax, [ebp + 8]  ; 返回值规定保存在 eax</span><br><span class="line">; // function epilog</span><br><span class="line">mov  esp, ebp        ; 设置栈顶 esp</span><br><span class="line">pop  ebp             ; 恢复 old ebp</span><br><span class="line">ret                  ; 将栈中保存的返回地址装入 eip</span><br></pre></td></tr></table></figure>
<h2 id="stdcall-调用惯例">stdcall 调用惯例</h2>
<p>stdcall，被调用者负责清理堆栈（callee clean-up），参数从右至左（Right-to-Left，RTL）压入栈。举例说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stdcall 调用惯例</span></span><br><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">int</span> c = sum(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>编译器生成的等价汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 被调用者清理堆栈（callee clean-up），参数 RTL 入栈</span><br><span class="line">push 3</span><br><span class="line">push 2</span><br><span class="line">call _sum@8      ; 将返回地址压入栈, 同时 sum 的地址装入 eip</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; sum 函数等价汇编代码</span><br><span class="line">; // function prolog</span><br><span class="line">push ebp  </span><br><span class="line">mov  ebp, esp</span><br><span class="line">; // return a + b;</span><br><span class="line">mov  eax, [ebp + 12] </span><br><span class="line">add  eax, [ebp + 8]  ; 返回值规定保存在 eax</span><br><span class="line">; // function epilog</span><br><span class="line">mov  esp, ebp        ; 设置栈顶 esp</span><br><span class="line">pop  ebp             ; 恢复 old ebp</span><br><span class="line">ret  8               ; 清理堆栈，并将栈中保存的返回地址装入 eip</span><br></pre></td></tr></table></figure>
<h1 id="gcc-汇编代码">gcc 汇编代码</h1>
<p><code>hello1.c</code> 文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    sum(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成汇编代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -m32 -S -masm=intel hello1.c -o hello1.s</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -m32 hello1.s -o hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello || <span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>生成的 <code>hello1.s</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  .section  __TEXT,__text,regular,pure_instructions</span><br><span class="line">  .macosx_version_min 10, 12</span><br><span class="line">  .intel_syntax noprefix</span><br><span class="line">  .globl  _sum</span><br><span class="line">  .p2align  4, 0x90</span><br><span class="line">_sum:                                   ## @sum</span><br><span class="line">## BB#0:</span><br><span class="line">  push  ebp</span><br><span class="line">  mov  ebp, esp</span><br><span class="line">  sub  esp, 8                       ; 预先分配 8 字节栈空间，保存 2 个布局变量</span><br><span class="line">  mov  eax, dword ptr [ebp + 12]    ; 堆栈中读取参数 2</span><br><span class="line">  mov  ecx, dword ptr [ebp + 8]     ; 堆栈中读取参数 1</span><br><span class="line">  mov  dword ptr [ebp - 4], ecx     ; 布局变量 1</span><br><span class="line">  mov  dword ptr [ebp - 8], eax     ; 布局变量 2</span><br><span class="line">  mov  eax, dword ptr [ebp - 4]</span><br><span class="line">  add  eax, dword ptr [ebp - 8]</span><br><span class="line">  add  esp, 8                       ; 清理 8 字节栈空间</span><br><span class="line">  pop  ebp</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">  .globl  _main</span><br><span class="line">  .p2align  4, 0x90</span><br><span class="line">_main:                                  ## @main</span><br><span class="line">## BB#0:</span><br><span class="line">  push  ebp</span><br><span class="line">  mov  ebp, esp</span><br><span class="line">  sub  esp, 40                     ; 预先分配 40 字节栈空间</span><br><span class="line">  mov  eax, 1</span><br><span class="line">  mov  ecx, 2</span><br><span class="line">  mov  dword ptr [ebp - 4], 0</span><br><span class="line">  mov  dword ptr [esp], 1</span><br><span class="line">  mov  dword ptr [esp + 4], 2</span><br><span class="line">  mov  dword ptr [ebp - 8], eax ## 4-byte Spill</span><br><span class="line">  mov  dword ptr [ebp - 12], ecx ## 4-byte Spill</span><br><span class="line">  call  _sum</span><br><span class="line">  mov  ecx, 3</span><br><span class="line">  mov  edx, 4</span><br><span class="line">  mov  dword ptr [esp], 3</span><br><span class="line">  mov  dword ptr [esp + 4], 4</span><br><span class="line">  mov  dword ptr [ebp - 16], eax ## 4-byte Spill</span><br><span class="line">  mov  dword ptr [ebp - 20], ecx ## 4-byte Spill</span><br><span class="line">  mov  dword ptr [ebp - 24], edx ## 4-byte Spill</span><br><span class="line">  call  _sum</span><br><span class="line">  xor  ecx, ecx</span><br><span class="line">  mov  dword ptr [ebp - 28], eax ## 4-byte Spill</span><br><span class="line">  mov  eax, ecx</span><br><span class="line">  add  esp, 40                  ; 清理 40 字节栈空间</span><br><span class="line">  pop  ebp</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>
<p>GCC 生成的汇编代码并没有使用 <code>push</code> 而是通过 <code>sub  esp, 40</code> 直接预先分配栈空间，然后使用 <code>mov</code> 指令将参数写进栈中，清理栈使用 <code>add  esp, 40</code>。逻辑上，还是符合 cdecl 调用惯例，调用者负责清理堆栈（caller clean-up），参数从右至左（Right-to-Left，RTL）压入栈。这样做的好处是，如果同时多次调用 <code>sum</code>，清理栈空间的指令，只需要最后的时候调用一次就可以了。统一使用 <code>sub esp</code> 和 <code>add esp</code> 去操作 esp 值，避免 <code>push</code> 指令操作 esp。</p>
<p>现在再来看看，stdcall 调用惯例下，GCC 生成的汇编代码。把 <code>sum</code> 函数改为 <code>__stdcall</code>，运行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -m32 -S -masm=intel hello2.c -o hello2.s</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff -C1 hello1.s hello2.s</span></span><br></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">*** hello1.s    Thu Feb 05 22:43:59 2018</span></span><br><span class="line"><span class="comment">--- hello2.s    Thu Feb 05 22:45:24 2018</span></span><br><span class="line"><span class="comment">***************</span></span><br><span class="line"><span class="meta">*** 18,20 ****</span></span><br><span class="line">    pop  ebp</span><br><span class="line"><span class="addition">!   ret</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">--- 18,20 ----</span></span><br><span class="line">    pop  ebp</span><br><span class="line"><span class="addition">!   ret  8</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">***************</span></span><br><span class="line"><span class="meta">*** 35,36 ****</span></span><br><span class="line"><span class="meta">--- 35,37 ----</span></span><br><span class="line">    call  _sum</span><br><span class="line"><span class="addition">+   sub  esp, 8</span></span><br><span class="line">    mov  ecx, 3</span><br><span class="line"><span class="comment">***************</span></span><br><span class="line"><span class="meta">*** 43,44 ****</span></span><br><span class="line"><span class="meta">--- 44,46 ----</span></span><br><span class="line">    call  _sum</span><br><span class="line"><span class="addition">+   sub  esp, 8</span></span><br><span class="line">    xor  ecx, ecx</span><br></pre></td></tr></table></figure>
<h1 id="反汇编代码">反汇编代码</h1>
<p>反汇编 <code>objdump</code>、<code>gdb</code>/<code>lldb</code>，或者商业工具使用，IDA Pro 或者 Hopper Disassembler [ <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Disassemblers_and_Decompilers#x86_Disassemblers">wiki</a> ]</p>
<h2 id="objdump-反汇编">objdump 反汇编</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gobjdump -d -Mintel hello1                # 使用 GNU objdump</span><br><span class="line">$ objdump -d -x86-asm-syntax=intel hello1   # 使用 llvm-objdump</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello1:	file format Mach-O 32-bit i386</span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line">__text:</span><br><span class="line">    1f30:	55 	push	ebp</span><br><span class="line">    1f31:	89 e5 	mov	ebp, esp</span><br><span class="line">    1f33:	83 ec 08 	sub	esp, 8</span><br><span class="line">    1f36:	8b 45 0c 	mov	eax, dword ptr [ebp + 12]</span><br><span class="line">    1f39:	8b 4d 08 	mov	ecx, dword ptr [ebp + 8]</span><br><span class="line">    1f3c:	89 4d fc 	mov	dword ptr [ebp - 4], ecx</span><br><span class="line">    1f3f:	89 45 f8 	mov	dword ptr [ebp - 8], eax</span><br><span class="line">    1f42:	8b 45 fc 	mov	eax, dword ptr [ebp - 4]</span><br><span class="line">    1f45:	03 45 f8 	add	eax, dword ptr [ebp - 8]</span><br><span class="line">    1f48:	83 c4 08 	add	esp, 8</span><br><span class="line">    1f4b:	5d 	pop	ebp</span><br><span class="line">    1f4c:	c3 	ret</span><br><span class="line">    1f4d:	0f 1f 00 	nop	dword ptr [eax]</span><br><span class="line">    1f50:	55 	push	ebp</span><br><span class="line">    1f51:	89 e5 	mov	ebp, esp</span><br><span class="line">    1f53:	83 ec 28 	sub	esp, 40</span><br><span class="line">    1f56:	b8 01 00 00 00 	mov	eax, 1</span><br><span class="line">    1f5b:	b9 02 00 00 00 	mov	ecx, 2</span><br><span class="line">    1f60:	c7 45 fc 00 00 00 00 	mov	dword ptr [ebp - 4], 0</span><br><span class="line">    1f67:	c7 04 24 01 00 00 00 	mov	dword ptr [esp], 1</span><br><span class="line">    1f6e:	c7 44 24 04 02 00 00 00 	mov	dword ptr [esp + 4], 2</span><br><span class="line">    1f76:	89 45 f8 	mov	dword ptr [ebp - 8], eax</span><br><span class="line">    1f79:	89 4d f4 	mov	dword ptr [ebp - 12], ecx</span><br><span class="line">    1f7c:	e8 af ff ff ff 	call	-81 &lt;_sum&gt;</span><br><span class="line">    1f81:	b9 03 00 00 00 	mov	ecx, 3</span><br><span class="line">    1f86:	ba 04 00 00 00 	mov	edx, 4</span><br><span class="line">    1f8b:	c7 04 24 03 00 00 00 	mov	dword ptr [esp], 3</span><br><span class="line">    1f92:	c7 44 24 04 04 00 00 00 	mov	dword ptr [esp + 4], 4</span><br><span class="line">    1f9a:	89 45 f0 	mov	dword ptr [ebp - 16], eax</span><br><span class="line">    1f9d:	89 4d ec 	mov	dword ptr [ebp - 20], ecx</span><br><span class="line">    1fa0:	89 55 e8 	mov	dword ptr [ebp - 24], edx</span><br><span class="line">    1fa3:	e8 88 ff ff ff 	call	-120 &lt;_sum&gt;</span><br><span class="line">    1fa8:	31 c9 	xor	ecx, ecx</span><br><span class="line">    1faa:	89 45 e4 	mov	dword ptr [ebp - 28], eax</span><br><span class="line">    1fad:	89 c8 	mov	eax, ecx</span><br><span class="line">    1faf:	83 c4 28 	add	esp, 40</span><br><span class="line">    1fb2:	5d 	pop	ebp</span><br><span class="line">    1fb3:	c3 	ret</span><br><span class="line"></span><br><span class="line">_sum:</span><br><span class="line">    1f30:	55 	push	ebp</span><br><span class="line">    1f31:	89 e5 	mov	ebp, esp</span><br><span class="line">    1f33:	83 ec 08 	sub	esp, 8</span><br><span class="line">    1f36:	8b 45 0c 	mov	eax, dword ptr [ebp + 12]</span><br><span class="line">    1f39:	8b 4d 08 	mov	ecx, dword ptr [ebp + 8]</span><br><span class="line">    1f3c:	89 4d fc 	mov	dword ptr [ebp - 4], ecx</span><br><span class="line">    1f3f:	89 45 f8 	mov	dword ptr [ebp - 8], eax</span><br><span class="line">    1f42:	8b 45 fc 	mov	eax, dword ptr [ebp - 4]</span><br><span class="line">    1f45:	03 45 f8 	add	eax, dword ptr [ebp - 8]</span><br><span class="line">    1f48:	83 c4 08 	add	esp, 8</span><br><span class="line">    1f4b:	5d 	pop	ebp</span><br><span class="line">    1f4c:	c3 	ret</span><br><span class="line">    1f4d:	0f 1f 00 	nop	dword ptr [eax]</span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">    1f50:	55 	push	ebp</span><br><span class="line">    1f51:	89 e5 	mov	ebp, esp</span><br><span class="line">    1f53:	83 ec 28 	sub	esp, 40</span><br><span class="line">    1f56:	b8 01 00 00 00 	mov	eax, 1</span><br><span class="line">    1f5b:	b9 02 00 00 00 	mov	ecx, 2</span><br><span class="line">    1f60:	c7 45 fc 00 00 00 00 	mov	dword ptr [ebp - 4], 0</span><br><span class="line">    1f67:	c7 04 24 01 00 00 00 	mov	dword ptr [esp], 1</span><br><span class="line">    1f6e:	c7 44 24 04 02 00 00 00 	mov	dword ptr [esp + 4], 2</span><br><span class="line">    1f76:	89 45 f8 	mov	dword ptr [ebp - 8], eax</span><br><span class="line">    1f79:	89 4d f4 	mov	dword ptr [ebp - 12], ecx</span><br><span class="line">    1f7c:	e8 af ff ff ff 	call	-81 &lt;_sum&gt;</span><br><span class="line">    1f81:	b9 03 00 00 00 	mov	ecx, 3</span><br><span class="line">    1f86:	ba 04 00 00 00 	mov	edx, 4</span><br><span class="line">    1f8b:	c7 04 24 03 00 00 00 	mov	dword ptr [esp], 3</span><br><span class="line">    1f92:	c7 44 24 04 04 00 00 00 	mov	dword ptr [esp + 4], 4</span><br><span class="line">    1f9a:	89 45 f0 	mov	dword ptr [ebp - 16], eax</span><br><span class="line">    1f9d:	89 4d ec 	mov	dword ptr [ebp - 20], ecx</span><br><span class="line">    1fa0:	89 55 e8 	mov	dword ptr [ebp - 24], edx</span><br><span class="line">    1fa3:	e8 88 ff ff ff 	call	-120 &lt;_sum&gt;</span><br><span class="line">    1fa8:	31 c9 	xor	ecx, ecx</span><br><span class="line">    1faa:	89 45 e4 	mov	dword ptr [ebp - 28], eax</span><br><span class="line">    1fad:	89 c8 	mov	eax, ecx</span><br><span class="line">    1faf:	83 c4 28 	add	esp, 40</span><br><span class="line">    1fb2:	5d 	pop	ebp</span><br><span class="line">    1fb3:	c3 	ret</span><br></pre></td></tr></table></figure>
<h2 id="lldb-反汇编">lldb 反汇编</h2>
<p>使用 lldb 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lldb hello1</span><br><span class="line">(lldb) target create &quot;hello1&quot;</span><br><span class="line">Current executable set to &#x27;hello1&#x27; (i386).</span><br><span class="line">(lldb) settings set target.x86-disassembly-flavor intel</span><br><span class="line">(lldb) disassemble --name main</span><br><span class="line">hello1`main:</span><br><span class="line">hello1[0x1f50] &lt;+0&gt;:  push   ebp</span><br><span class="line">hello1[0x1f51] &lt;+1&gt;:  mov    ebp, esp</span><br><span class="line">hello1[0x1f53] &lt;+3&gt;:  sub    esp, 0x28</span><br><span class="line">hello1[0x1f56] &lt;+6&gt;:  mov    eax, 0x1</span><br><span class="line">hello1[0x1f5b] &lt;+11&gt;: mov    ecx, 0x2</span><br><span class="line">hello1[0x1f60] &lt;+16&gt;: mov    dword ptr [ebp - 0x4], 0x0</span><br><span class="line">hello1[0x1f67] &lt;+23&gt;: mov    dword ptr [esp], 0x1</span><br><span class="line">hello1[0x1f6e] &lt;+30&gt;: mov    dword ptr [esp + 0x4], 0x2</span><br><span class="line">hello1[0x1f76] &lt;+38&gt;: mov    dword ptr [ebp - 0x8], eax</span><br><span class="line">hello1[0x1f79] &lt;+41&gt;: mov    dword ptr [ebp - 0xc], ecx</span><br><span class="line">hello1[0x1f7c] &lt;+44&gt;: call   0x1f30                    ; sum</span><br><span class="line">hello1[0x1f81] &lt;+49&gt;: mov    ecx, 0x3</span><br><span class="line">hello1[0x1f86] &lt;+54&gt;: mov    edx, 0x4</span><br><span class="line">hello1[0x1f8b] &lt;+59&gt;: mov    dword ptr [esp], 0x3</span><br><span class="line">hello1[0x1f92] &lt;+66&gt;: mov    dword ptr [esp + 0x4], 0x4</span><br><span class="line">hello1[0x1f9a] &lt;+74&gt;: mov    dword ptr [ebp - 0x10], eax</span><br><span class="line">hello1[0x1f9d] &lt;+77&gt;: mov    dword ptr [ebp - 0x14], ecx</span><br><span class="line">hello1[0x1fa0] &lt;+80&gt;: mov    dword ptr [ebp - 0x18], edx</span><br><span class="line">hello1[0x1fa3] &lt;+83&gt;: call   0x1f30                    ; sum</span><br><span class="line">hello1[0x1fa8] &lt;+88&gt;: xor    ecx, ecx</span><br><span class="line">hello1[0x1faa] &lt;+90&gt;: mov    dword ptr [ebp - 0x1c], eax</span><br><span class="line">hello1[0x1fad] &lt;+93&gt;: mov    eax, ecx</span><br><span class="line">hello1[0x1faf] &lt;+95&gt;: add    esp, 0x28</span><br><span class="line">hello1[0x1fb2] &lt;+98&gt;: pop    ebp</span><br><span class="line">hello1[0x1fb3] &lt;+99&gt;: ret</span><br><span class="line"></span><br><span class="line">(lldb) disassemble --name sum</span><br><span class="line">hello1`sum:</span><br><span class="line">hello1[0x1f30] &lt;+0&gt;:  push   ebp</span><br><span class="line">hello1[0x1f31] &lt;+1&gt;:  mov    ebp, esp</span><br><span class="line">hello1[0x1f33] &lt;+3&gt;:  sub    esp, 0x8</span><br><span class="line">hello1[0x1f36] &lt;+6&gt;:  mov    eax, dword ptr [ebp + 0xc]</span><br><span class="line">hello1[0x1f39] &lt;+9&gt;:  mov    ecx, dword ptr [ebp + 0x8]</span><br><span class="line">hello1[0x1f3c] &lt;+12&gt;: mov    dword ptr [ebp - 0x4], ecx</span><br><span class="line">hello1[0x1f3f] &lt;+15&gt;: mov    dword ptr [ebp - 0x8], eax</span><br><span class="line">hello1[0x1f42] &lt;+18&gt;: mov    eax, dword ptr [ebp - 0x4]</span><br><span class="line">hello1[0x1f45] &lt;+21&gt;: add    eax, dword ptr [ebp - 0x8]</span><br><span class="line">hello1[0x1f48] &lt;+24&gt;: add    esp, 0x8</span><br><span class="line">hello1[0x1f4b] &lt;+27&gt;: pop    ebp</span><br><span class="line">hello1[0x1f4c] &lt;+28&gt;: ret</span><br><span class="line">hello1[0x1f4d] &lt;+29&gt;: nop    dword ptr [eax]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ol>
<li>链接、装载与库，俞甲子，2009：第10章 内存: 栈与堆，<a href="https://book.douban.com/subject/3652388/">豆瓣</a></li>
<li>IDA Pro权威指南，Eagle，第2版2011：6.2.1 调用约定，<a href="https://book.douban.com/subject/10463039/">豆瓣</a></li>
<li>2001-09 Calling Conventions Demystified <a href="https://www.codeproject.com/Articles/1388/Calling-Conventions-Demystified">https://www.codeproject.com/Articles/1388/Calling-Conventions-Demystified</a></li>
<li>Calling Conventions <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions">https://en.wikipedia.org/wiki/X86_calling_conventions</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>编译器</tag>
        <tag>OS</tag>
        <tag>C</tag>
        <tag>ASM</tag>
        <tag>ABI</tag>
      </tags>
  </entry>
  <entry>
    <title>流行互联网网站技术栈整理（万字长文）</title>
    <url>/2023/12/popular-websites-tech-stack/</url>
    <content><![CDATA[<p>本文整理总结主要的流行互联网网站技术栈，以及这些网站的技术栈和架构的历史演进过程。涉及的网站大部分都是当前或曾经访问量或月活用户量 Top 的网站（参见 Similarweb 网站的统计<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，或访问量 Top 10 网站的历史演变<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，或 wiki 整理的至少 1 亿月活用户量的社交平台<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>）。国内网站或 APP 涵盖了主流<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的阿里、腾讯、百度、美团、字节、京东等大厂的互联网产品。整理的技术栈主要是流行网站的服务端业务系统的技术栈，包括编程语言、数据库、RPC 框架等，同时也简单整理了大数据技术栈，前端和客户端技术栈等不涉及。除了对大部分流行网站的技术栈做系统性梳理外，本文还挑选部分有代表性的网站，对这些网站的技术栈和架构的历史演进做详细解析。</p>
<span id="more"></span>
<p>技术栈是构建应用的技术集合，由编程语言、框架、库、服务器、数据库、工具等组合而成。组成技术栈的技术是与具体业务无关的基础软件。互联网公司选择的技术栈，倾向于使用开源软件，相对于专有软件，开源软件具有高质量、免费、开放、灵活等优势。互联网的早期开拓者 Yahoo 的技术栈选择是经典案例，受开源运动的影响，在 2000 左右 Yahoo 从最初基于自定义的专属软件迁移了到 LAMP 技术栈。</p>
<p>在“开源”（open source）一词出现之前，技术社区的黑客选择使用“自由软件”（free software）这个词。但是“自由软件”这个词与对知识产权的敌意、共产主义和其它观点相联系，几乎不受管理者和投资者的欢迎，于是 1998 年 2 月 3 日在由 <a href="https://en.wikipedia.org/wiki/Eric_S._Raymond">Eric Raymond</a> 等人参加的会议上“开源”一词诞生，2 月下旬开源软件促进会成立 <a href="https://opensource.org/history/">OSI</a>，Eric Raymond 担任主席。自由软件和开源软件被合称为 <a href="https://en.wikipedia.org/wiki/Free_and_open-source_software">FOSS</a>。缩写“<a href="https://en.wikipedia.org/wiki/LAMP_%28software_bundle%29">LAMP</a>”代表的是 Linux-Apache-MySQL-PHP，这些软件都是自由软件或开源软件。</p>
<h1 id="案例汇总与解析">案例汇总与解析</h1>
<h2 id="技术发展时间线">技术发展时间线</h2>
<p>在互联网诞生早期，开源技术栈、开源社区尚未成熟，互联网公司不得不自研专有软件，随着开源软件的成熟，技术栈的选择开始从专有软件逐渐转向开源软件。先来看下，主要 Web 技术和服务端技术的发展时间线：</p>
<ul>
<li>1994.03，Linux 1.0 对外发布，源码采用 GPL 协议。</li>
<li>1994.10，网景公司的 Web 浏览器 <a href="https://en.wikipedia.org/wiki/Netscape_%28web_browser%29">Netscape</a> 首次对外发布。</li>
<li>1995.02，<a href="https://en.wikipedia.org/wiki/Apache_HTTP_Server">Apache HTTP Server</a> 项目创立，4 月首次对外开源发布，版本为 0.6.2，源码采用 <a href="https://en.wikipedia.org/wiki/Apache_License">Apache 协议</a>。创建 Apache HTTP Server 项目的<a href="https://httpd.apache.org/ABOUT_APACHE.html">核心成员</a>包括 <a href="https://en.wikipedia.org/wiki/Brian_Behlendorf">Brian Behlendorf</a>、<a href="https://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a> 等。</li>
<li>1995.12，<a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a> 语言诞生，创造者为来自网景公司的 Brendan Eich。</li>
<li>1995.05，<a href="https://en.wikipedia.org/wiki/Java_%28programming_language%29">Java</a> 语言诞生，创造者为 Sun 公司。Java 平台早期并不真正开源，虽然 1998 年 JDK 1.2 开始以 <a href="https://en.wikipedia.org/wiki/Sun_Community_Source_License">SCSL</a> 协议开放源代码，但 SCSL 协议限制太大，饱受批评，直到 <a href="https://web.archive.org/web/0/http://www.sun.com/2006-1113/feature/story.jsp">2006.11</a> 才以 GPL 协议真正开源。</li>
<li>1995.06，<a href="https://en.wikipedia.org/wiki/PHP">PHP</a> 语言诞生，源码采用 <a href="https://www.php.net/license/">PHP</a> 协议（BSD 风格的协议）。</li>
<li>1995.12，<a href="https://en.wikipedia.org/wiki/HTML">HTML</a> 标准规范首次发布，版本为 HTML 2.0</li>
<li>1996.05，HTTP/1.0 规范发布（<a href="https://datatracker.ietf.org/doc/html/rfc1945">RFC1945</a>），第一作者 <a href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a>，第二作者 <a href="https://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a>。1997 年 HTTP 1.1 规范发布（<a href="https://datatracker.ietf.org/doc/html/rfc2068">RFC2068</a>），1999 年 HTTP 1.1 规范发布更新版（<a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC2616</a>）。HTTP 1.1 的主要设计者是 Roy Fielding，他也是 Apache HTTP Server 项目的<a href="https://httpd.apache.org/ABOUT_APACHE.html">主要创建者</a>之一。基于 HTTP 的设计思想，Roy Fielding 在 2000 年的博士论文创造了 <a href="https://en.wikipedia.org/wiki/REST">REST</a> 架构风格。</li>
<li>1996.05，Sun 公司首次对外发布 <a href="https://en.wikipedia.org/wiki/Jakarta_Servlet">Java Servlet</a> API。</li>
<li>1996.10，<a href="https://en.wikipedia.org/wiki/MySQL">MySQL</a> 首次公开对外发布，最初的公开发行版仅提供了 Solaris 的二进制发行版，一个月后，源代码和 Linux 二进制文件发布，源码采用的是专有协议“MySQL Free Public License”，到 <a href="https://web.archive.org/web/0/http://www.mysql.com/news/article-23.html">2000.06</a> 改为 GPL 协议。</li>
<li>1996.10，<a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a> 的诞生日是在 10 月 22 日，在这一天 <a href="http://PostgreSQL.org">PostgreSQL.org</a> 网站上线。PostgreSQL 之前的项目名为 Postgres，之所以改名是为了反映其对 SQL 的支持。源码采用 <a href="https://www.postgresql.org/about/licence/">PostgreSQL 协议</a>（类似 BSD 或 MIT 协议）。</li>
<li>1996.12，微软发布 <a href="https://en.wikipedia.org/wiki/Active_Server_Pages">ASP</a> 技术，到 2002 年 ASP 被 <a href="http://ASP.NET">ASP.NET</a> 替代。</li>
<li>1998.12，缩写“<a href="https://en.wikipedia.org/wiki/LAMP_%28software_bundle%29">LAMP</a>”诞生，代表 Linux-Apache-MySQL-PHP。</li>
<li>1999.12，Sun 公司首次对外发布 <a href="https://en.wikipedia.org/wiki/Jakarta_EE">J2EE</a>，版本为 1.2，包括 Servlet、JSP、EJB 等技术。</li>
<li>2001.04，Douglas Crockford 创造了 <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> 缩写和数据格式。2006.07，JSON 规范发布（<a href="https://datatracker.ietf.org/doc/html/rfc4627">RFC4627</a>）。</li>
<li>2002.08，<a href="https://en.wikipedia.org/wiki/Nginx">Nginx</a> 首次对外发布，源码采用 BSD 协议。最初，研发 Nginx 目的是为了解决 <a href="https://en.wikipedia.org/wiki/C10k_problem">C10k</a> 问题。之后，Nginx 逐渐替代 Apache HTTP Server，LAMP 技术栈改为 LNMP 技术栈。</li>
<li>2003.06，Java 的 <a href="https://en.wikipedia.org/wiki/Spring_Framework">Spring</a> 框架首次对外发布，版本为 0.9，源码采用 Apache 协议。</li>
<li>2004.08，<a href="https://en.wikipedia.org/wiki/Ruby_on_Rails">Ruby on Rails</a> 框架首次对外发布，源码采用 MIT 协议。</li>
<li>2004.10，首届 <a href="https://web.archive.org/web/20041001082754/http://www.web2con.com/">Web 2.0 Conference</a> 举办，<a href="https://en.wikipedia.org/wiki/Web_2.0">Web 2.0</a> 概念开始流行。</li>
<li>2005.02，“<a href="https://en.wikipedia.org/wiki/Ajax_%28programming%29">Ajax</a>”术语诞生，缩写代表的是“Asynchronous JavaScript + XML”。早期使用 Ajax 技术的经典案例是 Google 在 2004 年发布的 Gmail、2004 年 12 月发布的 Google 搜索的 <a href="https://en.wikipedia.org/wiki/Timeline_of_Google_Search">Google Suggest</a> 特性、2005 年发布的 Google Maps，以及 2004 年发布的 Flickr 等。早期 Ajax API 响应的数据格式是 XML，从 2005 年 <a href="https://inkdroid.org/2005/09/21/delicious-json/">del.icio.us API</a> 和 <a href="https://simonwillison.net/2005/Dec/16/json/">Yahoo! Web Services</a> 支持 <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> 格式等代表性转变开始，XML 逐渐被 JSON 取代。</li>
<li>2005.07，Python 的 <a href="https://en.wikipedia.org/wiki/Django_%28web_framework%29">Django</a> 框架首次对外发布，源码采用 BSD 协议。</li>
<li>2006.06，Rails 的创造者 DHH 在 RailsConf 2006 会议上做了题为“Discovering a world of Resources on Rails”的演讲，介绍了将要发布的 Rails 1.2（2007.01 正式发布）对 REST 开发的支持。Rails 框架支持 REST 开发，大力推动了 REST 的普及。受 Rails 的影响，其他编程语言的 Web 开发框架<a href="https://groups.google.com/g/rest_in_action/c/G7sBHhkNdsw">模仿 Rails 的方式</a>开始对支持 REST 开发。</li>
<li>2007.02，<a href="https://en.wikipedia.org/wiki/Apache_HBase">HBase</a> 宣布在 Hadoop 项目中成立，成为 Hadoop 的子项目。HBase 是 Google 的 <a href="https://en.wikipedia.org/wiki/Bigtable">BigTable</a>（OSDI'2006）论文的开源实现。</li>
<li>2007.01，iPhone 手机首次对外发布，同年 6 月 iPhone 正式发售，11 月 Android 系统首次对外公布，移到互联网开始大爆发。</li>
<li>2008.07，Facebook 对外开源 <a href="https://en.wikipedia.org/wiki/Apache_Cassandra">Cassandra</a> 项目，项目受 Amazon 的 <a href="https://en.wikipedia.org/wiki/Dynamo_%28storage_system%29">Dynamo</a>（SOSP'2007）论文和 Google 的 BigTable（OSDI'2006）论文的。</li>
<li>2009.06，“<a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a>”术语诞生。“NoSQL”术语诞生于在旧金山举行的一场关于“开源、分布式、非关系数据库”的技术聚会，该技术聚会被命名为“<a href="https://web.archive.org/web/20110710205509/http://nosql.eventbrite.com/">NoSQL meetup</a>”。NoSQL 的两大起源是 BigTable 和 Dynamo。</li>
<li>2009.11，Google 对外公开 <a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29">Go</a> 语言，BSD 协议开源。</li>
<li>2011.04，451 Group 咨询公司的分析师 Matthew Aslett 创造“<a href="https://en.wikipedia.org/wiki/NewSQL">NewSQL</a>”术语，是对用于 OLTP 的分布式关系型数据库的统称。最具代表性的 NewSQL 是 Google 的 <a href="https://en.wikipedia.org/wiki/Spanner_%28database%29">Spanner</a>（OSDI'2012）和 Amazon 的 <a href="https://en.wikipedia.org/wiki/Amazon_Aurora">Aurora</a>（2014.10 发布的云原生数据库产品）。</li>
</ul>
<h2 id="技术栈案例汇总">技术栈案例汇总</h2>
<p>按编程语言区别，主要流行的互联网产品的创建时间和早期的技术栈选择（也可以参见 <a href="https://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites">wiki</a>）：</p>
<ul>
<li><strong>C/C++ 技术栈</strong>：
<ul>
<li><strong>Yahoo!</strong>（1994，2002 转向 PHP）、<strong>Amazon</strong>（1994，之后转向以 Java 为主）、<strong>eBay</strong>（1995，2002 全面转向 Java）、<strong>Google 搜索</strong>（1998）<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>、<strong>新浪网</strong>（1998，之后转 PHP，2008 年 PHP 占据 90% 以上的 Web 开发）<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>、<strong>腾讯 QQ</strong>（1999）、<strong>QQ 空间</strong>（2005）、<strong>微信</strong>（2011）<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>、<strong>百度搜索</strong>（2000）、<strong>Yandex 搜索</strong>（2000）<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>等</li>
</ul>
</li>
<li><strong>PHP（LAMP 或 LNMP）技术栈</strong>：
<ul>
<li><strong>Wikipedia</strong>（2001）<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>、<strong>Facebook</strong>（2004，2006 核心服务转向 C++）、<strong>Flickr</strong>（2004）<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>、<strong>Etsy</strong>（2005）<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>、<strong><a href="https://en.wikipedia.org/wiki/WordPress">WordPress</a></strong>（2005）、<strong>新浪博客</strong>（2005）<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>、<strong>百度百科</strong>（2006，2006 开始百科、知道、文库、贴吧等产品以 PHP 为主实现）<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>，<strong>Tumblr</strong>（2007，2011 转向 Scala）<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>、<strong>哔哩哔哩</strong>（2009，2017 转向 Golang）<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>、<strong>新浪微博</strong>（2009，2011 转向 Java）<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>、<strong>腾讯微博</strong>（2010）<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>、<strong>美团</strong>（2010，2011 转向 Java）<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>、<strong>滴滴</strong>（2012，2017 业务系统转向 Golang）<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>等</li>
</ul>
</li>
<li><strong>Ruby on Rails 技术栈</strong>：
<ul>
<li><strong>Twitter</strong>（2006，2009 核心服务转向 Scala 和 Java）、<strong>Shopify</strong>（2006）<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>、<strong>SoundCloud</strong>（2007，2012 业务转向多种 JVM 语言和基础设施转向 Golang）<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup><sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup><sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>、<strong>Heroku</strong>（2007）<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>、<strong>GitHub</strong>（2008）<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>、<strong>Airbnb</strong>（2008，2016 开始服务化并部分转向 Java）<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup><sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup>等</li>
</ul>
</li>
<li><strong>Python 技术栈</strong>：
<ul>
<li><strong>Reddit</strong>（2005，少部分高性逻辑用 C 语言）<sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>、<strong>YouTube</strong>（2005）<sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>、<strong>豆瓣</strong>（2005）<sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>、<strong>Disqus</strong>（2007）<sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>、<strong>Dropbox</strong>（2007，2013 基础设施转向 Golang）<sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup><sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup><sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>、<strong>Quora</strong>（2009，高性能服务用 C++）<sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup>、<strong>Pinterest</strong>（2009，部分服务转向 Java）<sup class="footnote-ref"><a href="#fn37" id="fnref37">[37]</a></sup><sup class="footnote-ref"><a href="#fn38" id="fnref38">[38]</a></sup>、<strong>Instagram</strong>（2010，少部分高性逻辑用 C++）<sup class="footnote-ref"><a href="#fn39" id="fnref39">[39]</a></sup><sup class="footnote-ref"><a href="#fn40" id="fnref40">[40]</a></sup><sup class="footnote-ref"><a href="#fn41" id="fnref41">[41]</a></sup>、<strong>Uber</strong>（2010，2015 转向 Golang 和 Java 等）<sup class="footnote-ref"><a href="#fn42" id="fnref42">[42]</a></sup>、<strong>知乎</strong>（2011，2018 核心业务转向 Golang）<sup class="footnote-ref"><a href="#fn43" id="fnref43">[43]</a></sup>、<strong>字节跳动</strong>（2012，今日头条、抖音等，2014 开始引入 Golang，2016 业务大规模转向 Golang）<sup class="footnote-ref"><a href="#fn44" id="fnref44">[44]</a></sup><sup class="footnote-ref"><a href="#fn45" id="fnref45">[45]</a></sup>等</li>
</ul>
</li>
<li><strong>Java 技术栈</strong>：
<ul>
<li><strong>淘宝</strong>（2003，2004 PHP 全面转向 Java）、<strong>LinkedIn</strong>（2003）、<strong>Google Gmail</strong>（2004）<sup class="footnote-ref"><a href="#fn46" id="fnref46">[46]</a></sup>、<strong>Google Docs</strong>（2006）、<strong>Google+</strong>（2011）<sup class="footnote-ref"><a href="#fn47" id="fnref47">[47]</a></sup>、<strong>人人网</strong>（2005）<sup class="footnote-ref"><a href="#fn48" id="fnref48">[48]</a></sup>、<strong>Netflix</strong>（2007）<sup class="footnote-ref"><a href="#fn49" id="fnref49">[49]</a></sup>等</li>
</ul>
</li>
<li><strong>.NET 技术栈</strong>
<ul>
<li><strong>携程</strong>（1999，2017 全面转向 Java）<sup class="footnote-ref"><a href="#fn50" id="fnref50">[50]</a></sup>、<strong>京东</strong>（2004，2012 全面转向 Java）<sup class="footnote-ref"><a href="#fn51" id="fnref51">[51]</a></sup>、<strong>Stack Overflow</strong>（2008）、<strong>Bing 搜索</strong>（2009）等</li>
</ul>
</li>
</ul>
<p>值得一提的是，PHP 之父 <a href="https://en.wikipedia.org/wiki/Rasmus_Lerdorf">Rasmus Lerdorf</a>，在 2002 年至 2009 年期间为供职于 Yahoo!，2011 年起至今供职于 Etsy。Python 之父 <a href="https://en.wikipedia.org/wiki/Guido_van_Rossum">Guido van Rossum</a>，在 2005 年至 2012 年期间供职于 Google，在 2013 年至 2019 年期间供职于 Dropbox。国内最有影响力的 PHP 技术专家是<a href="https://baike.baidu.com/item/%E6%83%A0%E6%96%B0%E5%AE%B8/8222328">惠新宸</a>，是加入 PHP 语言官方开发组的首位国人，曾先后供职于雅虎中国、百度、新浪微博、链家网等公司。</p>
<h2 id="编程语言选择">编程语言选择</h2>
<p>2000 年前创建的网站，因为开源技术栈尚未成熟，编程语言基本上都是选择 C++ 开发。在开源技术栈成熟后，多数网站会选择拥抱开源。具体选择哪个编程语言，PHP、Ruby、Python、Java 等，主要由技术负责人的技术偏好决定。根据 <a href="https://w3techs.com/technologies/history_overview/programming_language/ms/y">w3techs</a> 统计，历年网站使用的服务端编程语言统计占比，2012 年至今 10 多年，PHP 占比稳居榜首，每年都是 75% 以上。大型网站通常都是公司内的技术团队研发的，技术栈由技术团队选择，而很多小型网站，很可能会直接使用开源的 CMS 系统搭建。根据 <a href="https://w3techs.com/technologies/overview/content_management">w3techs</a> 统计，前 100 万网站中有 43.0% 使用 WordPress 构建。WordPress 的服务端编程语言就是 PHP，数据库是 MySQL。大型网站选择 PHP 越来越少，因为 PHP 是解释型脚本语言，相对编译型编程语言有性能劣势。另外，PHP 的优势是快速开发 Web 动态网页，但是随着前后端分离开发模式的流行，Web 页面从服务端渲染逐渐转向客户端渲染，PHP 的优势不再，后端工程师只需要向前端提供 REST API 接口，展示层的实现完全由前端工程师实现。</p>
<p>早期部分网站选择 .NET 技术栈，比如<strong>京东</strong>、<strong>携程</strong>。但是，Java 平台生态更完善，有非常多的经验可以借鉴。另外，.NET 平台本身虽然不收费，但是 Windows 操作系统是收费的，开发工具也不便宜。于是京东在 2012 年从 .NET 迁移到 Java，携程在 2017 左右从 .NET 迁移到 Java。目前在国内，多数互联网大厂都选择 Java 技术栈，如淘宝、美团、京东、微博、携程等，Java 相对来说是主流选择。</p>
<p>编程语言的另外一个流行趋势是 Go 语言。Go 语言诞生于 Google，在 2009 年 11 月对外公开。在发明 Go 语言前，Google 内部主要使用的语言是 C++、Java 和 Python 等，但是 Go 发明者认为这些语言无法同时满足高效编译、高效执行和易于编程的特性诉求，所以创造了 Go 语言<sup class="footnote-ref"><a href="#fn52" id="fnref52">[52]</a></sup>。Go 比 C++ 能更高效编译和易于编程，比 Java 更易于编程，比 Python 能更高效执行。在 GoCon Tokyo 2014 会议上，Go 语言研发团队的 Brad Fitzpatrick 对各种编程语言在编程乐趣和执行速度（Fun vs. Fast）的对比<sup class="footnote-ref"><a href="#fn53" id="fnref53">[53]</a></sup>，如下图所示：</p>
<img width="600" alt="编程语言 Fun vs. Fast" title="编程语言 Fun vs. Fast" src="https://static.nullwy.me/gocon-tokyo-2014-fitzpatrick-go-fun-fast.png">
<p>早期由 Go 语言实现的经典开源项目主要是基础设施软件，比如 YouTube 的 <a href="https://github.com/vitessio/vitess">Vitess</a> 数据库分片中间件（<a href="https://www.reddit.com/r/programming/comments/qakq4">2012.02</a> 对外开源）、<a href="https://en.wikipedia.org/wiki/Docker_%28software%29">Docker</a> 容器（2013.03 对外开源）、Red Hat 的 CoreOS 团队的 <a href="https://github.com/etcd-io/etcd">Etcd</a> 分布式配置服务（<a href="https://web.archive.org/web/0/http://coreos.com/blog/distributed-configuration-with-etcd/">2013.07</a> 对外开源，实现 <a href="https://en.wikipedia.org/wiki/Raft_%28algorithm%29">Raft</a> 共识协议）、前 Google 工程师创建的 <a href="https://en.wikipedia.org/wiki/CockroachDB">CockroachDB</a> 分布式数据库（2014.02 对外开源，受 Google Spanner 启发）、Google 的 <a href="https://en.wikipedia.org/wiki/Kubernetes">Kubernetes</a> 容器编排系统（2014.06 对外开源）、SoundCloud 的 <a href="https://en.wikipedia.org/wiki/Prometheus_%28software%29">Prometheus</a> 监控工具（2015.01 对外开源）等。大规模使用 Go 语言的代表性的国外的互联网公司有 <strong>SoundCloud</strong><sup class="footnote-ref"><a href="#fn23" id="fnref23:1">[23:1]</a></sup><sup class="footnote-ref"><a href="#fn24" id="fnref24:1">[24:1]</a></sup>、<strong>Dropbox</strong><sup class="footnote-ref"><a href="#fn34" id="fnref34:1">[34:1]</a></sup><sup class="footnote-ref"><a href="#fn35" id="fnref35:1">[35:1]</a></sup>、<strong>Uber</strong><sup class="footnote-ref"><a href="#fn42" id="fnref42:1">[42:1]</a></sup> 等，国内的有<strong>七牛云</strong>、<strong>字节跳动</strong><sup class="footnote-ref"><a href="#fn44" id="fnref44:1">[44:1]</a></sup><sup class="footnote-ref"><a href="#fn45" id="fnref45:1">[45:1]</a></sup>、<strong>哔哩哔哩</strong><sup class="footnote-ref"><a href="#fn16" id="fnref16:1">[16:1]</a></sup>、<strong>滴滴</strong><sup class="footnote-ref"><a href="#fn20" id="fnref20:1">[20:1]</a></sup>、<strong>知乎</strong><sup class="footnote-ref"><a href="#fn43" id="fnref43:1">[43:1]</a></sup>、<strong>百度</strong><sup class="footnote-ref"><a href="#fn54" id="fnref54">[54]</a></sup><sup class="footnote-ref"><a href="#fn55" id="fnref55">[55]</a></sup>、<strong>腾讯</strong><sup class="footnote-ref"><a href="#fn56" id="fnref56">[56]</a></sup>等，在这些互联网公司 Go 语言通常主要被用于构建基础设施软件（网关、数据存储、监控、视频处理等）或高性能要求的业务服务，部分公司的大量核心业务也从 Python、PHP 等迁移到 Go 语言。使用 Go 语言的公司的更加完整的列表，可以参见官方整理的“<a href="https://github.com/golang/go/wiki/GoUsers">GoUsers</a>”。</p>
<h2 id="数据库选择">数据库选择</h2>
<p>数据库方面，根据 <a href="https://db-engines.com/en/ranking_trend/relational+dbms">DB-Engines Ranking</a> 的统计，流行的关系数据库主要是 4 个，开源免费的 MySQL 和 PostgreSQL，专有收费的 Oracle 和 Microsoft SQL Server。多数互联网产品使用的数据库是 MySQL，部分是 PostgreSQL 或 Oracle。一些早期使用 Oracle 数据库的网站选择部分或完全从 Oracle 数据库中迁出，代表性的案例是，Amazon 从 Oracle 完全迁移到 Amazon RDS 和 NoSQL，淘宝从 Oracle 完全迁移到 MySQL。以 PostgreSQL 为主数据库的互联网应用有 Skype、Reddit、Spotify、Disqus、Heroku、Instagram 等<sup class="footnote-ref"><a href="#fn57" id="fnref57">[57]</a></sup>。</p>
<p>MySQL 相对 PostgreSQL 更加流行的主要原因是<sup class="footnote-ref"><a href="#fn58" id="fnref58">[58]</a></sup><sup class="footnote-ref"><a href="#fn59" id="fnref59">[59]</a></sup>，在早期 MySQL 入门槛更低。MySQL 就支持在 Windows 下安装，而 PostgreSQL 只能在 Cygwin 下安装，MySQL 对 Windows 平台的支持使得初学者更容易上手，并且 MySQL 更加易于管理，能够快速简单地启动和使用，而且 MySQL 拥有一个非常简洁、易于导航和用户友好的在线文档和支持社区。另外一个重要原因是，MySQL 很早就默认支持复制（replication），而 PostgreSQL 的复制是第三方的，而且极其难用。之后的几年即便 PostgreSQL 完善了不足，但错过了流行的时间窗口，MySQL 成为了主流选择，有更完善的生态。不过，受 MySQL 被 Oracle 公司收购的影响，近几年 PostgreSQL 开始越来越流行，根据 DB-Engines Ranking 的统计，最新的 PostgreSQL 的流行度分数是 10 年前的三倍，流行度与前三名越来越接近。</p>
<p>传统关系数据库，因为在面对大数据量和高负载量时的性能和可扩展性较差，以及对数据模型的支持有限，逐渐演变出了分布式非关系数据库 NoSQL 和分布式关系数据库 NewSQL。NoSQL 数据库的按数据模型分类包括：键值数据库（比如 Redis、DynamoDB 等）、列族数据库（比如 Cassandra、HBase 等）、文档数据库（比如 MongoDB）、图数据库（比如 Neo4j）等。</p>
<h2 id="技术栈和架构演进">技术栈和架构演进</h2>
<p>容易发现多数网站的技术栈的演进模式类似。在创建网站早期通常选择使用 PHP、Ruby、Python 脚本语言和框架来开发，这些脚本语言和框架具有更快的开发效率，能快速交付上线。随着网站流量的增长，面临性能和可扩展性问题，通常会将网站服务化，从单体架构向面向服务的 SOA 和微服务架构演进，一大部分网站在服务化过程中会选择将核心业务改由其他性能更佳的编译型编程语言来实现，如 Java、Scala、C++、Go，原先的脚本语言可能全部废弃，也可能仅用于前端展示层的 Web 动态页面渲染，比如 Facebook、Twitter 等。当然也有一部分网站，演进为 SOA 和微服务架构后，业务逻辑的实现一直以最初的脚本语言为主。</p>
<p>在架构微服务化后，很多网站实现的微服务之间采用基于 HTTP 协议的 REST 方式通信（或者使用的 RPC 框架支持跨语言 RPC 调用），各个微服务的实现在理论上编程语言不需要统一，可以根据该微服务的性能要求或负责该微服务的团队的技术偏好自由选择，所以真实世界的互联网公司内部各个业务子系统的技术栈可能不统一。但是内部技术栈不统一会带来额外的维护成本。另外，考虑技术栈的迁移重构成本，新的业务子系统使用新的技术栈，而有些旧的业务子系统很可能继续使用旧的技术栈。除了业务子系统外，很可能团队内部有自研的中间件、运维工具等，这些组件由中间件团队、运维团队研发，很可能会选择与业务系统不一样的技术栈。</p>
<p><strong>注意，解决网站的可扩展性问题，不一定需要演进为服务化架构</strong>。架构服务化意味着将完整的单体服务按业务的功能领域做垂直拆分，而实际上在应用服务层可以通过部署多个相同副本的单体服务的方式实现系统的水平扩展，网站的可扩展性问题主要在数据存储层上。<strong>拆分应用服务的好处更多在于能实现组织团队的规模化，拆分后的小团队独立维护各自的微服务，能有效提升研发效率</strong>。解决数据库的扩展性的策略有，数据复制（数据缓存、数据库主从读写分离）、数据垂直拆分、数据水平拆分（也叫数据分片，sharding）。数据库被拆分后，如果单个事务内的数据分散在多个节点就要解决分布式事务问题，但是实现分布式事务代价太大，通常的选择是牺牲一致性，仅满足最终一致性（<a href="https://en.wikipedia.org/wiki/Eventual_consistency">BASE</a>）。对于无或弱事务要求的非关系型的数据，也可以选择存储在可扩展性能力更强的 NoSQL 数据库。</p>
<p>没有拆分应用服务，始终采用单体架构的经典案例是 Instagram，2019 年 Instagram 在技术博客上有这样一段话<sup class="footnote-ref"><a href="#fn41" id="fnref41:1">[41:1]</a></sup>：</p>
<blockquote>
<p>Our server app is a monolith, one big codebase of several million lines and a few thousand Django endpoints, all loaded up and served together. A few services have been split out of the monolith, but we don’t have any plans to aggressively break it up.</p>
</blockquote>
<p>Instagram 解决可扩展性问题，主要在数据存储层<sup class="footnote-ref"><a href="#fn39" id="fnref39:1">[39:1]</a></sup><sup class="footnote-ref"><a href="#fn40" id="fnref40:1">[40:1]</a></sup>。在 Instagram，PostgreSQL 被用于存储用户信息、媒体元数据、用户关系等数据，照片媒体数据存储在亚马逊 S3 服务上。Instagram 对 PostgreSQL 数据库做了主从读写分离、数据垂直拆分和数据水平分片。另外，Instagram 从 2012 年开始使用 Cassandra 数据库，Cassandra 被用于存储 Feed 流、活动等数据。类似的，Reddit 也是单体架构，在数据存储层做了可扩展性改造<sup class="footnote-ref"><a href="#fn29" id="fnref29:1">[29:1]</a></sup>。对 PostgreSQL 数据库做了主从读写分离和垂直拆分，拆分为四个主数据库，链接、帐户、子版块、评论、投票和杂项，每个主数据库都从数据库。另外，投票数据存储在 Cassandra 数据库。</p>
<h1 id="Yahoo-（1994）">Yahoo!（1994）</h1>
<p>Yahoo!，1994 年创立，早期网站操作系统是 FreeBSD，Web 服务器是自研的 <a href="https://en.wikipedia.org/wiki/David_Filo">Filo Server</a>，数据库是自研的 DBM 文件，Web 动态页面脚本是自研的 yScript，业务逻辑编程语言是 C++。1996 年 Web 服务器改用 Apache HTTP Server，1999 年部分数据库改用 MySQL（同时也使用 Oracle 数据库），2002 年编程语言从 yScript 和 C++ 改为 PHP，操作系统也从 FreeBSD 逐渐转向 Linux<sup class="footnote-ref"><a href="#fn60" id="fnref60">[60]</a></sup><sup class="footnote-ref"><a href="#fn61" id="fnref61">[61]</a></sup><sup class="footnote-ref"><a href="#fn62" id="fnref62">[62]</a></sup>。在 2002.10 的 PHPCon 2002 会议上，Yahoo! 工程师 Michael Radwin 介绍了 Yahoo! 从专有软件向开源软件转向的原因和演进过程，以及选择 PHP 而不选择 ASP、Perl、JSP 等其他技术的原因<sup class="footnote-ref"><a href="#fn60" id="fnref60:1">[60:1]</a></sup>。Yahoo! 转向开源软件的原因主要是，避免维护专有软件的成本，开源软件从早期的不成熟最终变得成熟，具有更好的性能，更容易与第三方软件集成，以及开源社区逐渐发展壮大。2005 年，Yahoo! 的技术架构如下图所示<sup class="footnote-ref"><a href="#fn61" id="fnref61:1">[61:1]</a></sup>：</p>
<img width="600" alt="Yahoo! 技术架构（2005）" title="Yahoo! 技术架构（2005）" src="https://static.nullwy.me/yahoo-architecture-2005.png">
<p>2000 年 ~ 2010 年，Yahoo! 是世界上流量最大的网站，虽然期间被 Google 短暂超越，但随后又反超，一直到到 2010 年后才被 Google 彻底超越<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>。2000 年前后 Yahoo! 转向到 MySQL 和 PHP，并在技术上助力 LAMP 生态的发展壮大，对 LAMP 技术栈的流行起到巨大的推动作用。值得一提的是，知名 MySQL 专家 <a href="https://en.wikipedia.org/wiki/Jeremy_Zawodny">Jeremy Zawodny</a>，《高性能MySQL》2004 年第 1 版（<a href="https://book.douban.com/subject/1495763/">豆瓣</a>）的作者，在 1999.12 ~ 2008.06 期间为 Yahoo! 工程师。PHP 之父 <a href="https://en.wikipedia.org/wiki/Rasmus_Lerdorf">Rasmus Lerdorf</a> 在 2002.09 ~ 2009.11 期间为 Yahoo! 工程师。在前端领域，JSON 创造者 <a href="https://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford</a>，在 2005 年至 2012 年期间供职于 Yahoo!。</p>
<h1 id="Amazon（1994）">Amazon（1994）</h1>
<p>Amazon，1994 年创立，早期是单服务、单数据库的单体架构，使用的编程语言是 C++，2000 年开始从单体架构向 SOA 和微服务架构演进，使用最多的语言变为 Java，C++ 被用在高性能要求的系统和底层基础设施组件。Amazon 架构演进过程如下图所示<sup class="footnote-ref"><a href="#fn63" id="fnref63">[63]</a></sup>：</p>
<img width="600" alt="Amazon 架构演进" title="Amazon 架构演进" src="https://static.nullwy.me/amazon-architecture-evolution.png">
<p>Amazon 网站的技术栈演进过程：</p>
<ul>
<li>1995 ~ 2000：单体架构，Unix（Sun）、Obidos、Oracle、C++
<ul>
<li>Obidos 是亚马逊内部 Web 动态页面渲染引擎，编程语言是 C++。</li>
</ul>
</li>
<li>2000 ~ 2006：SOA 架构，Linux、Obidos、Oracle、C++
<ul>
<li>2000 年，将 Sun/Unix 服务器替换为 HP/Linux 服务器。</li>
<li>2000 年，拆分应用服务，向 SOA 架构演进。</li>
<li>2005 年初，开始将 Obidos 框架替换为 Gurupa 框架，Gurupa 是 Web 页面渲染引擎，同时也是 SOA 框架。Web 动态页面的编程语言从 C++ 替换为 Perl/Mason，同时应用服务开始被更细粒度的拆分。</li>
</ul>
</li>
<li>2006 年开始：微服务架构，Linux、Gurupa、Oracle、Perl &amp; Java &amp; C++
<ul>
<li>2019.10，彻底去掉 Oracle 数据库，迁移到 Amazon RDS 和 NoSQL。</li>
</ul>
</li>
</ul>
<p>当前 Amazon 网站的主要技术栈<sup class="footnote-ref"><a href="#fn63" id="fnref63:1">[63:1]</a></sup><sup class="footnote-ref"><a href="#fn64" id="fnref64">[64]</a></sup><sup class="footnote-ref"><a href="#fn65" id="fnref65">[65]</a></sup><sup class="footnote-ref"><a href="#fn66" id="fnref66">[66]</a></sup>：</p>
<ul>
<li><strong>应用服务</strong>：
<ul>
<li><strong>展示层</strong>：Perl/Mason</li>
<li><strong>业务逻辑层</strong>：Java（主要）、C++ 等</li>
<li><strong>RPC框架</strong>：Gurupa 框架（自研闭源）
<ul>
<li>2006 年更早之前使用 <a href="https://en.wikipedia.org/wiki/Obidos_%28software%29">Obidos</a> 框架</li>
</ul>
</li>
<li><strong>消息队列MQ</strong>：<a href="https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service">Amazon SQS</a></li>
</ul>
</li>
<li><strong>数据存储</strong><sup class="footnote-ref"><a href="#fn67" id="fnref67">[67]</a></sup>：
<ul>
<li><strong>关系数据库</strong>：Amazon RDS for PostgreSQL<sup class="footnote-ref"><a href="#fn68" id="fnref68">[68]</a></sup>、Amazon Aurora (PostgreSQL)
<ul>
<li>2019 年 10 月彻底去掉 Oracle 数据库，迁移到 Amazon RDS 和 NoSQL。</li>
</ul>
</li>
<li><strong>键值存储</strong>：<a href="https://en.wikipedia.org/wiki/Amazon_DynamoDB">Amazon DynamoDB</a></li>
<li><strong>缓存</strong>：Amazon ElastiCache for Redis<sup class="footnote-ref"><a href="#fn69" id="fnref69">[69]</a></sup></li>
<li><strong>Blob文件存储</strong>：<a href="https://en.wikipedia.org/wiki/Amazon_S3">Amazon S3</a></li>
</ul>
</li>
<li><strong>数据分析</strong>：<a href="https://en.wikipedia.org/wiki/Amazon_Kinesis">Amazon Kinesis</a>、Amazon EMR、<a href="https://en.wikipedia.org/wiki/AWS_Lambda">AWS Lambda</a>、<a href="https://en.wikipedia.org/wiki/Amazon_Redshift">Amazon Redshift</a> 等</li>
</ul>
<h1 id="eBay（1995）">eBay（1995）</h1>
<p>eBay，1995 年创立，早期使用的编程语言是 Perl，1997 年迁移到 C++，2002 年迁移到 Java。eBay 的技术栈演进过程<sup class="footnote-ref"><a href="#fn70" id="fnref70">[70]</a></sup><sup class="footnote-ref"><a href="#fn71" id="fnref71">[71]</a></sup>：</p>
<ul>
<li>1995 ~ 1997：FreeBSD、Apache、GDBM、Perl</li>
<li>1997 ~ 2002：Windows、IIS、Oracle、C++
<ul>
<li>1999.02，开始应用服务器池化和水平扩展；数据库服务器垂直扩展（替换为高端服务器 Sun E10000）</li>
<li>1999.11，开始数据库水平扩展，按功能垂直拆分、数据水平分片。</li>
</ul>
</li>
<li>2002 ~ 2006：Windows、IBM WebSphere、Oracle、Java（J2EE）
<ul>
<li>2002 年，开始将 C++ 替换为 Java，使用 J2EE 框架</li>
</ul>
</li>
<li>2006 年开始：Ubuntu、Tomcat、Oracle、Java（Spring/Spring Boot）
<ul>
<li>2007 年初，开始向 SOA 架构演进，再然后演进为微服务架构<sup class="footnote-ref"><a href="#fn72" id="fnref72">[72]</a></sup><sup class="footnote-ref"><a href="#fn73" id="fnref73">[73]</a></sup></li>
</ul>
</li>
</ul>
<p>2016 年，eBay 的技术架构如下图所示<sup class="footnote-ref"><a href="#fn73" id="fnref73:1">[73:1]</a></sup>：</p>
<img width="600" alt="eBay 技术架构（2016）" title="eBay 技术架构（2016）" src="https://static.nullwy.me/ebay-architecture-2016.png">
<p>当前 eBay 的主要技术栈<sup class="footnote-ref"><a href="#fn70" id="fnref70:1">[70:1]</a></sup><sup class="footnote-ref"><a href="#fn71" id="fnref71:1">[71:1]</a></sup><sup class="footnote-ref"><a href="#fn73" id="fnref73:2">[73:2]</a></sup><sup class="footnote-ref"><a href="#fn74" id="fnref74">[74]</a></sup>：</p>
<ul>
<li><strong>应用服务</strong>：
<ul>
<li><strong>展示层</strong>：Java、Spring MVC</li>
<li><strong>业务逻辑层</strong>：Java、Spring、Spring Boot</li>
<li><strong>RPC框架</strong>：Raptor、<a href="http://Raptor.io">Raptor.io</a>（自研闭源，基于 Spring、Spring Boot）</li>
<li><strong>消息队列MQ</strong>：BES (business event stream)（自研闭源）、BES2（自研闭源，基于 Kafka 实现，BES2 API 完全兼容 BES1）<sup class="footnote-ref"><a href="#fn75" id="fnref75">[75]</a></sup></li>
</ul>
</li>
<li><strong>数据存储</strong><sup class="footnote-ref"><a href="#fn76" id="fnref76">[76]</a></sup>：
<ul>
<li><strong>关系数据库</strong>：Oracle（主）、MySQL（次）</li>
<li><strong>NoSQL</strong>：Apache Cassandra、MongoDB</li>
<li><strong>搜索引擎</strong>：Elasticsearch<sup class="footnote-ref"><a href="#fn77" id="fnref77">[77]</a></sup></li>
</ul>
</li>
<li><strong>数据分析</strong><sup class="footnote-ref"><a href="#fn78" id="fnref78">[78]</a></sup>：Apache Kafka、Apache Flink、<a href="https://en.wikipedia.org/wiki/Apache_Kylin">Apache Kylin</a>（自研开源，MOLAP 数仓）、<a href="https://en.wikipedia.org/wiki/ClickHouse">ClickHouse</a>（ROLAP 实时数仓） 等
<ul>
<li>Apache Kylin，2014.10 对外开源，2014.11 成为 Apache 孵化器项目，2015.12 从 Apache 孵化器毕业。</li>
</ul>
</li>
</ul>
<h1 id="淘宝（2003）">淘宝（2003）</h1>
<p>淘宝技术架构<sup class="footnote-ref"><a href="#fn79" id="fnref79">[79]</a></sup><sup class="footnote-ref"><a href="#fn80" id="fnref80">[80]</a></sup><sup class="footnote-ref"><a href="#fn81" id="fnref81">[81]</a></sup><sup class="footnote-ref"><a href="#fn82" id="fnref82">[82]</a></sup><sup class="footnote-ref"><a href="#fn83" id="fnref83">[83]</a></sup>，是从 LAMP 架构演变而来的。在 2003 年 5 月最早上线时，淘宝是对购买得到的采用 LAMP 架构网站源码进行二次开发的网站。为了应对网站流量的增长，2003 年底数据库从 MySQL 切换到 Oracle，2004 年初编程语言从 PHP 迁移到 Java，同时硬件演变为 IBM 小型机和 EMC 高端硬件存储，依赖的基础设施被统称为“IOE”（IBM 小型机、Oracle 数据库、EMC 存储设备），这个架构被称为 2.0 架构。</p>
<p>2007 年底开始拆分第一个业务中心是用户中心（UIC，User Information Center），在 2008 年初上线。2008 年初，启动“千岛湖”项目，拆分出了交易中心（TC，Trade Center）和类目属性中心（Forest）。2008 年 10 月，为了打通淘宝网和淘宝商城（后来的天猫）的数据，启动“五彩石”项目，拆分出了店铺中心（SC，Shop Center）、商品中心（IC，Item Center）、评价中心（RC，Rate Center）。到 2009 年初，“五彩石”项目结束，阿里电商架构也从之前的单体架构演进为了 SOA 服务化架构，被称为 3.0 架构，同时淘宝网和淘宝商城也完成了数据整合，并淘宝网和淘宝商城的共享业务沉淀到多个业务中心。在 2009 年，共享业务事业部成立，在组织架构上共享业务事业部和淘宝、天猫平级。在业务中心的上层业务服务有，交易管理（TM，Trade Manager）、商品管理（IM，Item Manager）、店铺系统（ShopSystem）、商品详情（Detail）、评价管理（RateManager）等。2009 年淘宝的服务化拆分如下图所示<sup class="footnote-ref"><a href="#fn81" id="fnref81:1">[81:1]</a></sup>：</p>
<img width="600" alt="淘宝的服务化拆分（2009）" title="淘宝的服务化拆分（2009）" src="https://static.nullwy.me/taobao-architecture-2009.jpg">
<p>在各个应用服务拆分的同时，数据库也按业务功能做了垂直拆分，2008 年 Oracle 被拆分为商品、交易、用户、评价、收藏夹等 10 来套。当时的淘宝的分布式架构设计，包括 Java + Oracle 技术栈的选择，以及应用服务和数据库的拆分策略，很大程度上参考的是 eBay 的架构<sup class="footnote-ref"><a href="#fn79" id="fnref79:1">[79:1]</a></sup><sup class="footnote-ref"><a href="#fn82" id="fnref82:1">[82:1]</a></sup>。对照 eBay 架构师在 2006 年 11 月对外分享的 eBay 架构的 slides<sup class="footnote-ref"><a href="#fn70" id="fnref70:2">[70:2]</a></sup>，容易发现两者大同小异。</p>
<p>因为使用 Oracle 成本太高，2008 年 8 月淘宝数据库设计了异构数据库读写分离架构，写库为集中式的 Oracle，读库使用分库分表的 MySQL，该数据库架构方案基于自研的数据库中间件 TDDL 实现<sup class="footnote-ref"><a href="#fn84" id="fnref84">[84]</a></sup>。之后的几年，数据库逐渐向 MySQL 迁移。2008 年 9 月前微软亚洲研究院常务副院长<a href="https://baike.baidu.com/item/%E7%8E%8B%E5%9D%9A/8451588">王坚</a>博士加盟阿里巴巴集团，担任首席架构师，2009 年 11 月时任阿里 CTO 的王坚博士决策启动阿里“去IOE”工程。淘宝的“去IOE”工程的关键时点<sup class="footnote-ref"><a href="#fn85" id="fnref85">[85]</a></sup>：</p>
<ul>
<li>2009.07，王坚博士开始担任阿里首席技术官 CTO。</li>
<li>2009.11，王坚博士决策启动阿里“去IOE”工程。</li>
<li>2010.01，大淘宝核心系统“去IOE”工作启动。</li>
<li>2010.07，淘宝商品库完成“去I”。</li>
<li>2011.07，淘宝商品库从 Oracle 迁移到 MySQL，完成“去IOE”。</li>
<li>2011.09，淘宝交易库从 Oracle 迁移到 MySQL，完成“去IOE”。</li>
<li>2012.12，完成大淘宝“去IOE”。</li>
</ul>
<p>值得注意的是，在 2011 年淘宝商品库和交易库“去IOE”的同时，为了满足数据库的性能要求，底层硬件从 HDD 机械硬盘改为 SSD 固态硬盘。而庆幸的是，当时的前几年正好是 SSD 大爆发的时间点<sup class="footnote-ref"><a href="#fn86" id="fnref86">[86]</a></sup>。在消费级 SSD 市场，2010 年苹果的 MacBook Air 开始全面改用 SSD，2012 年苹果的 MacBook Pro 开始全面改用 SSD。在数据库服务器层面，因为 SSD 在随机读写的性能具有巨大优势，2010 年开始机械硬盘改用 SSD 成为趋势，当时的 MySQL 新版代码也专门针对 SSD 做了性能优化<sup class="footnote-ref"><a href="#fn87" id="fnref87">[87]</a></sup>。</p>
<p>2009 年初淘宝演变为 SOA 架构后，服务拆分粒度越来越细，到 2009 年底拆分出的总服务数达到 187 个，到 2010 年底达到 329 个<sup class="footnote-ref"><a href="#fn81" id="fnref81:2">[81:2]</a></sup>。因为系统依赖关系越来越复杂，当时最大问题是稳定性问题，系统的稳定性建设成为重点工作。到 2013 年阿里电商系统开始 4.0 架构改造，即异地多活架构改造，内部称为单元化项目。2013 年 8 月完成杭州同城双活，2014 年双 11 前的 10 月完成杭州和上海近距离两个单元的异地双活，2015 年双 11 完成三地四单元的异地多活<sup class="footnote-ref"><a href="#fn80" id="fnref80:1">[80:1]</a></sup><sup class="footnote-ref"><a href="#fn83" id="fnref83:1">[83:1]</a></sup>，至此也完成了 3.0 到 4.0 架构的升级。在阿里电商系统迁移到阿里云公共云方面，2015 年阿里电商系统开始采用混合云弹性架构，当阿里本地保有云无法支撑时，就快速在公有云上扩建新的单元，当流量过去后，再还资源给公有云。2015 年 10% 的双 11 大促流量使用了阿里云的机器来支撑，2016 年 50% 以上的双 11 大促流量使用了阿里云的机器来支撑<sup class="footnote-ref"><a href="#fn80" id="fnref80:2">[80:2]</a></sup>。2019 年初，阿里电商开启了全面上公共云的改造，到 2019 年双 11，阿里电商系统实现了全部核心应用上公共云，2021 年双 11，阿里电商系统实现了 100% 上公共云。</p>
<p>当前阿里电商系统（淘宝、天猫等）的主要技术栈<sup class="footnote-ref"><a href="#fn82" id="fnref82:2">[82:2]</a></sup><sup class="footnote-ref"><a href="#fn83" id="fnref83:2">[83:2]</a></sup>：</p>
<ul>
<li><strong>应用服务</strong>：
<ul>
<li><strong>展示层</strong>：Java</li>
<li><strong>业务逻辑</strong>：Java、Spring、Spring Boot 等</li>
<li><strong>RPC框架</strong>：HSF（2008 自研闭源）、Apache Dubbo（2008 自研，2011.10 对外开源）</li>
<li><strong>消息队列MQ</strong>：<a href="https://en.wikipedia.org/wiki/Apache_RocketMQ">Apache RocketMQ</a>（自研，2013.09 对外开源）
<ul>
<li>2007 年自研 Notify；2011 年自研 MetaQ；2013.09，对外开源发布 RocketMQ 3.0。RocketMQ 3.0 和 MetaQ 3.0 等价，阿里内部使用的称为 MetaQ 3.0，外部开源称之为 RocketMQ 3.0。</li>
</ul>
</li>
<li><strong>链路追踪</strong>：鹰眼 EagleEye（2012 自研闭源）
<ul>
<li>2012 年内部发布鹰眼 1.0，参考 Google 2010 年的 <a href="https://research.google/pubs/pub36356/">Dapper</a> 论文</li>
</ul>
</li>
<li><strong>注册和配置服务</strong>：ConfigServer（2008 自研闭源）、Nacos（自研，<a href="https://mp.weixin.qq.com/s/fnrGjiywiySA8iAZh_cF0Q">2018.07</a> 对外开源）
<ul>
<li>2008 年，淘宝团队内部自研 ConfigServer 并发布 1.0，被用于 HSF 的服务发现。2018.07，Nacos 对外开源，是 ConfigServer 的开源实现，在阿里内部 Nacos 被用在钉钉、考拉、饿了么、优酷等业务线。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据存储</strong>：
<ul>
<li><strong>关系数据库</strong>：MySQL (阿里云 RDS，底层基于 MySQL 自研 AliSQL)、自研 TDDL 中间件、阿里云分布式式数据库 <a href="https://help.aliyun.com/zh/polardb/polardb-for-xscale/what-is-polardb-for-xscale">PolarDB-X</a>、MySQL 的 <a href="https://help.aliyun.com/zh/rds/apsaradb-rds-for-mysql/introduction-to-x-engine">X-Engine</a> 存储引擎
<ul>
<li>2008 年，淘宝团队内部自研 TDDL 中间件，用于实现数据库的读写分离、分库分表。</li>
<li>2014 年，淘宝 TDDL 团队和阿里云 RDS 团队合作，在阿里云上输出产品分布式数据库服务 DRDS，2014.06 DRDS 开始公测，2014.12 正式上线。DRDS 脱胎于阿里 B2B 团队开源的 <a href="https://github.com/alibaba/cobar">Cobar</a> 分布式数据库引擎（2012.06 对外开源），同时借鉴了淘宝 TDDL 丰富的分布式数据库实践经验。</li>
<li>2020 年，阿里云发布分布式式数据库 PolarDB-X，融合了分布式 SQL 引擎 DRDS 与分布式自研存储 X-DB（X-Cluster）。</li>
<li>MySQL 的 <a href="https://github.com/polardb/polardbx-engine/wiki/2-X-Engine-Overview">X-Engine</a> 存储引擎，早期代码源自 Facebook 的 RocksDB 4.8.1（2016.07 发布），被应用在阿里的交易历史库、钉钉历史库等核心系统。</li>
</ul>
</li>
<li><strong>缓存</strong>：<a href="https://www.alibabacloud.com/help/zh/redis/product-overview/overview-1">Tair</a>（2009 自研，2010.06 对外开源，分布式键值存储，支持基于内存和文件的两种存储方式）
<ul>
<li>2009.04，Tair 1.0 正式诞生，并被应用于淘宝核心系统、MDB缓存、用户中心等业务。</li>
<li>2010.06，Tair 对外开源。</li>
<li>2014.05，阿里云推出基于 Tair 的缓存产品 OCS。</li>
<li>2019.11，阿里云发布 Redis 企业版，即 Tair 3.0，兼容 Redis 5.0。</li>
</ul>
</li>
<li><strong>列族数据库</strong>：Apache <a href="https://help.aliyun.com/zh/hbase/product-overview/what-is-apsaradb-for-hbase">HBase</a>，为淘宝推荐、手淘消息等提供支撑的数据库
<ul>
<li>早期淘宝交易订单的所有数据都存储在单独的 Oracle 数据库；2010 年拆分为在线库和历史库，三个月之前的历史订单迁移进单独的 Oracle 历史库；2011 年交易历史库整体迁移到 HBase；2018 年历史库迁移到基于 X-Engine 存储引擎的 PolarDB-X 集群<sup class="footnote-ref"><a href="#fn88" id="fnref88">[88]</a></sup>。</li>
</ul>
</li>
<li><strong>搜索引擎</strong>：Havenask（自研，<a href="https://www.infoq.cn/article/myy674gdqphqgvm8u2h5">2022.12</a> 对外开源）
<ul>
<li>支持了淘宝、天猫、菜鸟、优酷、高德、饿了么等在内整个阿里的搜索业务。阿里云的 <a href="https://help.aliyun.com/zh/open-search/">OpenSearch</a> 产品底层基于 Havenask 实现。</li>
</ul>
</li>
<li><strong>Blob文件存储</strong>：阿里云 OSS
<ul>
<li>早期采用 NetApp 提供的 NAS 存储设备；2007.06 开始基于自研的 <a href="https://github.com/alibaba/tfs">TFS</a>（Taobao File System）；2010.09 对外开源 TFS；2016 迁移到阿里云 OSS<sup class="footnote-ref"><a href="#fn89" id="fnref89">[89]</a></sup>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据分析</strong>：阿里云 <a href="https://help.aliyun.com/zh/flink/">Flink</a>、阿里云 <a href="https://help.aliyun.com/zh/maxcompute/">MaxCompute</a>（离线数仓）、阿里云 <a href="https://cn.aliyun.com/product/bigdata/hologram">Hologres</a>（实时数仓）等
<ul>
<li>早期阿里内部三大实时计算引擎并存，Galaxy、JStorm、Blink（<a href="https://en.wikipedia.org/wiki/Apache_Flink">Apache Flink</a> 的分支），<a href="https://flink-learning.org.cn/article/detail/b91ee62ecc12107ed15ccd0c97d33cd5">2017</a> 年开始统一到 Blink。2019.01，阿里收购 Apache Flink 母公司 Data Artisans，随后阿里的 Blink 正式开源，之后 Blink 和 Flink 完成合并。2021 年开始，阿里内部的实时计算使用的是 Blink 团队与 Flink 创始团队联合打造了 <a href="https://help.aliyun.com/zh/flink/">Flink 企业版</a>平台，即 VVP（Ververica Platform）。</li>
</ul>
</li>
</ul>
<p>2016 年，阿里产品专家倪超对外介绍的阿里电商技术架构，如下图所示<sup class="footnote-ref"><a href="#fn90" id="fnref90">[90]</a></sup>：</p>
<img width="600" alt="阿里电商技术架构（2016）" title="阿里电商技术架构（2016）" src="https://static.nullwy.me/alibaba-architecture-2016.png">
<p>类似的，阿里巴巴中间件首席架构师《企业IT架构转型之道》（<a href="https://book.douban.com/subject/27039508/">豆瓣</a>）作者钟华在 2017 年对外介绍的阿里电商技术架构图<sup class="footnote-ref"><a href="#fn91" id="fnref91">[91]</a></sup>：</p>
<img width="600" alt="阿里电商中台架构（2017）" title="阿里电商中台架构（2017）" src="https://static.nullwy.me/alibaba-middle-platform-2017.png">
<p>2017 年，阿里中间件技术部专家谢吉宝对外介绍的阿里中间件技术大图<sup class="footnote-ref"><a href="#fn83" id="fnref83:3">[83:3]</a></sup>：</p>
<img width="600" alt="阿里中间件技术大图（2017）" title="阿里中间件技术大图（2017）" src="https://static.nullwy.me/alibaba-middleware-2017.png">
<p>阿里 HSF 与 Dubbo 的历史演进时间线：</p>
<ul>
<li>2008 年，阿里淘宝团队自研 HSF 框架，5 月发布 HSF 1.1。</li>
<li>2009 年初，由阿里 B2B 团队研发的 Dubbo 发布 1.0 版本。阿里内部淘系（淘宝、天猫、一淘等）主要使用的服务框架是 HSF，而阿里 B2B 使用的则是 Dubbo，二者独立，各行其道，彼此不通<sup class="footnote-ref"><a href="#fn92" id="fnref92">[92]</a></sup>。</li>
<li>2010.04，重构后发布 Dubbo 2.0 版本。</li>
<li><a href="https://www.iteye.com/topic/1116866">2011.10</a>，Dubbo 对外开源，版本为 2.0.7。因为在功能完善性、架构优雅性、使用简便性等方面有其相对独特的优势，开源后被国内很多互联网公司广泛使用<sup class="footnote-ref"><a href="#fn93" id="fnref93">[93]</a></sup>，包括去哪儿，京东、当当网、网易考拉、有赞等。</li>
<li>2012 年，阿里内部架构调整，开始统一技术基础设施，合并重复项目，决定把 Dubbo 合并到 HSF 里面去<sup class="footnote-ref"><a href="#fn94" id="fnref94">[94]</a></sup>。随后，HSF 发布 2.0 的版本，兼容 Dubbo 的协议，HSF 推出后很快就在阿里集团全面铺开<sup class="footnote-ref"><a href="#fn92" id="fnref92:1">[92:1]</a></sup>。Dubbo 项目在阿里内部被抛弃，在 2012.10 发布 2.5.3 版本之后就停止更新，2013 年和 2014 年更新了 2 次 Dubbo 2.4 的维护版本，然后停止了所有维护工作。</li>
<li><a href="www.infoq.com/cn/news/2014/10/dubbox-open-source">2014.10</a>，当当网开源 Dubbox，基于 Dubbo 2.5.3 的代码，为 Dubbo 新增了 REST 风格远程调用、Kryo/FST 序列化等特性。</li>
<li><a href="https://mp.weixin.qq.com/s/P5p7jMcaZVW15sknDbgdRQ">2016.01</a>，阿里云互联网中间件产品 <a href="https://help.aliyun.com/zh/edas/product-overview/what-is-edas">EDAS</a> 正式商用，EDAS 所提供的分布式服务框架源自阿里的 HSF。</li>
<li><a href="https://www.oschina.net/news/88477">2017.09</a>，Dubbo 重启维护，对外发布恢复维护后的第一个版本是 2.5.4。之所以重启是因为阿里云上的客户大部分使用 Dubbo，阿里云想要将基于 Dubbo 的解决方案作为自己的一个产品，卖给这些客户<sup class="footnote-ref"><a href="#fn92" id="fnref92:2">[92:2]</a></sup><sup class="footnote-ref"><a href="#fn94" id="fnref94:1">[94:1]</a></sup>。</li>
<li>2018.01，Dubbo 2.6.0 发布，合并了当当网提供的 Dubbox 分支。</li>
<li>2018.02，阿里宣布将 Dubbo 捐献给 Apache，进入 Apache 孵化器。</li>
<li><a href="https://developer.aliyun.com/article/672608">2018.11</a>，阿里云 EDAS 产品版本升级，新版本实现 SpringCloud 和 Dubbo 用户代码零侵入就能迁移至 EDAS。</li>
<li>2018.12，Dubbo 3.0 正式进入开发阶段，Dubbo 3.0 是 HSF 与 Dubbo 的融合版本。</li>
<li>2019.01，Dubbo 2.7.0 发布，包名切换到 org.apache，全面拥抱 Java 8。</li>
<li><a href="https://www.infoq.cn/article/LHqFdI_X9kdHdeXkZ7xf">2019.05</a>，Dubbo 从 Apache 毕业，成为 Apache 的顶级项目。</li>
<li>2020 年，在双十一前在阿里内部率先由阿里考拉实现了 Dubbo 3.0 的全面部署。</li>
<li>2021.06，Dubbo 3.0 正式发布。</li>
<li>2022 年，阿里集团几乎所有的业务线（包括淘宝、天猫、饿了么、钉钉等）全面从 HSF2 迁移到 Dubbo3。阿里内部使用的是 HSF3，HSF3 与以往的 HSF2 完全不同，HSF3 完全就是基于标准 Dubbo3 的 SPI 扩展库<sup class="footnote-ref"><a href="#fn95" id="fnref95">[95]</a></sup><sup class="footnote-ref"><a href="#fn96" id="fnref96">[96]</a></sup>。</li>
</ul>
<p>阿里 RocketMQ 的历史演进时间线：</p>
<ul>
<li>2007，自研 Notify，最早底层的消息存储采用本地文件存储，参考 ActiveMQ 实现了单机 kv 存储引擎，2008 年底层的消息存储改用 Oracle，2010 年从 Oracle 迁移到高可用 MySQL 存储集群<sup class="footnote-ref"><a href="#fn97" id="fnref97">[97]</a></sup>。</li>
<li>2011.01，基于 Kafka 的设计用 Java 完全重写并发布 MetaQ 1.0。</li>
<li><a href="https://www.infoq.cn/article/2012/03/metamorphosis">2012.03</a>，淘宝对外开源 MetaQ 1.x，项目名为 Metamorphosis（<a href="https://web.archive.org/web/20120312015328/http://code.taobao.org/p/metamorphosis/wiki/intro/">淘蝌蚪</a>、<a href="https://github.com/killme2008/Metamorphosis">GitHub</a>），版本号为 1.4.0。
<ul>
<li>Metamorphosis <a href="https://web.archive.org/web/20120312015318/http://code.taobao.org/p/metamorphosis/wiki/changelist/">1.0.1</a> 开始实现高可用的 HA 方案，支持同步和异步复制，复制特性类似于 MySQL 的主从复制。</li>
<li>Kafka 的复制特性，直到 2013.12 发布的 0.8.0 版本才开始支持。Kafka 实现的复制是集群间的分区复制（Intra-cluster Replication），复制的副本粒度是分区（partition），参见 <a href="https://issues.apache.org/jira/browse/KAFKA-50">KAFKA-50</a>。</li>
</ul>
</li>
<li>2012.09，淘宝内部发布 MetaQ 2.0 版本，MetaQ 2.0 对架构进行了重新设计，为了解决分区文件数增加后的性能下降问题，对消息日志文件存储目录结构做了改造<sup class="footnote-ref"><a href="#fn98" id="fnref98">[98]</a></sup>。改造后的 MetaQ 架构与 Kafka 存在很大差异，这个版本的 MetaQ 可以认为是第一代的 RocketMQ。</li>
<li>2013.07，淘宝内部发布 MetaQ 3.0 版本。</li>
<li>2013.09，对外开源发布 RocketMQ 3.0。RocketMQ 3.0 和 MetaQ 3.0 等价，阿里内部使用的称为 MetaQ 3.0，外部开源称之为 RocketMQ 3.0<sup class="footnote-ref"><a href="#fn99" id="fnref99">[99]</a></sup>。</li>
<li>2014.10，阿里云消息队列 <a href="https://help.aliyun.com/zh/apsaramq-for-rocketmq/">ONS</a>（云开放消息服务，Open Notification Service）对外公测，ONS 是基于阿里消息中间件 MetaQ（RocketMQ）打造的云消息产品。</li>
<li><a href="https://www.oschina.net/news/89061">2016.11</a>，阿里巴巴将 RocketMQ 捐赠给 Apache，成为 Apache 孵化器项目。</li>
<li><a href="https://www.oschina.net/news/89061">2017.09</a>，RocketMQ 从孵化器毕业，正式成为 Apache 顶级项目。</li>
</ul>
<h1 id="LinkedIn（2003）">LinkedIn（2003）</h1>
<p>LinkedIn，2003 年创立，采用纯 Java 技术栈，早期是单体架构，到 2008 年演化为 SOA 架构<sup class="footnote-ref"><a href="#fn100" id="fnref100">[100]</a></sup>。到 2010 年拆分的服务数超过 150 个，到 2015 年拆分的服务数超过 750 个<sup class="footnote-ref"><a href="#fn101" id="fnref101">[101]</a></sup>。</p>
<p>2008 年，LinkedIn 对外介绍的技术架构如下图所示<sup class="footnote-ref"><a href="#fn100" id="fnref100:1">[100:1]</a></sup>：</p>
<img width="600" alt="LinkedIn 技术架构（2008）" title="LinkedIn 技术架构（2008）" src="https://static.nullwy.me/linkedIn-architecture-2008.png">
<p>2012 年，LinkedIn 对外介绍的关注在数据基础设施上的技术架构图<sup class="footnote-ref"><a href="#fn102" id="fnref102">[102]</a></sup>：</p>
<img width="600" alt="LinkedIn 数据基础设施架构（2012）" title="LinkedIn 数据基础设施架构（2012）" src="https://static.nullwy.me/linkedIn-data-infrastructure-icde2012.jpg">
<p>当前 LinkedIn 的主要技术栈<sup class="footnote-ref"><a href="#fn100" id="fnref100:2">[100:2]</a></sup><sup class="footnote-ref"><a href="#fn101" id="fnref101:1">[101:1]</a></sup>：</p>
<ul>
<li><strong>应用服务</strong>：
<ul>
<li><strong>展示层</strong>：Java、Spring MVC、</li>
<li><strong>业务逻辑层</strong>：Java、Spring</li>
<li><strong>RPC框架</strong>：
<ul>
<li><a href="https://github.com/linkedin/rest.li">Rest.li</a>（自研开源），REST + JSON 框架。<a href="https://engineering.linkedin.com/blog/2023/linkedin-integrates-protocol-buffers-with-rest-li-for-improved-m">2023.04</a>，对外宣布 <a href="http://Rest.li">Rest.li</a> 项目不再活跃，为了提升性能，迁移到 Protobuf + gRPC。</li>
</ul>
</li>
<li><strong>消息队列MQ</strong>：ActiveMQ</li>
</ul>
</li>
<li><strong>数据存储</strong><sup class="footnote-ref"><a href="#fn102" id="fnref102:1">[102:1]</a></sup><sup class="footnote-ref"><a href="#fn103" id="fnref103">[103]</a></sup><sup class="footnote-ref"><a href="#fn104" id="fnref104">[104]</a></sup>：
<ul>
<li><strong>关系数据库</strong>：Oracle（主）、MySQL（次）</li>
<li><strong>缓存</strong>：Memcached</li>
<li><strong>键值存储</strong>：<a href="https://en.wikipedia.org/wiki/Voldemort_%28distributed_data_store%29">Voldemort</a>（自研，2009.01 对外开源）
<ul>
<li><a href="https://blog.linkedin.com/2009/03/20/project-voldemort-scaling-simple-storage-at-linkedin">2009.01</a> 对外开源，设计受 Amazon <a href="https://en.wikipedia.org/wiki/Dynamo_%28storage_system%29">Dynamo</a> 论文影响。2018 年之后 LinkedIn 不在使用 Voldemort，数据迁移到 LinkedIn 的 Venice 数据库</li>
</ul>
</li>
<li><strong>文档数据库</strong>：<a href="https://dbdb.io/db/espresso">Espresso</a>（自研闭源），分布式文档数据库
<ul>
<li>2011 年初开始计划和设计，2012.06 在生产环境部署，底层实现基于 MySQL、Lucene、ZooKeeper。</li>
</ul>
</li>
<li><strong>图数据库</strong>：LIquid（自研闭源）</li>
<li><strong>搜索引擎</strong>：基于 Lucene</li>
<li><strong>Blob文件存储</strong>：<a href="https://github.com/linkedin/ambry">Ambry</a>（自研，<a href="https://engineering.linkedin.com/blog/2016/05/introducing-and-open-sourcing-ambry---linkedins-new-distributed-">2016.05</a> 对外开源）</li>
</ul>
</li>
<li><strong>数据分析</strong><sup class="footnote-ref"><a href="#fn102" id="fnref102:2">[102:2]</a></sup><sup class="footnote-ref"><a href="#fn103" id="fnref103:1">[103:1]</a></sup><sup class="footnote-ref"><a href="#fn104" id="fnref104:1">[104:1]</a></sup>：
<ul>
<li><strong>数据采集</strong>：
<ul>
<li><a href="https://github.com/linkedin/databus">Databus</a>（自研，<a href="https://engineering.linkedin.com/data-replication/open-sourcing-databus-linkedins-low-latency-change-data-capture-system">2013.02</a> 对外开源）
<ul>
<li>数据变更抓取 CDC 工具，支持 Oracle 和 MySQL，2012.10 在 SoCC 2012 会议上发表<a href="https://dblp.org/rec/conf/cloud/DasBSGVNZGWGSTPSS12.html">论文</a>，2013.02 对外开源。</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Apache_Kafka">Apache Kafka</a>（自研，<a href="https://blog.linkedin.com/2011/01/11/open-source-linkedin-kafka">2011.01</a> 对外开源）
<ul>
<li>2011.07 成为 Apache 孵化器项目，2012.10 从 Apache 孵化器毕业</li>
</ul>
</li>
</ul>
</li>
<li><strong>计算引擎</strong>：Apache Hadoop、<a href="https://en.wikipedia.org/wiki/Apache_Samza">Apache Samza</a>（自研开源）、Apache Spark、Apache Flink
<ul>
<li>Apache Samza，2013.09 对外开源，2015.01 从 Apache 孵化器毕业</li>
</ul>
</li>
<li><strong>数据仓库</strong>：Apache Hive、Presto、<a href="https://github.com/linkedin/venice">Venice</a> 等</li>
</ul>
</li>
</ul>
<h1 id="Facebook（2004）">Facebook（2004）</h1>
<p>Facebook，2004 年创立，早期采用 LAMP 技术栈，为了应对负载增长开始服务化，将核心业务从 LAMP 中移出到新的服务，新的服务改用使用 C++、Java 等编写。为了解决 PHP 进程与非 PHP 进程的 RPC 通信问题，<a href="https://engineering.fb.com/2014/02/20/open-source/under-the-hood-building-and-open-sourcing-fbthrift/">2006</a> 年内部研发了跨语言的 RPC 库 <a href="https://en.wikipedia.org/wiki/Apache_Thrift">Thrift</a>，2007.04 对外开源。PHP 代码用于实现前端展示层的 Web 动态页面渲染，以及对服务层的数据聚合。</p>
<p>2010 年，Facebook 工程师 Aditya Agarwal 对外介绍的 Facebook 技术架构如下图所示<sup class="footnote-ref"><a href="#fn105" id="fnref105">[105]</a></sup>：</p>
<img width="600" alt="Facebook 技术架构（2010）" title="Facebook 技术架构（2010）" src="https://static.nullwy.me/facebook-architecture-2010.png">
<p>Facebook 的技术栈图<sup class="footnote-ref"><a href="#fn106" id="fnref106">[106]</a></sup>：</p>
<img width="600" alt="Facebook 技术架构（2008）" title="Facebook 技术架构（2008）" src="https://static.nullwy.me/facebook-architecture-2008.png">
<p>Facebook 的 NewsFeed 服务的架构图<sup class="footnote-ref"><a href="#fn106" id="fnref106:1">[106:1]</a></sup>：</p>
<img width="600" alt="Facebook NewsFeed 技术架构（2008）" title="Facebook NewsFeed 技术架构（2008）" src="https://static.nullwy.me/facebook-newsfeed-architecture-2008.png">
<p>Facebook 的 Search 服务的架构图<sup class="footnote-ref"><a href="#fn106" id="fnref106:2">[106:2]</a></sup>：</p>
<img width="600" alt="Facebook Search 技术架构（2008）" title="Facebook Search 技术架构（2008）" src="https://static.nullwy.me/facebook-search-architecture-2008.png">
<p>当前 Facebook 的主要技术栈<sup class="footnote-ref"><a href="#fn105" id="fnref105:1">[105:1]</a></sup><sup class="footnote-ref"><a href="#fn106" id="fnref106:3">[106:3]</a></sup><sup class="footnote-ref"><a href="#fn107" id="fnref107">[107]</a></sup>：</p>
<ul>
<li><strong>应用服务</strong>：
<ul>
<li><strong>展示层</strong>：PHP（早期采用 LAMP 技术栈）、<a href="https://en.wikipedia.org/wiki/HHVM">HHVM</a>（<a href="https://www.facebook.com/notes/10158791564347200/">2011.12</a> 对外开源）、Hack（2014.03 对外发布）</li>
<li><strong>业务逻辑层</strong>：Hack、C++（主要用于实现性能敏感服务，包括 Ads、News Feed、Search 等）、Rust、Java 等<sup class="footnote-ref"><a href="#fn108" id="fnref108">[108]</a></sup><sup class="footnote-ref"><a href="#fn109" id="fnref109">[109]</a></sup></li>
<li><strong>RPC框架</strong>：<a href="https://en.wikipedia.org/wiki/Apache_Thrift">Apache Thrift</a>（自研开源）
<ul>
<li>2005 年末开始研发；2007.04 对外开源；<a href="https://thrift.apache.org/about">2008.05</a> 成为 Apache 孵化器项目；2010.10 从 Apache 孵化器毕业。</li>
</ul>
</li>
<li><strong>消息队列MQ</strong>：Wormhole（自研闭源）
<ul>
<li><a href="https://engineering.fb.com/2013/06/13/core-infra/wormhole-pub-sub-system-moving-data-through-space-and-time/">2013.06</a> 对外介绍；2015.05 在 <a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/sharma">NSDI 2015</a> 会议上发表论文。Wormhole 是发布-订阅系统，消息发布者直接读取数据存储系统的写事务日志，投递给对消息感兴趣的订阅者，订阅者可能是 News Feed、Cache、Index Servers 等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据存储</strong>：
<ul>
<li><strong>关系数据库</strong>：MySQL、MySQL 存储引擎 <a href="https://en.wikipedia.org/wiki/MyRocks">MyRocks</a>（自研，<a href="https://github.com/facebook/mysql-5.6/wiki">2015.11</a> 对外开源）
<ul>
<li><a href="https://en.wikipedia.org/wiki/RocksDB">RocksDB</a> 是 Facebook 在 2012.04 创建的内嵌的键值数据库，基于 Google 开源的 <a href="https://en.wikipedia.org/wiki/LevelDB">LevelDB</a> 代码。</li>
<li><a href="https://en.wikipedia.org/wiki/MyRocks">MyRocks</a> 是 Facebook 基于 RocksDB 数据库实现的 MySQL 存储引擎，2014 年开始研究 RocksDB 和 MySQL 的集成，2015.11 对外开源，在 <a href="https://www.slideshare.net/matsunobu/myrocks-deep-dive">2016.04</a> 在 Percona Live 2016 会议上最早对外介绍。</li>
<li><a href="https://engineering.fb.com/2017/09/25/core-infra/migrating-a-database-from-innodb-to-myrocks/">2017.08</a>，Facebook 将 UDB 数据库（User Database，存储社交活动数据）从 InnoDB 完全迁移到了 MyRocks，迁移后存储空间使用量减少了一半，而 CPU 和 IO 使用率没有明显变化。</li>
<li><a href="https://engineering.fb.com/2018/06/26/core-infra/migrating-messenger-storage-to-optimize-performance/">2018.06</a>，Facebook 在博客上对外介绍已经将 Messenger 应用的数据从 HBase 迁移到了 MyRocks，迁移后存储空间使用量减少 90%，读取延迟比以前的系统低 50 倍。值得注意的是，Messenger 应用的数据最早存储在 Facebook 自研的 <a href="https://en.wikipedia.org/wiki/Apache_Cassandra">Cassandra</a> 上，<a href="https://engineering.fb.com/2010/11/15/core-infra/the-underlying-technology-of-messages/">2010</a> 年底发布新版的 Messenger 开始，改为存储在 HBase 上。</li>
</ul>
</li>
<li><strong>键值存储</strong>：<a href="https://engineering.fb.com/2021/08/06/core-infra/zippydb/">ZippyDB</a>（自研闭源），基于 RocksDB 实现的分布式键值数据库，2013 年开始在 Facebook 部署使用</li>
<li><strong>缓存</strong>：<a href="https://github.com/facebook/mcrouter">Mcrouter</a>（自研开源），实现分布式扩展的 Memcached
<ul>
<li>Facebook 早在 2005.04 就已经开始使用 Memcached；<a href="https://www.facebook.com/notes/10158791580232200/">2013.04</a> 在 <a href="https://www.usenix.org/conference/nsdi13/technical-sessions/presentation/nishtala">NSDI 2013</a> 会议上发表论文，描述对 Memcached 的分布式扩展性改造。</li>
</ul>
</li>
<li><strong>图数据库</strong>：<a href="https://engineering.fb.com/2013/06/25/core-infra/tao-the-power-of-the-graph/">TAO</a>（自研闭源），底层是 Memcache 和 MySQL</li>
<li><strong>搜索引擎</strong>：<a href="https://research.facebook.com/publications/unicorn-a-system-for-searching-the-social-graph/">Unicorn</a>（自研闭源），基于标准的搜索引擎的概念，但增加了社交图谱搜索的特性。Facebook 搜索功能（包括 <a href="https://en.wikipedia.org/wiki/Facebook_Graph_Search">Facebook Graph Search</a> 产品）底层实现基于 Unicorn。
<ul>
<li>2013.03 Facebook Graph Search 产品对外推出，2014.12 开始原始的图谱搜索公开可见度降低，2019.06 几乎完全弃用。</li>
<li>2015 年初，Instagram 的搜索引擎从 Elasticsearch 迁移到 Unicorn<sup class="footnote-ref"><a href="#fn110" id="fnref110">[110]</a></sup>。</li>
</ul>
</li>
<li><strong>Blob文件存储</strong>：Haystack（自研闭源）
<ul>
<li><a href="https://engineering.fb.com/2009/04/30/core-infra/needle-in-a-haystack-efficient-storage-of-billions-of-photos/">2009.04</a> 对外介绍；2010.10 在 <a href="https://dblp.org/rec/conf/osdi/BeaverKLSV10.html">OSDI 2010</a> 会议上发表论文。基于 Haystack 论文的开源实现包括：<a href="https://github.com/seaweedfs/seaweedfs">SeaweedFS</a>、bilibili 的 <a href="https://github.com/Terry-Mao/bfs">BFS</a> 等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据分析</strong><sup class="footnote-ref"><a href="#fn111" id="fnref111">[111]</a></sup><sup class="footnote-ref"><a href="#fn112" id="fnref112">[112]</a></sup>：
<ul>
<li><strong>日志采集</strong>：<a href="https://en.wikipedia.org/wiki/Scribe_%28log_server%29">Scribe</a>（自研，<a href="https://engineering.fb.com/2008/10/24/web/facebook-s-scribe-technology-now-open-source/">2008.10</a> 对外开源）</li>
<li><strong>计算引擎</strong>：XStream（Puma、Stylus、Swift）</li>
<li><strong>数据仓库</strong>：<a href="https://en.wikipedia.org/wiki/Apache_Hive">Apache Hive</a>（自研，2008.08 对外开源）、<a href="https://en.wikipedia.org/wiki/Presto_%28SQL_query_engine%29">Presto</a>（自研，2013.11 对外开源）、Laser、Scuba</li>
</ul>
</li>
</ul>
<h1 id="Twitter（2006）">Twitter（2006）</h1>
<p>Twitter，2006 年创立，早期采用 Ruby on Rails 技术栈，数据库是 MySQL，2009 年开始服务化，将核心业务从 Ruby on Rails 中移出到新的服务，新的服务用 Scala、Java 编写<sup class="footnote-ref"><a href="#fn113" id="fnref113">[113]</a></sup><sup class="footnote-ref"><a href="#fn114" id="fnref114">[114]</a></sup>。</p>
<p>2013 年，Twitter 工程师总结的 Twitter 从单体架构向分布式架构演进的过程，如下图所示<sup class="footnote-ref"><a href="#fn114" id="fnref114:1">[114:1]</a></sup>：</p>
<img width="600" alt="Twitter 单体架构" title="Twitter 单体架构" src="https://static.nullwy.me/twitter-architecture-rails.png">
<img width="600" alt="Twitter 服务化架构（2013）" title="Twitter 服务化架构（2013）" src="https://static.nullwy.me/twitter-architecture-2013.png">
<p>当前 Twitter 的主要技术栈<sup class="footnote-ref"><a href="#fn113" id="fnref113:1">[113:1]</a></sup><sup class="footnote-ref"><a href="#fn114" id="fnref114:2">[114:2]</a></sup>：</p>
<ul>
<li><strong>应用服务</strong>：
<ul>
<li><strong>展示层</strong>：Ruby on Rails</li>
<li><strong>业务逻辑层</strong>：Scala（主要）、Java</li>
<li><strong>RPC框架</strong>：<a href="https://github.com/twitter/finagle">Finagle</a>（自研，<a href="https://blog.twitter.com/engineering/en_us/a/2011/finagle-a-protocol-agnostic-rpc-system">2011.08</a> 对外开源）
<ul>
<li>使用 Finagle 框架的公司包括：Foursquare（<a href="https://www.scala-lang.org/old/node/5130">2010</a> PHP 转向 Scala）、Pinterest（Python + Java）、SoundCloud（Ruby + JVM）、Tumblr（PHP + Scala） 等。</li>
</ul>
</li>
<li><strong>消息队列MQ</strong>：Kestrel（<a href="https://robey.livejournal.com/53832.html">2008.11</a> 对外开源） -&gt; DistributedLog -&gt; Kafka</li>
<li><strong>链路追踪</strong>：<a href="https://github.com/openzipkin/zipkin">Zipkin</a>（自研开源）
<ul>
<li><a href="https://blog.twitter.com/engineering/en_us/a/2012/distributed-systems-tracing-with-zipkin">2012.06</a>，对外开源，是 Google <a href="https://research.google/pubs/pub36356/">Dapper</a> 链路追踪系统的开源实现。</li>
<li>2015 年中，项目从 Twitter 转交到 OpenZipkin 开源组织。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据存储</strong><sup class="footnote-ref"><a href="#fn115" id="fnref115">[115]</a></sup>：
<ul>
<li><strong>关系数据库</strong>：MySQL、Manhattan（自研闭源，基于 MySQL 的分布式数据库）
<ul>
<li>最初所有数据都存储在 MySQL 上。</li>
<li><a href="https://news.ycombinator.com/item?id=987693">2009</a> 年底，计划从 MySQL 迁移到 Cassandra，打算用 Cassandra 存储推文 Tweets 数据，但最终改变了策略，继续使用 MySQL，Cassandra 仅被用于存储分析数据<sup class="footnote-ref"><a href="#fn116" id="fnref116">[116]</a></sup>。</li>
<li>2010.04，对外开源数据库分片框架 <a href="https://en.wikipedia.org/wiki/Gizzard_%28Scala_framework%29">Gizzard</a>，基于 Gizzard 的分布式数据库 T-bird 被用于存储推文 Tweets 数据<sup class="footnote-ref"><a href="#fn117" id="fnref117">[117]</a></sup>。</li>
<li><a href="https://blog.twitter.com/engineering/en_us/a/2014/manhattan-our-real-time-multi-tenant-distributed-database-for-twitter-scale">2014.04</a>，对外介绍自研的基于 MySQL 的分布式数据库 Manhattan，被用于存储推文 Tweets 等主要数据，Cassandra 被废弃。</li>
<li><a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2021/adopting-rocksdb-within-manhattan">2018</a> 年中，开始将 Manhattan 底层使用的 MhBtree 存储引擎改为基于 RocksDB 存储引擎。</li>
</ul>
</li>
<li><strong>缓存和键值存储</strong>：Redis、Memcached</li>
<li><strong>图数据库</strong>：<a href="https://en.wikipedia.org/wiki/FlockDB">FlockDB</a>（自研开源）</li>
<li><strong>搜索引擎</strong>：Earlybird<sup class="footnote-ref"><a href="#fn118" id="fnref118">[118]</a></sup>（自研闭源）、Elasticsearch<sup class="footnote-ref"><a href="#fn119" id="fnref119">[119]</a></sup>，用于推文 Tweets、用户、消息等搜索
<ul>
<li><a href="https://blog.twitter.com/engineering/en_us/a/2010/twitters-new-search-architecture">2010</a> 年，自研基于 Lucene 实现的 Earlybird 搜索引擎，替代旧的基于 MySQL 实现的搜索<sup class="footnote-ref"><a href="#fn118" id="fnref118:1">[118:1]</a></sup></li>
</ul>
</li>
<li><strong>Blob文件存储</strong>：Blobstore（自研闭源）
<ul>
<li>2011 年，使用 <a href="https://en.wikipedia.org/wiki/Photobucket">Photobucket</a>；<a href="https://blog.twitter.com/engineering/en_us/a/2012/blobstore-twitter-s-in-house-photo-storage-system">2012.09</a> 开始改为使用自研的 Blobstore。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据分析</strong><sup class="footnote-ref"><a href="#fn120" id="fnref120">[120]</a></sup>：Kafka、Cloud BigTable、Cloud BigQuery 等</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Similarweb: Top Websites Ranking <a href="https://www.similarweb.com/top-websites/">https://www.similarweb.com/top-websites/</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>2020-08 Ranked: The Most Popular Websites Since 1993 (Captain Gizmo) <a href="https://www.visualcapitalist.com/most-popular-websites-since-1993/">https://www.visualcapitalist.com/most-popular-websites-since-1993/</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>List of social platforms with at least 100 million active users <a href="https://en.wikipedia.org/wiki/List_of_social_platforms_with_at_least_100_million_active_users">https://en.wikipedia.org/wiki/List_of_social_platforms_with_at_least_100_million_active_users</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2023-02 艾媒金榜｜2022年度中国APP月活排行榜 <a href="https://www.iimedia.cn/c880/91597.html">https://www.iimedia.cn/c880/91597.html</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2007 Jeff Dean: Software Engineering Advice from Building Large-Scale Distributed Systems (Stanford CS295 class lecture, Spring, 2007) <a href="https://research.google.com/people/jeff/stanford-295-talk.pdf">https://research.google.com/people/jeff/stanford-295-talk.pdf</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>2008-11 Google Architecture <a href="http://highscalability.com/blog/2008/11/22/google-architecture.html">http://highscalability.com/blog/2008/11/22/google-architecture.html</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2008-06 新浪夏清然、徐继哲：自由软件和新浪网. 程序员 2008年第6期54-55，<a href="https://kns.cnki.net/kcms2/article/abstract?v=zcLOVLBHd2yRQ8cenitMd2JyjVqLnTRrIbCiNVgweUi0oksDMHi6mpnw3tjzJCetgm1nmkLf3WsQz_LDhH0H4WbuX5fX2pEZlAPiMqseXpMsfZMncrPMYOQ77jJKNZBm&amp;uniplatform=NZKPT&amp;flag=copy">cnki</a>，<a href="http://lib.cqvip.com/Qikan/Article/Detail?id=27523653">cqvip</a> <a href="http://www.zeuux.com/blog/content/3620/">http://www.zeuux.com/blog/content/3620/</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>2016-01 微信张文瑞：从无到有：微信后台系统的演进之路 <a href="https://www.infoq.cn/article/the-road-of-the-growth-weixin-background">https://www.infoq.cn/article/the-road-of-the-growth-weixin-background</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>2008-02 Yandex Architecture <a href="http://highscalability.com/yandex-architecture">http://highscalability.com/yandex-architecture</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>2007-08 Wikimedia architecture <a href="http://highscalability.com/wikimedia-architecture">http://highscalability.com/wikimedia-architecture</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>2007-11 Flickr Architecture <a href="http://highscalability.com/flickr-architecture">http://highscalability.com/flickr-architecture</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>2016-03 What does Etsy's architecture look like today? <a href="http://highscalability.com/blog/2016/3/23/what-does-etsys-architecture-look-like-today.html">http://highscalability.com/blog/2016/3/23/what-does-etsys-architecture-look-like-today.html</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>2011-05 新浪刘晓震：新浪博客应用架构分享 (PHPChina 2011) <a href="https://web.archive.org/web/0/http://www.phpchina.com/?action-viewnews-itemid-38418">https://web.archive.org/web/0/http://www.phpchina.com/?action-viewnews-itemid-38418</a> <a href="https://www.modb.pro/doc/121035">https://www.modb.pro/doc/121035</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>2013-11 百度张东进：百度PHP基础设施构建思路 (QCon上海2013, slides, 30p) <a href="https://www.modb.pro/doc/121042">https://www.modb.pro/doc/121042</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>2013-05 The Tumblr Architecture Yahoo Bought for a Cool Billion Dollars <a href="http://highscalability.com/blog/2013/5/20/the-tumblr-architecture-yahoo-bought-for-a-cool-billion-doll.html">http://highscalability.com/blog/2013/5/20/the-tumblr-architecture-yahoo-bought-for-a-cool-billion-doll.html</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>2017-06 B站任伟：B站高性能微服务架构 <a href="https://zhuanlan.zhihu.com/p/33247332">https://zhuanlan.zhihu.com/p/33247332</a> <a href="#fnref16" class="footnote-backref">↩︎</a> <a href="#fnref16:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>2021-05 微博刘道儒：十年三次重大架构升级，微博应对“极端热点”的进阶之路 <a href="https://www.infoq.cn/article/qgwbh0wz5bvw9apjos2a">https://www.infoq.cn/article/qgwbh0wz5bvw9apjos2a</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2012-08 腾讯张松国：腾讯微博架构介绍 (ArchSummit深圳2012, slides, 59p) <a href="https://www.slideshare.net/dleyanlin/08-13994311">https://www.slideshare.net/dleyanlin/08-13994311</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>2016-02 美团夏华夏：从技术细节看美团架构 (ArchSummit北京2014) <a href="https://www.infoq.cn/article/see-meituan-architecture-from-technical-details">https://www.infoq.cn/article/see-meituan-architecture-from-technical-details</a> <a href="http://bj2014.archsummit.com/node/596/">http://bj2014.archsummit.com/node/596/</a> <a href="https://www.modb.pro/doc/8311">https://www.modb.pro/doc/8311</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>2019-06 滴滴杜欢：大型微服务框架设计实践 (Gopher China 2019) <a href="https://www.infoq.cn/article/EfOlY8_rubh4LfoXzF8B">https://www.infoq.cn/article/EfOlY8_rubh4LfoXzF8B</a> <a href="https://www.modb.pro/doc/35485">https://www.modb.pro/doc/35485</a> <a href="#fnref20" class="footnote-backref">↩︎</a> <a href="#fnref20:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>2018-08 E-Commerce at Scale: Inside Shopify's Tech Stack - <a href="http://Stackshare.io">Stackshare.io</a> <a href="https://shopify.engineering/e-commerce-at-scale-inside-shopifys-tech-stack">https://shopify.engineering/e-commerce-at-scale-inside-shopifys-tech-stack</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>2013-03 Phil Calçado @ SoundCloud: From a monolithic Ruby on Rails app to the JVM (slides, 75p) <a href="https://www.slideshare.net/pcalcado/from-a-monolithic-ruby-on-rails-app-to-the-jvm">https://www.slideshare.net/pcalcado/from-a-monolithic-ruby-on-rails-app-to-the-jvm</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>2012-07 Go at SoundCloud <a href="https://developers.soundcloud.com/blog/go-at-soundcloud">https://developers.soundcloud.com/blog/go-at-soundcloud</a> <a href="#fnref23" class="footnote-backref">↩︎</a> <a href="#fnref23:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>2014-04 Peter Bourgon @ SoundCloud: Go: Best Practices for Production Environments (GopherCon 2014) <a href="http://peter.bourgon.org/go-in-production/">http://peter.bourgon.org/go-in-production/</a> <a href="#fnref24" class="footnote-backref">↩︎</a> <a href="#fnref24:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>2009-04 Heroku - Simultaneously Develop and Deploy Automatically Scalable Rails Applications in the Cloud <a href="http://highscalability.com/blog/2009/4/24/heroku-simultaneously-develop-and-deploy-automatically-scala.html">http://highscalability.com/blog/2009/4/24/heroku-simultaneously-develop-and-deploy-automatically-scala.html</a> <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>2021-07 GitHub’s Journey from Monolith to Microservices <a href="https://www.infoq.com/articles/github-monolith-microservices/">https://www.infoq.com/articles/github-monolith-microservices/</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>2017-12 Building Services at Airbnb, Part 1 <a href="https://medium.com/airbnb-engineering/c4c1d8fa811b">https://medium.com/airbnb-engineering/c4c1d8fa811b</a> <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>2020-11 Jessica Tai @ Airbnb: How to Tame Your Service APIs: Evolving Airbnb’s Architecture <a href="https://www.infoq.com/presentations/airbnb-api-architecture/">https://www.infoq.com/presentations/airbnb-api-architecture/</a> <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>2013-08 Reddit: Lessons Learned from Mistakes Made Scaling to 1 Billion Pageviews a Month <a href="http://highscalability.com/blog/2013/8/26/reddit-lessons-learned-from-mistakes-made-scaling-to-1-billi.html">http://highscalability.com/blog/2013/8/26/reddit-lessons-learned-from-mistakes-made-scaling-to-1-billi.html</a> <a href="#fnref29" class="footnote-backref">↩︎</a> <a href="#fnref29:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>2012-03 7 Years of YouTube Scalability Lessons in 30 Minutes <a href="http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html">http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html</a> <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>2016-04 豆瓣田忠博：豆瓣的服务化体系改造 (QCon北京2016, slides, 37p) <a href="http://2016.qconbeijing.com/presentation/2834/">http://2016.qconbeijing.com/presentation/2834/</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>2010-09 Disqus: Scaling the World's Largest Django App (DjangoCon 2010, slides) <a href="https://www.slideshare.net/zeeg/djangocon-2010-scaling-disqus">https://www.slideshare.net/zeeg/djangocon-2010-scaling-disqus</a> <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>2021-05 Dropbox: Atlas: Our journey from a Python monolith to a managed platform <a href="https://dropbox.tech/infrastructure/atlas--our-journey-from-a-python-monolith-to-a-managed-platform">https://dropbox.tech/infrastructure/atlas--our-journey-from-a-python-monolith-to-a-managed-platform</a> <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>2014-07 Dropbox: Open Sourcing Our Go Libraries <a href="https://dropbox.tech/infrastructure/open-sourcing-our-go-libraries">https://dropbox.tech/infrastructure/open-sourcing-our-go-libraries</a> <a href="#fnref34" class="footnote-backref">↩︎</a> <a href="#fnref34:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>2017-07 Tammy Butow @ Dropbox: Go Reliability and Durability at Dropbox <a href="https://about.sourcegraph.com/blog/go/go-reliability-and-durability-at-dropbox-tammy-butow">https://about.sourcegraph.com/blog/go/go-reliability-and-durability-at-dropbox-tammy-butow</a> <a href="#fnref35" class="footnote-backref">↩︎</a> <a href="#fnref35:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>2011-02 Adam D'Angelo: Why did Quora choose C++ over C for its high performance services? Does the Quora codebase use a limited subset of C++? <a href="https://qr.ae/pKwCE3">https://qr.ae/pKwCE3</a> <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>2012-02 A Short on the Pinterest Stack for Handling 3+ Million Users <a href="http://highscalability.com/blog/2012/2/16/a-short-on-the-pinterest-stack-for-handling-3-million-users.html">http://highscalability.com/blog/2012/2/16/a-short-on-the-pinterest-stack-for-handling-3-million-users.html</a> <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p>2015-08 Finagle and Java Service Framework at Pinterest (slides) <a href="https://www.slideshare.net/yongshengwu/finaglecon2015pinterest">https://www.slideshare.net/yongshengwu/finaglecon2015pinterest</a> <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>2013-03 Instagram 5位传奇工程师背后的技术揭秘 <a href="https://web.archive.org/web/0/http://www.csdn.net/article/2013-03-28/2814698-The-technologie-%20behind-Instagram">https://web.archive.org/web/0/http://www.csdn.net/article/2013-03-28/2814698-The-technologie- behind-Instagram</a> <a href="#fnref39" class="footnote-backref">↩︎</a> <a href="#fnref39:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p>2017-03 Lisa Guo: Scaling Instagram Infrastructure（QCon London 2017, 87p） <a href="https://www.infoq.com/presentations/instagram-scale-infrastructure/">https://www.infoq.com/presentations/instagram-scale-infrastructure/</a> <a href="#fnref40" class="footnote-backref">↩︎</a> <a href="#fnref40:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn41" class="footnote-item"><p>2019-08 Static Analysis at Scale: An Instagram Story <a href="https://instagram-engineering.com/8f498ab71a0c">https://instagram-engineering.com/8f498ab71a0c</a> <a href="#fnref41" class="footnote-backref">↩︎</a> <a href="#fnref41:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn42" class="footnote-item"><p>2016-07 The Uber Engineering Tech Stack, Part I: The Foundation <a href="https://web.archive.org/web/0/https://eng.uber.com/tech-stack-part-one/">https://web.archive.org/web/0/https://eng.uber.com/tech-stack-part-one/</a> <a href="#fnref42" class="footnote-backref">↩︎</a> <a href="#fnref42:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn43" class="footnote-item"><p>2018-11 知乎社区核心业务 Golang 化实践 <a href="https://zhuanlan.zhihu.com/p/48039838">https://zhuanlan.zhihu.com/p/48039838</a> <a href="#fnref43" class="footnote-backref">↩︎</a> <a href="#fnref43:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn44" class="footnote-item"><p>2022-10 字节马春辉：字节大规模微服务语言发展之路 <a href="https://www.infoq.cn/article/n5hkjwfx1gxklkh8iham">https://www.infoq.cn/article/n5hkjwfx1gxklkh8iham</a> <a href="#fnref44" class="footnote-backref">↩︎</a> <a href="#fnref44:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn45" class="footnote-item"><p>2021-07 字节成国柱：字节跳动微服务架构体系演进 <a href="https://mp.weixin.qq.com/s/1dgCQXpeufgMTMq_32YKuQ">https://mp.weixin.qq.com/s/1dgCQXpeufgMTMq_32YKuQ</a> <a href="#fnref45" class="footnote-backref">↩︎</a> <a href="#fnref45:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn46" class="footnote-item"><p>Why does Google use Java instead of Python for Gmail? <a href="https://qr.ae/pKkduC">https://qr.ae/pKkduC</a> <a href="#fnref46" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn47" class="footnote-item"><p>2011-07 揭秘Google+技术架构 <a href="http://www.infoq.com/cn/news/2011/07/Google-Plus">http://www.infoq.com/cn/news/2011/07/Google-Plus</a> <a href="#fnref47" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn48" class="footnote-item"><p>2009-12 人人网架构师张洁：人人网使用的开源软件列表 <a href="https://web.archive.org/web/0/http://ugc.renren.com/2009/12/13/a-list-of-open-source-software-in-renren">https://web.archive.org/web/0/http://ugc.renren.com/2009/12/13/a-list-of-open-source-software-in-renren</a> <a href="#fnref48" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn49" class="footnote-item"><p>2018-12 Netflix OSS and Spring Boot — Coming Full Circle <a href="https://netflixtechblog.com/4855947713a0">https://netflixtechblog.com/4855947713a0</a> <a href="#fnref49" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn50" class="footnote-item"><p>携程为什么突然技术转型从 .NET 转 Java？ <a href="https://www.zhihu.com/question/56259195">https://www.zhihu.com/question/56259195</a> <a href="#fnref50" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn51" class="footnote-item"><p>京东技术解密，2014，<a href="https://book.douban.com/subject/26264767/">豆瓣</a>：12 少年派的奇幻漂流——从.Net到Java <a href="#fnref51" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn52" class="footnote-item"><p>Golang Frequently Asked Questions: Why did you create a new language? <a href="https://go.dev/doc/faq#creating_a_new_language">https://go.dev/doc/faq#creating_a_new_language</a> <a href="#fnref52" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn53" class="footnote-item"><p>2014-05 Brad Fitzpatrick: Go: 90% Perfect, 100% of the time: Fun vs. Fast <a href="https://go.dev/talks/2014/gocon-tokyo.slide#28">https://go.dev/talks/2014/gocon-tokyo.slide#28</a> <a href="#fnref53" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn54" class="footnote-item"><p>2021-08 百度Geek说：短视频go研发框架实践 <a href="https://my.oschina.net/u/4939618/blog/5191598">https://my.oschina.net/u/4939618/blog/5191598</a> <a href="#fnref54" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn55" class="footnote-item"><p>2023-07 百度Geek说：从 php5.6 到 golang1.19 - 文库 App 性能跃迁之路 <a href="https://my.oschina.net/u/4939618/blog/10086661">https://my.oschina.net/u/4939618/blog/10086661</a> <a href="#fnref55" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn56" class="footnote-item"><p>2022-03 2021年，腾讯研发人员增长41%，Go首次超越C++成为最热门语言 <a href="https://mp.weixin.qq.com/s/zj-DhASG4S-3z56GTYjisg">https://mp.weixin.qq.com/s/zj-DhASG4S-3z56GTYjisg</a> <a href="#fnref56" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn57" class="footnote-item"><p>2020-05 Which Major Companies Use PostgreSQL? What Do They Use It for? <a href="https://learnsql.com/blog/companies-that-use-postgresql-in-business/">https://learnsql.com/blog/companies-that-use-postgresql-in-business/</a> <a href="#fnref57" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn58" class="footnote-item"><p>2009-05 Why is MySQL more popular than PostgreSQL? <a href="https://news.ycombinator.com/item?id=619871">https://news.ycombinator.com/item?id=619871</a> <a href="#fnref58" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn59" class="footnote-item"><p>Why is MySQL more popular than PostgreSQL? <a href="https://qr.ae/pKPJcE">https://qr.ae/pKPJcE</a> <a href="#fnref59" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn60" class="footnote-item"><p>2002-10 Michael Radwin: Making the Case for PHP at Yahoo! (PHPCon 2002, slides) <a href="https://web.archive.org/web/0/http://www.php-con.com/2002/view/session.php?s=1012">https://web.archive.org/web/0/http://www.php-con.com/2002/view/session.php?s=1012</a> <a href="https://speakerdeck.com/xy/making-the-case-for-php-at-yahoo">https://speakerdeck.com/xy/making-the-case-for-php-at-yahoo</a> <a href="#fnref60" class="footnote-backref">↩︎</a> <a href="#fnref60:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn61" class="footnote-item"><p>2005-10 Michael Radwin: PHP at Yahoo! (PHP Conference 2005, slides) <a href="https://speakerdeck.com/xy/php-at-yahoo-zend2005">https://speakerdeck.com/xy/php-at-yahoo-zend2005</a> <a href="#fnref61" class="footnote-backref">↩︎</a> <a href="#fnref61:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn62" class="footnote-item"><p>2007-06 Federico Feroldi: PHP in Yahoo! (slides) <a href="https://www.slideshare.net/fullo/federico-feroldi-php-in-yahoo">https://www.slideshare.net/fullo/federico-feroldi-php-in-yahoo</a> <a href="#fnref62" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn63" class="footnote-item"><p>2021-02 AWS re:Invent 2020: Amazon’s architecture evolution and AWS strategy <a href="https://www.youtube.com/watch?v=HtWKZSLLYTE">https://www.youtube.com/watch?v=HtWKZSLLYTE</a> <a href="#fnref63" class="footnote-backref">↩︎</a> <a href="#fnref63:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn64" class="footnote-item"><p>What programming languages are used at Amazon? <a href="https://qr.ae/pKFwnw">https://qr.ae/pKFwnw</a> <a href="#fnref64" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn65" class="footnote-item"><p>2011-04 Charlie Cheever: How did Google, Amazon, and the like initially develop and code their websites, databases, etc.? <a href="https://qr.ae/pKKyB0">https://qr.ae/pKKyB0</a> <a href="#fnref65" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn66" class="footnote-item"><p>2016-04 Is Amazon still using Perl Mason to render its content? <a href="https://qr.ae/pKFwFm">https://qr.ae/pKFwFm</a> <a href="#fnref66" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn67" class="footnote-item"><p>2019-10 Migration Complete – Amazon’s Consumer Business Just Turned off its Final Oracle Database <a href="https://aws.Amazon/blogs/aws/migration-complete-amazons-consumer-business-just-turned-off-its-final-oracle-database/?nc1=h_ls">https://aws.Amazon/blogs/aws/migration-complete-amazons-consumer-business-just-turned-off-its-final-oracle-database/?nc1=h_ls</a> <a href="#fnref67" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn68" class="footnote-item"><p>Amazon RDS for PostgreSQL customers <a href="https://aws.Amazon/rds/postgresql/customers/?nc1=h_ls">https://aws.Amazon/rds/postgresql/customers/?nc1=h_ls</a> <a href="#fnref68" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn69" class="footnote-item"><p>Amazon ElastiCache for Redis customers <a href="https://aws.Amazon/elasticache/redis/customers/?nc1=h_ls">https://aws.Amazon/elasticache/redis/customers/?nc1=h_ls</a> <a href="#fnref69" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn70" class="footnote-item"><p>2006-11 Randy Shoup &amp; Dan Pritchett: The eBay Architecture (SDForum2006, slides, 37p) <a href="http://www.addsimplicity.com/downloads/eBaySDForum2006-11-29.pdf">http://www.addsimplicity.com/downloads/eBaySDForum2006-11-29.pdf</a> <a href="#fnref70" class="footnote-backref">↩︎</a> <a href="#fnref70:1" class="footnote-backref">↩︎</a> <a href="#fnref70:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn71" class="footnote-item"><p>2007-05 eBay Architecture <a href="http://highscalability.com/blog/2008/5/27/ebay-architecture.html">http://highscalability.com/blog/2008/5/27/ebay-architecture.html</a> <a href="#fnref71" class="footnote-backref">↩︎</a> <a href="#fnref71:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn72" class="footnote-item"><p>2011-10 Tony Ng: eBay Architecture (slides, 46p) <a href="https://www.slideshare.net/tcng3716/ebay-architecture">https://www.slideshare.net/tcng3716/ebay-architecture</a> <a href="#fnref72" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn73" class="footnote-item"><p>2016-11 Ron Murphy: Microservices at eBay (slides, 20p) <a href="https://www.modb.pro/doc/120378">https://www.modb.pro/doc/120378</a> <a href="#fnref73" class="footnote-backref">↩︎</a> <a href="#fnref73:1" class="footnote-backref">↩︎</a> <a href="#fnref73:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn74" class="footnote-item"><p>2020-09 High Efficiency Tool Platform for Framework Migration <a href="https://innovation.ebayinc.com/tech/engineering/high-efficiency-tool-platform-for-framework-migration/">https://innovation.ebayinc.com/tech/engineering/high-efficiency-tool-platform-for-framework-migration/</a> <a href="#fnref74" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn75" class="footnote-item"><p>2023-10 BES2：打造eBay下一代高可靠消息中间件 <a href="https://mp.weixin.qq.com/s/ThhkO1WM7ck1WO8RqjTCJA">https://mp.weixin.qq.com/s/ThhkO1WM7ck1WO8RqjTCJA</a> <a href="#fnref75" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn76" class="footnote-item"><p>2013-06 Cassandra at eBay - Cassandra Summit 2013 (slides) <a href="https://www.slideshare.net/jaykumarpatel/cassandra-at-ebay-cassandra-summit-2013">https://www.slideshare.net/jaykumarpatel/cassandra-at-ebay-cassandra-summit-2013</a> <a href="#fnref76" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn77" class="footnote-item"><p>2017-03 Sudeep Kumar: 'Elasticsearch as a Service' at eBay <a href="https://www.elastic.co/elasticon/conf/2017/sf/elasticsearch-as-a-service-at-ebay">https://www.elastic.co/elasticon/conf/2017/sf/elasticsearch-as-a-service-at-ebay</a> <a href="#fnref77" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn78" class="footnote-item"><p>2016-08 How eBay Uses Apache Software to Reach Its Big Data Goals <a href="https://www.linux.com/news/how-ebay-uses-apache-software-reach-its-big-data-goals/">https://www.linux.com/news/how-ebay-uses-apache-software-reach-its-big-data-goals/</a> <a href="#fnref78" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn79" class="footnote-item"><p>淘宝技术这十年，子柳，2013，<a href="https://book.douban.com/subject/24335672/">豆瓣</a> <a href="#fnref79" class="footnote-backref">↩︎</a> <a href="#fnref79:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn80" class="footnote-item"><p>尽在双11：阿里巴巴技术演进与超越，2017，<a href="https://book.douban.com/subject/26998040/">豆瓣</a>：第1章 阿里技术架构演进 <a href="#fnref80" class="footnote-backref">↩︎</a> <a href="#fnref80:1" class="footnote-backref">↩︎</a> <a href="#fnref80:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn81" class="footnote-item"><p>2011-06 淘宝吴泽明范禹：淘宝业务发展及技术架构 (slides, 43p) <a href="https://www.modb.pro/doc/116697">https://www.modb.pro/doc/116697</a> <a href="#fnref81" class="footnote-backref">↩︎</a> <a href="#fnref81:1" class="footnote-backref">↩︎</a> <a href="#fnref81:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn82" class="footnote-item"><p>2014-12 阿里云王宇德、张文生：淘宝迁云架构实践 <a href="https://web.archive.org/web/1/http://www.csdn.net/article/a/2014-12-09/15821474">https://web.archive.org/web/1/http://www.csdn.net/article/a/2014-12-09/15821474</a> <a href="#fnref82" class="footnote-backref">↩︎</a> <a href="#fnref82:1" class="footnote-backref">↩︎</a> <a href="#fnref82:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn83" class="footnote-item"><p>2017-07 阿里谢吉宝唐三：阿里电商架构演变之路 (首届阿里巴巴中间件技术峰会, slides, 33p) <a href="https://www.modb.pro/doc/121185">https://www.modb.pro/doc/121185</a> <a href="#fnref83" class="footnote-backref">↩︎</a> <a href="#fnref83:1" class="footnote-backref">↩︎</a> <a href="#fnref83:2" class="footnote-backref">↩︎</a> <a href="#fnref83:3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn84" class="footnote-item"><p>2010-11 淘宝赵林丹臣：淘宝数据库架构演进历程 (iDataForum2010, slides, 38p) <a href="https://www.slideshare.net/ssuser1646de/ss-10163048">https://www.slideshare.net/ssuser1646de/ss-10163048</a> <a href="#fnref84" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn85" class="footnote-item"><p>2019-10 阿里刘振飞：十年磨一剑：从2009启动“去IOE”工程到2019年OceanBase拿下TPC-C世界第一 <a href="https://mp.weixin.qq.com/s/7B6rp17XVhpAWZr1-6DHqQ">https://mp.weixin.qq.com/s/7B6rp17XVhpAWZr1-6DHqQ</a> <a href="https://developer.aliyun.com/article/722414">https://developer.aliyun.com/article/722414</a> <a href="#fnref85" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn86" class="footnote-item"><p>2016-02 SSD的30年发展史 <a href="https://mp.weixin.qq.com/s/JsHKFilB5fvLY9V9z_xsXw">https://mp.weixin.qq.com/s/JsHKFilB5fvLY9V9z_xsXw</a> <a href="#fnref86" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn87" class="footnote-item"><p>2010-04 Yoshinori Matsunobu: SSD Deployment Strategies for MySQL (slides, 52p) <a href="https://www.slideshare.net/matsunobu/ssd-deployment-strategies-for-mysql">https://www.slideshare.net/matsunobu/ssd-deployment-strategies-for-mysql</a> <a href="#fnref87" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn88" class="footnote-item"><p>2020-04 阿里王剑英、和利：淘宝万亿级交易订单背后的存储引擎 <a href="https://mp.weixin.qq.com/s/MkX1Pr8tERrzK29XG9zMUQ">https://mp.weixin.qq.com/s/MkX1Pr8tERrzK29XG9zMUQ</a> <a href="https://help.aliyun.com/zh/rds/apsaradb-rds-for-mysql/storage-engine-that-processes-trillions-of-taobao-order-records">https://help.aliyun.com/zh/rds/apsaradb-rds-for-mysql/storage-engine-that-processes-trillions-of-taobao-order-records</a> <a href="#fnref88" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn89" class="footnote-item"><p>2022-03 阿里云罗庆超：阿里巴巴集团上云之 TFS 迁移 OSS 技术白皮书 <a href="https://developer.aliyun.com/article/876301">https://developer.aliyun.com/article/876301</a> <a href="#fnref89" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn90" class="footnote-item"><p>2016-12 阿里倪超：阿里巴巴Aliware十年微服务架构演进历程中的挑战与实践 <a href="https://www.sohu.com/a/121588928_465959">https://www.sohu.com/a/121588928_465959</a> <a href="#fnref90" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn91" class="footnote-item"><p>2017-10 阿里钟华古谦：企业IT架构转型之道 (杭州云栖大会2017, slides, 18p) <a href="https://www.modb.pro/doc/121695">https://www.modb.pro/doc/121695</a> <a href="#fnref91" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn92" class="footnote-item"><p>2021-09 阿里郭浩：Dubbo 和 HSF 在阿里巴巴的实践：携手走向下一代云原生微服务 <a href="https://mp.weixin.qq.com/s/_Ug3yEh9gz5mLE_ag1DjwA">https://mp.weixin.qq.com/s/_Ug3yEh9gz5mLE_ag1DjwA</a> <a href="#fnref92" class="footnote-backref">↩︎</a> <a href="#fnref92:1" class="footnote-backref">↩︎</a> <a href="#fnref92:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn93" class="footnote-item"><p>2012-11 阿里巴巴分布式服务框架 Dubbo 团队成员梁飞专访 <a href="http://www.iteye.com/magazines/103">http://www.iteye.com/magazines/103</a> <a href="#fnref93" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn94" class="footnote-item"><p>2019-01 Dubbo 作者梁飞亲述：那些辉煌、沉寂与重生的故事 <a href="https://www.infoq.cn/article/3F3Giujjo-QwSw2wEz7u">https://www.infoq.cn/article/3F3Giujjo-QwSw2wEz7u</a> <a href="#fnref94" class="footnote-backref">↩︎</a> <a href="#fnref94:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn95" class="footnote-item"><p>Dubbo 用户案例：阿里巴巴升级 Dubbo3 全面取代 HSF2 <a href="https://cn.dubbo.apache.org/zh-cn/users/alibaba/">https://cn.dubbo.apache.org/zh-cn/users/alibaba/</a> <a href="https://github.com/apache/dubbo-website/blob/ee727525aa61d68b397cc6ddedb322001f0ca4da/content/zh/users/alibaba.md">https://github.com/apache/dubbo-website/blob/ee727525aa61d68b397cc6ddedb322001f0ca4da/content/zh/users/alibaba.md</a> <a href="#fnref95" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn96" class="footnote-item"><p>2023-01 阿里巴巴升级 Dubbo3 全面取代 HSF2 <a href="https://cn.dubbo.apache.org/zh-cn/blog/2023/01/16/%e9%98%bf%e9%87%8c%e5%b7%b4%e5%b7%b4%e5%8d%87%e7%ba%a7-dubbo3-%e5%85%a8%e9%9d%a2%e5%8f%96%e4%bb%a3-hsf2/">https://cn.dubbo.apache.org/zh-cn/blog/2023/01/16/阿里巴巴升级-dubbo3-全面取代-hsf2/</a> <a href="#fnref96" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn97" class="footnote-item"><p>2017-11 阿里林清山隆基：阿里消息中间件架构演进之路：notify和metaq <a href="https://zhuanlan.zhihu.com/p/302600352">https://zhuanlan.zhihu.com/p/302600352</a> <a href="#fnref97" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn98" class="footnote-item"><p>2013-07 淘宝张乐伟韩彰：淘宝消息中间件技术演变：MetaQ 1.0、MetaQ 2.0、MetaQ 3.0（slides, 30p）<a href="https://www.modb.pro/doc/109298">https://www.modb.pro/doc/109298</a> <a href="#fnref98" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn99" class="footnote-item"><p>2017-03 阿里冯嘉鼬神：Apache RocketMQ背后的设计思路与最佳实践 <a href="https://developer.aliyun.com/article/71889">https://developer.aliyun.com/article/71889</a> <a href="#fnref99" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn100" class="footnote-item"><p>2008-05 LinkedIn - A Professional Network built with Java Technologies and Agile Practices (JavaOne2008, slides) <a href="https://www.slideshare.net/linkedin/linkedins-communication-architecture">https://www.slideshare.net/linkedin/linkedins-communication-architecture</a> <a href="#fnref100" class="footnote-backref">↩︎</a> <a href="#fnref100:1" class="footnote-backref">↩︎</a> <a href="#fnref100:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn101" class="footnote-item"><p>2015-07 Josh Clemm: A Brief History of Scaling LinkedIn <a href="https://engineering.linkedin.com/architecture/brief-history-scaling-linkedin">https://engineering.linkedin.com/architecture/brief-history-scaling-linkedin</a> <a href="https://www.slideshare.net/joshclemm/how-linkedin-scaled-a-brief-history">https://www.slideshare.net/joshclemm/how-linkedin-scaled-a-brief-history</a> <a href="#fnref101" class="footnote-backref">↩︎</a> <a href="#fnref101:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn102" class="footnote-item"><p>Aditya Auradkar, Chavdar Botev, etc.: Data Infrastructure at LinkedIn. ICDE 2012: 1370-1381，<a href="https://dblp.org/rec/conf/icde/AuradkarBDMFGGGGHKKKLNNPPQQRSSSSSSSSTTVWWZZ12.html">dblp</a>, <a href="https://www.semanticscholar.org/paper/a89f1ca0846f39e71b6b4452951f2fd19c2ae3b5">semanticscholar</a>, <a href="https://www.slideshare.net/amywtang/icde">slides</a> <a href="#fnref102" class="footnote-backref">↩︎</a> <a href="#fnref102:1" class="footnote-backref">↩︎</a> <a href="#fnref102:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn103" class="footnote-item"><p>2012-06 Sid Anand: LinkedIn Data Infrastructure Slides (Version 2) (slides) <a href="https://www.slideshare.net/r39132/linkedin-data-infrastructure-slides-version-2-13394853">https://www.slideshare.net/r39132/linkedin-data-infrastructure-slides-version-2-13394853</a> <a href="#fnref103" class="footnote-backref">↩︎</a> <a href="#fnref103:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn104" class="footnote-item"><p>2021-12 Evolving LinkedIn’s analytics tech stack <a href="https://engineering.linkedin.com/blog/2021/evolving-linkedin-s-analytics-tech-stack">https://engineering.linkedin.com/blog/2021/evolving-linkedin-s-analytics-tech-stack</a> <a href="#fnref104" class="footnote-backref">↩︎</a> <a href="#fnref104:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn105" class="footnote-item"><p>2010-05 Aditya Agarwal: Scale at Facebook (Qcon London 2010) <a href="https://www.infoq.com/presentations/Scale-at-Facebook/">https://www.infoq.com/presentations/Scale-at-Facebook/</a> <a href="#fnref105" class="footnote-backref">↩︎</a> <a href="#fnref105:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn106" class="footnote-item"><p>2008-11 Aditya Agarwal: Facebook architecture (QCon SF 2008, slides, 34p) <a href="https://www.slideshare.net/mysqlops/facebook-architecture">https://www.slideshare.net/mysqlops/facebook-architecture</a> <a href="https://www.infoq.com/presentations/Facebook-Software-Stack/">https://www.infoq.com/presentations/Facebook-Software-Stack/</a> <a href="#fnref106" class="footnote-backref">↩︎</a> <a href="#fnref106:1" class="footnote-backref">↩︎</a> <a href="#fnref106:2" class="footnote-backref">↩︎</a> <a href="#fnref106:3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn107" class="footnote-item"><p>2011-04 Michaël Figuière: What is Facebook's architecture? <a href="https://qr.ae/pKYg12">https://qr.ae/pKYg12</a> <a href="#fnref107" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn108" class="footnote-item"><p>2013-10 Where does Facebook use C++? <a href="https://qr.ae/pKCIee">https://qr.ae/pKCIee</a> <a href="#fnref108" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn109" class="footnote-item"><p>2022-07 Programming languages endorsed for server-side use at Meta <a href="https://engineering.fb.com/2022/07/27/developer-tools/programming-languages-endorsed-for-server-side-use-at-meta/">https://engineering.fb.com/2022/07/27/developer-tools/programming-languages-endorsed-for-server-side-use-at-meta/</a> <a href="#fnref109" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn110" class="footnote-item"><p>2015-07 Instagram: Search Architecture <a href="https://instagram-engineering.com/eeb34a936d3a">https://instagram-engineering.com/eeb34a936d3a</a> <a href="#fnref110" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn111" class="footnote-item"><p>Guoqiang Jerry Chen, Janet L. Wiener, etc.: Realtime Data Processing at Facebook. SIGMOD Conference 2016: 1087-1098，<a href="https://dblp.org/rec/conf/sigmod/ChenWIJLSWWWY16.html">dblp</a>, <a href="https://www.semanticscholar.org/paper/4ce25286205c62fffda7d685a916cf4508149245">semanticscholar</a> <a href="#fnref111" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn112" class="footnote-item"><p>2021-10 XStream: stream processing platform at facebook (Flink Forward Global 2021, slides) <a href="https://www.slideshare.net/aniketmokashi/xstream-stream-processing-platform-at-facebook">https://www.slideshare.net/aniketmokashi/xstream-stream-processing-platform-at-facebook</a> <a href="#fnref112" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn113" class="footnote-item"><p>2013-01 Johan Oskarsson: The Twitter stack <a href="https://blog.oskarsson.nu/post/40196324612/the-twitter-stack">https://blog.oskarsson.nu/post/40196324612/the-twitter-stack</a> <a href="#fnref113" class="footnote-backref">↩︎</a> <a href="#fnref113:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn114" class="footnote-item"><p>2013-10 Chris Aniszczyk: Evolution of The Twitter Stack (slides) <a href="https://www.slideshare.net/caniszczyk/twitter-opensourcestacklinuxcon2013">https://www.slideshare.net/caniszczyk/twitter-opensourcestacklinuxcon2013</a> <a href="#fnref114" class="footnote-backref">↩︎</a> <a href="#fnref114:1" class="footnote-backref">↩︎</a> <a href="#fnref114:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn115" class="footnote-item"><p>2017-01 The Infrastructure Behind Twitter: Scale <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2017/the-infrastructure-behind-twitter-scale">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2017/the-infrastructure-behind-twitter-scale</a> <a href="#fnref115" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn116" class="footnote-item"><p>2010-07 Cassandra at Twitter Today <a href="https://blog.twitter.com/engineering/en_us/a/2010/cassandra-at-twitter-today">https://blog.twitter.com/engineering/en_us/a/2010/cassandra-at-twitter-today</a> <a href="#fnref116" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn117" class="footnote-item"><p>2011-12 How Twitter Stores 250 Million Tweets a Day Using MySQL <a href="http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html">http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html</a> <a href="#fnref117" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn118" class="footnote-item"><p>2013-11 Michael Busch: Search at Twitter (Lucene Revolution 2013, slides) <a href="https://www.slideshare.net/lucenerevolution/twitter-search-lucenerevolutioneu2013-copy">https://www.slideshare.net/lucenerevolution/twitter-search-lucenerevolutioneu2013-copy</a> <a href="https://www.youtube.com/watch?v=AguWva8P_DI">https://www.youtube.com/watch?v=AguWva8P_DI</a> <a href="#fnref118" class="footnote-backref">↩︎</a> <a href="#fnref118:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn119" class="footnote-item"><p>2022-10 Stability and scalability for search <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2022/stability-and-scalability-for-search">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2022/stability-and-scalability-for-search</a> <a href="#fnref119" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn120" class="footnote-item"><p>2021-10 Processing billions of events in real time at Twitter <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2021/processing-billions-of-events-in-real-time-at-twitter-">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2021/processing-billions-of-events-in-real-time-at-twitter-</a> <a href="#fnref120" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>技术栈</tag>
        <tag>微服务</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>Java</tag>
        <tag>分布式</tag>
        <tag>可伸缩性</tag>
      </tags>
  </entry>
  <entry>
    <title>可靠性工程概述</title>
    <url>/2023/10/reliability-engineering/</url>
    <content><![CDATA[<p>为了应对负载的增长，目前大型网站普遍都采用分布式架构。相对于采用单体架构的系统，分布式系统中有大量的服务器及设备，各模块之间存在错综复杂的依赖关系，存在更多的不确定性。整个系统的故障率会随设备的增加而呈指数级增加，单一节点问题可能会被无限放大，日常运行过程中一定会伴随故障发生。所以，可靠性开始成为大型网站关注的最重要的质量属性之一，并因此发展出了站点可靠性工程（<a href="https://en.wikipedia.org/wiki/Site_reliability_engineering">Site reliability engineering</a>，SRE）。站点可靠性工程，是从可靠性工程发展而来的，从可靠性工程中借鉴了概念和成果。本文溯本求源，内容主要是总结概括，可靠性工程的历史演进和核心概念，软件可靠性工程的核心概念，以及可靠性设计的方法。</p>
<span id="more"></span>
<h1 id="历史演进">历史演进</h1>
<p>可靠性工程起源于第二次世界大战<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。“二战”期间，美国 60% 的机载电子设备运到远东后不能使用，50% 的电子设备在存储期间失效。经过分析，发现这些电子设备故障的主要原因是电子管的可靠性太差，为此美国在 1943 年成立电子管研究委员会，在 1952 年美国国防部成立一个由军方、工业部门及学术界组成的小组，名为“电子设备可靠性咨询小组”（AGREE，Advisory Group on the Reliability of Electronic Equipment）。1957 年 6 月，AGREE 小组出版报告《军用电子设备可靠性》（Reliability of Military Electronic Equipment），该报告是公认的可靠性工程的奠基性文件，研究报告提出一整套可靠性设计、试验和管理方法，确立了可靠性工程发展方向，标志着可靠性工程学科诞生。此后，它不断向工业和民用产品领域渗透，20 世纪 60 年代推广到核工业, 70 年代在化学工业普及，并陆续扩散到其他工程领域。</p>
<p>随着可靠性工程学科的发展演进，围绕故障展开，逐渐衍生出对产品的维修性（maintainability）、可用性（availability）、保障性（supportability）、测试性（testability）、安全性（safety）等质量特性的工程学研究。“维修性工程”和“安全性工程”是从“可靠性工程”中分离出来的，而“保障性工程”和“测试性工程”又是从“维修性工程”中独立出来的。新的 XX 性陆续分出，因为这些特性紧密相关，已经分出的 XX 性围绕可靠性又重新集成起来，在 20 世纪 80 年代呈现综合化发展趋势。可靠性的含义不断扩展，从狭义可靠性演变为广义可靠性，从狭义可靠性工程演变为广义可靠性工程。</p>
<p>1980 年代初期，为了避免因为扩展可靠性固有的含义引发的可靠性定性含义和可靠性的定量含义之间的理解混乱，Jean-Claude Laprie 选择“可信性”（dependability）作为术语，根据国际电工委员会标准，可信性的定义是，用以描述可用性及其影响因素（可靠性、维修性和维修保障性）的集合性术语，可信性仅用于非定量术语的一般描述。某些情况下，可信性还包含耐久性（durability）、安全性（safety）、安全保密性（security）等其他特性。<strong>可信性可以理解为广义可靠性</strong>。</p>
<p>当今在国际上有两个比较完整的可靠性标准化体系，一个是美国军用标准（MIL-STD），另一个是国际电工委员会（IEC）标准。美国军用标准多年来一直扮演着研究开发可靠性相关标准文件的带头角色，也是最早制定可靠性标准的。最早的可靠性定义是由美国 AGREE 在 1957 年的报告中提出的，1966 年美国的 MIL-STD-721B 又给出了传统的或经典的可靠性定义，即产品在规定的条件下和规定的时间内完成规定功能的能力。最主要的可靠性国际标准组织是国际电工委员会的 TC56 技术委员会，TC56 的发展时间线<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<ul>
<li>1965，国际电工委员会 IEC 成立名为“电子元件和设备可靠性”（Reliability of Electronic Components and Equipment）的技术委员会，即 TC56。</li>
<li>1973，TC56 更名为“可靠性与维修性”（Reliability and Maintainability）技术委员会。</li>
<li>1985，TC56 技术委员会成立了软件可靠性工作组，开始制定软件可靠性和维修性标准。</li>
<li>1989，TC56 更名为“可信性”（Dependability）技术委员会，此名称一直沿用至今。</li>
<li>1990，TC56 在与国际标准化组织（ISO）协商后，工作范围应不再局限于电工技术领域，而是解决所有学科的通用可靠性问题，从而使 IEC/TC56 成为所谓的横向委员会。</li>
</ul>
<p>我国与 IEC/TC56 对口的专业技术标准化组织是，TC24 全国电工电子产品可靠性与维修性标准化技术委员会（简称“可标委”），成立于 1982 年，挂靠在工业和信息化部电子第五研究所（又名中国电子产品可靠性与环境试验研究所）。</p>
<h1 id="可信性与质量六性">可信性与质量六性</h1>
<p>除了上文的“可信性”集合性术语外，有些资料将广义可靠性解释为，“可用性 + 可靠性 + 维修性”，这三个质量特性也被缩写为 RAM。RAM 有时候会再加上安全性（Safety），被缩写为 <a href="https://en.wikipedia.org/wiki/RAMS">RAMS</a>。使用 RAMS 缩写的典型例子是国际电工委员会的 <a href="https://webstore.iec.ch/publication/6747">IEC 62278:2002</a> 标准（等同的国家标准 <a href="https://std.samr.gov.cn/gb/search/gbDetailed?id=71F772D76DCCD3A7E05397BE0A0AB82A">GB/T 21562-2008</a>）。</p>
<p>另外，常见的可靠性相关的缩写是 RMS 和 RMTSS。RMS 代表可靠性、维修性、保障性，或称“三性”。RMTSS 代表可靠性、维修性、测试性、保障性、安全性，或称“五性”。质量“三性”或“五性”，也是我国军用武器装备的军用标准要求的通用质量特性。我国武器装备的军用标准学习和借鉴的是美国军用标准，军用装备的质量特性分为专用质量特性和通用质量特性。专用质量特性，反映的是不同系统或者装备自身的特点和个性特征，主要指的是功能和性能，如某型飞机的最大（最小）飞行速度、巡航速度、飞行高度等指标。通用质量特性，则表征不同装备的共性特征。通用质量特性是逐渐演变的，从一开始的“二性”演变为“六性”<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，通用质量特性包含的特性如下：</p>
<ul>
<li>二性：可靠性、维修性（也缩写为 R&amp;M）</li>
<li>三性：可靠性、维修性、保障性（也缩写为 RMS）</li>
<li>五性：可靠性、维修性、测试性、保障性、安全性（也缩写为 RMTSS）</li>
<li>六性：可靠性、维修性、保障性、测试性、安全性、环境适应性</li>
</ul>
<p><strong>通用质量特性与可信性的含义大体上相同</strong>。质量特性、可信性、可靠性的关系，如下图所示：</p>
<img width="700" alt="质量特性、可信性、可靠性的关系" title="质量特性、可信性、可靠性的关系" src="https://static.nullwy.me/quality-characteristics-classification.png">
<p>根据国际电工委员会 IEC 60050 (191):1990（等同的国家标准 GB/T 3187-1994 《可靠性、维修性术语》）、IEC 60050-192:2015（等同于 GB/T 2900.99-2016 《电工术语 可信性》）以及国家军用标准 GJB 451A-2005 《可靠性维修性保障性术语》（与美国军用标准 <a href="http://everyspec.com/MIL-STD/MIL-STD-0700-0799/MIL-STD-721C_1040/">MIL-STD-721C</a> 相似）等标准文档，相关特性的定义和度量指标如下：</p>
<ul>
<li><strong>可信性（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-01-22">dependability</a>）</strong>：用以描述可用性及其影响因索（可靠性、维修性和维修保障性）的集合性术语。可信性仅用于非定量术语的一般描述。</li>
<li><strong>可靠性（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-01-24">reliability</a>）</strong>：在给定的条件，给定的时间区间，能无故障地执行要求的能力。可靠性一般用可靠度（reliability）、平均故障间隔时间（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-05-13">MTBF</a>）、使用寿命（useful life）等参数来度量。</li>
<li><strong>可用性（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-01-23">availability</a>）</strong>：在所要求的外部资源得到提供的情况下，产品在给定的条件下，在给定的时刻或时间区间内处于能完成要求的功能的状态的能力。此能力是产品的可靠性、维修性和维修保障性的综合反映。可用性的度量指标称为可用度（availability），表示为平均可用时间同平均可用时间与平均不可用时间的和之比。</li>
<li><strong>维修性（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-01-27">maintainability</a>）</strong>：在给定的条件下，使用所述的程序和资源实施维修时，产品在给定的使用条件下保持或恢复能完成要求的功能的状态的能力。维修性反映产品修理的难易程度，主要使用平均修复时间（MTTR）来度量。</li>
<li><strong>保障性（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-01-31">supportability</a>）</strong>：在规定的运行剖面和给定的后勤与维修资源下，保防能维待要求的可用性的能力。维修保障（maintenance support），是维修产品的资源的供给，资源包括人力资源、保障设备、材料和备件、维修设施、文档和信息以及维修信息系统。保障性一般用平均保障延误时间、资源满足率、资源利用率等参数来度量。</li>
<li><strong>测试性（testability）</strong>：是指产品能及时并准确地确定其状态（可工作、不可工作或性能下降），并隔离其内部故障的能力。测试性反映产品是否易于测试、出现故障时是否易于检测和隔离，一般用检测时间、技术准备时间、故障检测率、故障隔离率等参数来度量。</li>
<li><strong>安全性（safety）</strong>：是指产品所具有的不导致人员伤亡、系统毁坏、重大财产损失或不危及人员健康和环境的能力。安全性可理解为产品在任何情况下对人员、系统、财产和环境都不构成安全威胁。它可定义为产品在规定的条件下和规定的时间内，以可接受的风险执行规定功能的能力。安全性一般用事故概率、损失率、安全可靠度等参数来度量。</li>
<li><strong>环境适应性（environmental worthiness）</strong>：是指产品在其寿命期内预计可能遇到的各种环境作用下能实现其所有预定功能、性能和（或）不被破坏的能力。它反映了产品对各种环境的适应能力，即在其可能遇到的各种环境下均能正常工作的能力，是可靠性的一种特殊情况。环境适应性鉴定试验通过的判定准则是，在所有试验条件下“零故障”。</li>
</ul>
<p><strong>通用质量特性的“六性”之间是紧密联系的</strong><sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：</p>
<ul>
<li>维修性是对可靠性的补充，如果产品不发生故障就不需要修复性维修。</li>
<li>可用性是产品的可靠性、维修性和维修保障性的综合反映。</li>
<li>保障性为产品正常使用与维修提供外部资源的支持，提供使用保障和维修保障，可靠性和维修性依赖于保障性。</li>
<li>测试性是维修性的基础，维修依赖于测试，产品要修理一定要先发现故障和隔离故障，所以测试性设计得好，维修时间就可大大缩短。</li>
<li>安全性本是可靠性的一部分，是避免人员伤亡、健康损害、财产或环境损害风险的可靠性。可靠性是安全性的基础，很多安全性问题都是因为产品不可靠造成的，所以提高产品可靠性也能提高安全性，当然并非所有安全性问题都是不可靠引起的。</li>
<li>环境适应性是可靠性的一种特殊情况，是可靠性研究的前提，研究可靠性首先要确定产品是否有足够的环境适应性。</li>
</ul>
<p>通用质量特性的“六性”工作围绕故障（failure）而展开，也被人称为“故障六性”<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4:2">[4:2]</a></sup>。可靠性的目标是减少故障；维修性的目标是修复故障；测试性的目标是检测故障；保障性保证出现故障时可以快速供应维修资源；安全性旨在出现故障以后降低风险；环境适应性鉴定试验通过的判定准则是，在所有试验条件下“零故障”<sup class="footnote-ref"><a href="#fn5" id="fnref5:1">[5:1]</a></sup>。</p>
<img width="450" alt="故障六性" title="故障六性" src="https://static.nullwy.me/quality-6-characteristics.png">
<p>可靠性是产品质量特性之一，是一种面向时间的质量特性（time oriented quality characteristic）<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。Lloyd Condra 在<a href="https://www.amazon.com/dp/B00SC8DKDG">书中</a>对可靠性和质量的关系的解释是，“可靠性是质量随着时间的变化（reliability is quality over time）”，“为了衡量产品的质量水平，我们对现在的产品进行评判，而为了度量产品的可靠性水平，则要对产品未来会是什么样子进行评判”。这里的讨论的质量其实指的是符合性质量，质量管理一开始是从符合性质量开始的，质量管理的主要工作是质量检验（Quality Inspection），检测产品是否符合规格，质量检验的结果即合格品率。质量管理的关注焦点是产品的合格品率，而可靠性关注焦点是产品在用户使用过程中合格水平随着时间的保持能力，如下图所示 <sup class="footnote-ref"><a href="#fn5" id="fnref5:2">[5:2]</a></sup>：</p>
<img width="600" alt="质量与可靠性关系示意图" title="质量与可靠性关系示意图" src="https://static.nullwy.me/quality-vs-reliability.png">
<h1 id="故障与失效的区别">故障与失效的区别</h1>
<p>可靠性工程中有两个基本而重要的术语“fault”和“failure”。在我国的可靠性标准文档中，把“fault”翻译为“故障”，把“failure”翻译为“失效”或“故障”，也就是说，“失效”对应的英文只有“failure”；而“故障”对应的英文是“fault”或“failure”<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>。</p>
<p>我国第一个定义可靠性相关的常用术语的国家标准是 GB 3187-1982 《可靠性基本名词术语及定义》，该标准对英文术语“failure”的中文翻译是“失效”或“故障”，并把“mean time between failures”翻译是“平均无故障时间”：<sup class="footnote-ref"><a href="#fn8" id="fnref8:1">[8:1]</a></sup></p>
<blockquote>
<p>2.2.1 失效（故障） failure：产品丧失规定的功能。对可修复产品通常也称故障。<br>
2.5.5 平均寿命（平均无故障时间） mean life (mean time between failures)：寿命（无故障时间）的平均值。</p>
</blockquote>
<p>替代 GB 3187-1982 的新国家标准是 <a href="https://std.samr.gov.cn/gb/search/gbDetailed?id=71F772D7962ED3A7E05397BE0A0AB82A">GB/T 3187-1994</a> 《可靠性、维修性术语》（等同于 IEC 60050-191:1991），该标准把“failure”仅翻译为“失效”，不再又称“故障”。完整的术语定义如下：</p>
<blockquote>
<p>4.1.1 失效 failure<br>
产品终止完成规定功能的能力这样的事件。<br>
4.2.1 故障 fault<br>
产品不能执行规定功能的状态。预防性维修或共他计划性活动或缺乏外部资源的情况除外。故障通常是产品本身失效后的状态，但也可能在失效前就存在。</p>
</blockquote>
<p>基于上述的定义，对于性能随时间逐渐退化的产品，故障（fault）与失效（failure）的区别，如下图所示<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>：</p>
<img width="600" alt="故障（fault）与失效（failure）的区别" title="故障（fault）与失效（failure）的区别" src="https://static.nullwy.me/reliability-fault-vs-failure.png">
<p>国外历来都是将“fault”和“failure”的定义加以区分的，我国新的标准文档也区分翻译为“故障”和“失效”，但是实际上在我国的电工行业中的惯用情况是把“fault”和“failure”都翻译为“故障”，很多书籍资料也不严格区分。比如，中国质量协会的《可靠性工程师手册》（第 2 版 2017<sup class="footnote-ref"><a href="#fn5" id="fnref5:3">[5:3]</a></sup>)，不严格区分“故障”与“失效”术语，统一都使用“故障”，书中的解释如下：</p>
<blockquote>
<p>在我国的可靠性工程应用中，一般不对故障与失效进行严格的区分，如失效树分析也称为故障树分析，故障模式、影响分析也称为失效模式、影响分析。因此本书也不做严格区分，多数情况下故障一词也可用失效代替。</p>
</blockquote>
<p>一般而言，故障是产品本身失效后的状态，此时产品处于故障状态，这时故障和失效是不需要严格加以区分。对无故障容忍能力的产品而言，故障即失效。然而，对有故障容忍能力的产品，产品可以出故障，但不会失效，这时我们就必须区分失效和故障的概念<sup class="footnote-ref"><a href="#fn9" id="fnref9:1">[9:1]</a></sup>。故障容忍（容错，<a href="https://en.wikipedia.org/wiki/Fault_tolerance">fault tolerance</a>），是在某些故障出现时继续运行的能力，只有当所有冗余的硬件同时有故障时，产品才失效。</p>
<h1 id="可靠性的度量">可靠性的度量</h1>
<p>可靠性的度量指标是<strong>可靠度</strong>（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-05-05">reliability</a>），根据国际电工委员会的标准文档，可靠度的定义是：在给定的条件下在时间区间 (t1, t2) 内按要求执行的概率。当 t1=0 和 t2=t，则 R(0,t) 可简化为 R(t)，并称为产品的<strong>可靠度函数</strong>（reliability function）。</p>
<p>若在 t=0 时产品的总数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">N_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，在 0 ~ t 的时间内累计的故障数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_f(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，正常的产品数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_s(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，则有：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>0</mn></msub><mo>=</mo><msub><mi>N</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_0 = N_f(t) + N_s(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></p>
<p>产品在 t 时刻的可靠度的估计值为：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mo>^</mo></mover><mo>=</mo><mfrac><mrow><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><msub><mi>N</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">\hat{R(t)}=\frac{N_s(t)}{N_0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2634em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0134em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4551em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>显然，当 t=0 时，R(0) = 1，当 t=∞ 时，R(∞) = 0。</p>
<p>可靠度的反面是<strong>不可靠度</strong>（unreliability），含义是：在规定的条件下，在规定的时间内，不能完成规定功能的概率。<strong>不可靠度函数</strong>通常记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，不可靠度的估计值的计算公式为：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mo>^</mo></mover><mo>=</mo><mfrac><mrow><msub><mi>N</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><msub><mi>N</mi><mn>0</mn></msub></mfrac><mo>=</mo><mfrac><mrow><msub><mi>N</mi><mn>0</mn></msub><mo>−</mo><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><msub><mi>N</mi><mn>0</mn></msub></mfrac><mo>=</mo><mn>1</mn><mo>−</mo><mover accent="true"><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{F(t)} = \frac{N_f(t)}{N_0} = \frac{N_0 - N_s(t)}{N_0} = 1 - \hat{R(t)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2634em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0134em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4832em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0381em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5131em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4551em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2634em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0134em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span></span></span></p>
<p><strong>示例</strong>：假设在 t=0，投入工作的 10000 只灯泡，以天作为度量时间的单位，在 t= 365 天时，发现有 300 只灯泡坏了，这时的可靠度和不可靠度的计算如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>R</mi><mo stretchy="false">(</mo><mn>365</mn><mo stretchy="false">)</mo></mrow><mo>^</mo></mover><mo>=</mo><mfrac><mrow><mn>1000</mn><mo>−</mo><mn>300</mn></mrow><mn>1000</mn></mfrac><mo>=</mo><mn>0.97</mn></mrow><annotation encoding="application/x-tex">\hat{R(365)} = \frac{1000 - 300}{1000} = 0.97</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2634em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0134em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord">365</span><span class="mclose">)</span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span><span class="mbin mtight">−</span><span class="mord mtight">300</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.97</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>365</mn><mo stretchy="false">)</mo></mrow><mo>^</mo></mover><mo>=</mo><mfrac><mn>300</mn><mn>1000</mn></mfrac><mo>=</mo><mn>0.03</mn></mrow><annotation encoding="application/x-tex">\hat{F(365)} = \frac{300}{1000} = 0.03</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2634em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0134em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">365</span><span class="mclose">)</span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">300</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.03</span></span></span></span></p>
<p>对不可靠度函数求导，其导数称为<strong>故障概率密度函数</strong>，通常记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">f(t) = \lim_{\Delta t \to 0} \frac{F(t + \Delta t) - F(t)} {\Delta t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>某时刻尚未发生故障的产品，在该时刻后单位时间内发生故障的概率，称为产品的<strong>故障率</strong>（<a href="https://en.wikipedia.org/wiki/Failure_rate">failure rate</a>），记为记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">λ(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>。故障率的计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mo>^</mo></mover><mo>=</mo><mfrac><mrow><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mtext>间隔时间内的故障数</mtext><mrow><mtext>间隔起点的存活数</mtext><mo>×</mo><mtext>时间间隔</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat{λ(t)} = \frac{N_s(t) - N_s(t + \Delta t)} {N_s(t) \Delta t} = \frac{间隔时间内的故障数}{间隔起点的存活数 × 时间间隔}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2634em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0134em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2757em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">间隔起点的存活数</span><span class="mbin mtight">×</span><span class="mord cjk_fallback mtight">时间间隔</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">间隔时间内的故障数</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>→</mo><mn>0</mn></mrow></msub><mfrac><mrow><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><msub><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">λ(t) = \lim_{\Delta t \to 0} \frac{N_s(t) - N_s(t + \Delta t)} {N_s(t) \Delta t} = \lim_{\Delta t \to 0} \frac{F(t + \Delta t) - F(t)}{R(t)\Delta t} = \frac{f(t)}{R(t)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>在长期的可靠性实践中，人们发现许多产品的故障率随时间的变化曲线形似浴盆，所以习惯性的将故障率曲线称为“浴盆曲线”（<a href="https://en.wikipedia.org/wiki/Bathtub_curve">bathtub curve</a>），如下图所示<sup class="footnote-ref"><a href="#fn5" id="fnref5:4">[5:4]</a></sup>。大多数电子产品的故障率曲线的形状就是浴盆曲线。</p>
<img width="600" alt="产品典型的故障率曲线" title="产品典型的故障率曲线" src="https://static.nullwy.me/reliability-bathtub-curve.png">
<p>故障率随时间的变化大致可以分为以下三个阶段：早期故障期（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-02-28">early failure period</a>）、偶然故障期（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-02-30">random failure period</a>）、耗损故障期（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-02-31">wear-out failure period</a>）。三个阶段有时也被称为：早夭期（infant mortality period）、使用寿命期（useful life period）和耗损期（wear-out period）。故障率曲线与人类的死亡率曲线相似，曲线的三个阶段分别对应人类生命周期的婴幼儿时期、壮年期以及老年期。在偶然故障期，产品的故障率可降到一个较低的水平，且基本处于平稳状态，可以近似认为故障率为常数。</p>
<p>如果产品的故障率为常数，那么其故障的概率分布可以用指数分布（<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83">exponential distribution</a>）描述，指数分布是唯一具有恒定故障率的连续概率分布。恒定故障率的特性也被称为“无记忆性”（<a href="https://en.wikipedia.org/wiki/Memorylessness">memorylessness</a>），该特性说明故障率在任何时刻都与系统已工作过的时间长短没有关系。服从指数分布的概率密度函数为：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi><msup><mi>e</mi><mrow><mo>−</mo><mi>λ</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f(t) = {\lambda} e^{-\lambda t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">λ</span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">λ</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>服从指数分布的可靠度函数、不可靠度函数和故障率函数依次为：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>λ</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R(t) = e^{-\lambda t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">λ</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>λ</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">F(t) = 1 - e^{-\lambda t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">λ</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda(t) = \lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></p>
<p>公式中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span>为常数。</p>
<p>上面提到的这些指标是概率相关的度量指标。另外，还有一些是时间相关的度量指标：</p>
<ul>
<li><strong>平均故障间隔时间</strong>（MTBF，mean time between failures）：相邻两次故障间的持续时间的平均值。失效间隔时间（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-05-03">time between failures</a>）包括可用时间和不可用时间。MTBF 只能用于可修复产品。</li>
<li><strong>平均故障间隔工作时间</strong>（MTBF /<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-05-13">MOTBF</a>，mean operating time between failures）：相邻两次故障间的累计工作时间的平均值。MOTBF 只能用于可修复产品，该值也被成为可修复产品的平均寿命（mean life）。</li>
<li><strong>平均故障前工作时间</strong>（<a href="">MTTF</a>，mean operating time to failure）：故障前工作时间的平均值。等同于，平均失效前时间（MTTF，mean time to failure）。MTTF 可以用于不可修复产品和可修复产品。MTTF 值也被成为不可修复产品的平均寿命（mean life）。</li>
<li><strong>平均恢复时间</strong>（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-07-23">MTTR</a>，mean time to restoration）：恢复时间的平均值。最新的国际电工委员会 IEV 标准文档，废弃了平均恢复时间（mean time to recovery）和平均修理时间（mean time to repair）。平均恢复时间是维修性的主要度量指标。</li>
<li><strong>可用性</strong>（<a href="https://en.wikipedia.org/wiki/Availability">availability</a>）：或者翻译为“可用度”，可以表示为平均可用时间除以平均可用时间与平均不可用时间之和。可用性是反映可靠性和维修的综合性指标。</li>
</ul>
<p>根据国际电工委员会标准文档 IEC 60050-192:2015（等同的国家标准文档是 <a href="https://std.samr.gov.cn/gb/search/gbDetailed?id=71F772D81729D3A7E05397BE0A0AB82A">GB/T 2900.99-2016</a>《电工术语 可信性》），MTBF 和 <a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-05-13">MOTBF</a> 缩写代表的都是<strong>平均故障间隔工作时间</strong>（mean operating time between failures），统计的值是<strong>故障间隔工作时间</strong>（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-05-04">operating time between failures</a>），即相邻两次故障间的累计工作时间；而<strong>故障间隔时间</strong>（<a href="https://www.electropedia.org/iev/iev.nsf/display?openform&amp;ievref=192-05-03">time between failures</a>），包括可用时间和不可用时间。所以，<strong>平均故障间隔时间</strong>和<strong>平均故障间隔工作时间</strong>的含义是不同的，前者同时统计包括工作时间（operating time）和非工作时间（non-operating time），而后者只统计工作时间（operating time）。但是在很多其他文档中，比如维基百科的词条“平均故障间隔时间”（<a href="https://en.wikipedia.org/wiki/Mean_time_between_failures">Mean time between failures</a>）词条，“平均失效间隔时间”的缩写也是 MTBF。<strong>也就说， MTBF 即是“平均故障间隔时间”的缩写，也是“平均故障间隔工作时间”的缩写，但两者含义却不同，需要读者自行辨别</strong>。本文使用 MTBF，统一都表示“平均故障间隔时间”。</p>
<p><strong>MTBF 只能用于可修复产品，MTTF 用于不可修复产品和可修复产品</strong>。对于不可修复产品，MTTF 等同于 MTBF，对于可修复产品，MTTF 等同于 MOTBF。MTBF 是 MTTR 和 MTTF 的总和，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>B</mi><mi>F</mi><mo>=</mo><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi><mo>+</mo><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">MTBF = MTTR + MTTF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MTBF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">MTTR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MTTF</span></span></span></span>。</p>
<p>产品的<strong>平均寿命</strong>（mean life）的理论值为故障概率密度函数的<a href="https://zh.wikipedia.org/wiki/%E6%9C%9F%E6%9C%9B%E5%80%BC">期望值</a>，记为 θ。该期望值也是可修复产品的 MOTBF 的理论值，是不可修复产品的 MTTF 的理论值。平均寿命或 MTTF 的计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>=</mo><mi>θ</mi><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><mi>t</mi><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">MTTF = θ = E(T) = \int_{0}^\infty t f(t)\,\mathrm{d}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MTTF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2151em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8593em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span></span></span></span></p>
<p>如果概率密度函数服从指数分布，那么平均寿命或 MTTF 值为：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>=</mo><mi>θ</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>λ</mi></mrow><annotation encoding="application/x-tex">MTTF = θ = 1/\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MTTF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal">λ</span></span></span></span></p>
<p>对于服从指数分布的产品，当产品工作时间到达平均寿命时，可靠度的值 36.8%：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>36.8</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">R(θ) = e^{-1} = 36.8\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">36.8%</span></span></span></span></p>
<p>假设某可修复产品的正常工作时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><msub><mrow><mi>T</mi><mi>F</mi><mi>F</mi></mrow><mn>1</mn></msub><mo separator="true">,</mo><msub><mrow><mi>T</mi><mi>F</mi><mi>F</mi></mrow><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mrow><mi>T</mi><mi>F</mi><mi>F</mi></mrow><mi>n</mi></msub><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{ {TFF}_1, {TFF}_2 ...,  {TFF}_n \right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">TFF</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">TFF</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">TFF</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>，故障时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><msub><mrow><mi>T</mi><mi>T</mi><mi>R</mi></mrow><mn>1</mn></msub><mo separator="true">,</mo><msub><mrow><mi>T</mi><mi>T</mi><mi>R</mi></mrow><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mrow><mi>T</mi><mi>T</mi><mi>R</mi></mrow><mi>n</mi></msub><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{ {TTR}_1, {TTR}_2 ..., {TTR}_n \right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">TTR</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">TTR</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">TTR</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>，如下图所示：</p>
<img width="600" alt="MTBF、MTTF 和 MTTR 示意图" title="MTBF、MTTF 和 MTTR 示意图" src="https://static.nullwy.me/reliability-mtbf-mttf-mttr.png">
<p>MTBF、MTTF、MTTR 和可用性（availability）的估计值的计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>B</mi><mi>F</mi><mo>=</mo><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mrow><mi>T</mi><mi>B</mi><mi>F</mi></mrow><mi>i</mi></msub></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mtext>total uptime + total downtime</mtext><mtext>total number of failures</mtext></mfrac></mrow><annotation encoding="application/x-tex">MTBF = \frac{\sum_{i=1}^n {TBF}_i}{n} = \frac{\text{total uptime + total downtime}}{\text{total number of failures}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MTBF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.405em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.06em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.535em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">TBF</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total number of failures</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total uptime + total downtime</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>=</mo><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mrow><mi>T</mi><mi>T</mi><mi>F</mi></mrow><mi>i</mi></msub></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mtext>total uptime</mtext><mtext>total number of failures</mtext></mfrac></mrow><annotation encoding="application/x-tex">MTTF = \frac{\sum_{i=1}^n {TTF}_i}{n} = \frac{\text{total uptime}}{\text{total number of failures}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MTTF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.405em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.06em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.535em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">TTF</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total number of failures</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total uptime</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi><mo>=</mo><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mrow><mi>T</mi><mi>T</mi><mi>R</mi></mrow><mi>i</mi></msub></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mtext>total downtime</mtext><mtext>total number of failures</mtext></mfrac></mrow><annotation encoding="application/x-tex">MTTR = \frac{\sum_{i=1}^n {TTR}_i}{n} = \frac{\text{total downtime}}{\text{total number of failures}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">MTTR</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.405em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.06em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.535em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">TTR</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total number of failures</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total downtime</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>可用性</mtext><mo>=</mo><mfrac><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi></mrow><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>+</mo><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi></mrow><mrow><mi>M</mi><mi>T</mi><mi>B</mi><mi>F</mi></mrow></mfrac><mo>=</mo><mfrac><mtext>total uptime</mtext><mrow><mtext>total uptime</mtext><mo>+</mo><mtext>total downtime</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">可用性 = \frac {MTTF} {MTTF + MTTR} = \frac {MTTF} {MTBF} = \frac{\text{total uptime}}{\text{total uptime} + \text{total downtime}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">可用性</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2757em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">MTTF</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">MTTR</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">MTTF</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">MTBF</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">MTTF</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4133em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total uptime</span></span><span class="mbin mtight">+</span><span class="mord text mtight"><span class="mord mtight">total downtime</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total uptime</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>对于电子设备，MTBF 近似常量，比如，典型的企业级固态硬盘 SSD 的 MTBF 值可能是 200 万小时<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>，也就是 228 年，年故障率 AFR（<a href="https://en.wikipedia.org/wiki/Annualized_failure_rate">Annualized Failure Rate</a>） 为 0.44%（1/228）。</p>
<p>可以利用数学和统计方法对可靠性进行预计和度量，并分析可靠性数据。但是可靠性的量化涉及大量不确定性，由于可靠性经常关系到制造和使用产品的人，人的行为和表现不像植物对肥料的反应、气象模型对海洋温度的反应那样服从于数学分析和预测，而且产品可能在大范围变化的环境中工作，因此还会有其他不确定性因素被引入。数学和统计方法虽然在适当的场合是非常有价值的，但是由于涉及大量不确定性，在实际的可靠性工程中的作用有限，在实际的工程实践中优先需要确定的是故障的原因和解决方案<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>。</p>
<h1 id="软件可靠性工程">软件可靠性工程</h1>
<p>软件可靠性工程是从硬件可靠性工程发展而来的<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>。在软件工程学建立初期，一些软件工程专家利用和改造硬件可靠性工程学的成果，使之移植到软件领域，从而开创了软件可靠性学科。</p>
<p>类似的，起源于 Google 的“站点可靠性工程”（SRE, <a href="https://en.wikipedia.org/wiki/Site_reliability_engineering">Site reliability engineering</a>）也源自可靠性工程，区别是站点可靠性工程关注的是大型网站和网络服务这样的软件系统 <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup><sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>。</p>
<h2 id="术语与概念">术语与概念</h2>
<p>国家标准 <a href="https://std.samr.gov.cn/gb/search/gbDetailed?id=71F772D7805FD3A7E05397BE0A0AB82A">GB/T 11457-2006</a> 《信息技术 软件工程术语》，对软件可靠性的定义如下：</p>
<blockquote>
<p>2.1662 系统可靠性 system reliability<br>
包括全部硬件和软件子系统在内的某个系统，在规定的环境及时间里正确执行所要求的任务或使命的概率。<br>
2.1528 软件可靠性 software reliability<br>
a) 在规定条件下，在规定的时间内，软件不引起系统失效的概率。该概率是系统输人和系统使用的函数，也是软件中存在的缺陷的函数。系统输人将确定是否会遇到已存在的缺陷（如果有缺陷存在的话）。<br>
b) 在规定的时间周期内所述条件下程序执行所需要的功能的能力。</p>
</blockquote>
<p>GB/T 11457-2006 吸收了 <a href="https://standards.ieee.org/ieee/610.12/855/">IEEE Std 610.12-1990</a> 全部术语，包括术语“软件可靠性”，国标的术语定义只是对 IEEE 术语定义的中文翻译。IEEE 最早在标准文档中定义“软件可靠性”是在 <a href="https://standards.ieee.org/ieee/729/967/">IEEE Std 729-1983</a>，这个标准之后被 IEEE Std 610.12-1990 替代。</p>
<p>IEEE 对“软件可靠性”术语给出两个定义，定义 a) 是定量的定义，也就是“可靠度”，定义 b) 是定性的定义。对比后容易发现，硬件可靠性和软件可靠性的定义是相同的。这种相容性，使这种可靠性定义能够用于既包括软件又包括硬件的系统。</p>
<p>故障相关的术语，国家标准 GB/T 11457-2006 《信息技术 软件工程术语》的定义是：</p>
<blockquote>
<p><strong>2.163 隐错 bug</strong><br>
见：出错 error(2.561) 和故障 fault(2.609)。<br>
<strong>2.421 缺陷 defect</strong><br>
见：故障 fault(2.609)。<br>
<strong>2.561 出错, 误差, 差错 error</strong><br>
a) 计算的、观察的或测量的值或条件与实际的、规定的或理论上正确的值或条件的差别。例如，在计算的结果和正确的结果之间差30m；<br>
b) 不正确的步骤、过程或数据定义。例如，在计算机程序中的不正确的指定；<br>
c) 不正确的结果。例如，当正确的结果是10，而计算的结果是12；<br>
d) 产生不正确结果的人为动作。例如，在编程或操作的一部分上的不正确动作。<br>
注：当上述所有四种定义是公共使用时，一种区分赋给定义 a) 为字差错（error），定义 b) 为字过错（fault），定义 c) 为字失效（failure）和定义 d) 为字错误（mistake）。<br>
<strong>2.601 失效 failure</strong><br>
系统或部件不能按规定的性能要求执行它所要求的功能。注：故障容忍在人们的动作（弄错-mistake）、它的显示（硬件或软件故障 fault）、故障的结果（失效 failure）和不正确（差错－error）结果的总数之间进行区分<br>
<strong>2.609 故障, 缺陷 fault</strong><br>
a) 硬件设备或部件中的缺陷。例如，短路或断线。<br>
b) 在计算机程序中不正确的步骤、过程或数据定义。注：此定义最初由容错（fault tolerance）系统使用。在通常用法中，术语“差错（error）”和“隐错（bug）”表示同样含义。</p>
</blockquote>
<p>基于 IEEE 的定义，容易发现术语“fault、“<a href="https://en.wikipedia.org/wiki/Software_bug">bug</a>”和“defect”是同义词，术语“error”同时具有“mistake”、“fault”和“failure”的含义。这些术语之间的因果关系是，开发者在软件开发过程中产生人为失误（mistake），导致在软件中存在缺陷（fault, bug, defect），在软件运行时如果用户遭遇缺陷（fault, bug, defect），会引发失效（failure），如下图所示：</p>
<img width="600" alt="软件故障的因果关系" title="软件故障的因果关系" src="https://static.nullwy.me/reliability-software-failure-cause.png">
<p>失效（failure）是指系统或部件在特定约束下不能完成所要求的功能，用户在测试或实际使用中会观察到失效（failure）。<strong>失效（failure）是系统运行行为对用户要求的偏离，是一种面向用户的概念。故障（fault）是在系统运行时引起或可能潜在地引起失效（failure）的缺陷（defect），是一种面向开发者的概念。</strong></p>
<h2 id="可靠性的度量-v2">可靠性的度量</h2>
<p>早期的软件可靠性度量工作试图将硬件可靠性理论中的数学公式外推来进行软件可靠性的预测。大多数与硬件相关的可靠性模型依据的是由于“磨损”而导致的故障，而不是由于设计缺陷而导致的故障。在硬件中，由于物理磨损（如温度、腐蚀、振动的影响）导致的故障远比与设计缺陷有关的故障多。不幸的是，软件恰好相反。实际上，所有软件故障都可以追溯到设计或实现问题，磨损根本没有影响<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>。</p>
<p>软件系统的故障主要是人为差错造成，涉及大量不确定性，利用数学和统计方法对可靠性进行预计和度量，在实际的工程实践中的作用有限。少数常用的与可靠性相关的度量指标是：MTBF、MTTR 和可用性。</p>
<p>MTBF 指标衡量的是系统无故障运行的能力，也就是可靠性。MTTR 指标衡量的是系统快速从故障中恢复的能力，这种能力在硬件产品下被称为“维修性”（maintainability），但在软件系统下通常为称“韧性”（resilience）。术语“maintainability”，在硬件上下文中通常被翻译为“维修性”，而在软件上下文中通常被翻译为“维护性”或“可维护性”，软件可维护性指的是软件可被修改的能力，修改可能包括修复缺陷、增加或完善功能等。</p>
<p>MTBF 反映的是硬件产品的寿命，是硬件产品质量的最重要的指标之一。与硬件不同，软件的 MTBF 不可控，而故障恢复的工作流程清晰，可干预程度高，研发团队可以对各环节展开精细化管理，轻松、高效地达成 MTTR 优化目标，所以软件系统的 <strong>MTTR 相对 MTBF 更加重要</strong><sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>。</p>
<p>可用性是衡量可靠性和韧性的综合性指标。想要提高系统的可用性，需要做的是延长无故障时间（MTTF）和缩短故障恢复时间（MTTR）。</p>
<h1 id="可靠性设计">可靠性设计</h1>
<p>Laprie 等人把提高系统可靠性的方法总结为<a href="https://en.wikipedia.org/wiki/Dependability#Means">四种</a>：</p>
<ul>
<li><strong>故障避免（fault avoidonce，简称“避错”）</strong>：在系统的设计和实现过程中使用一些开发方法来减少故障发生，并在系统投入使用之前发现系统中的故障。</li>
<li><strong>故障排除（fault removal，简称“排错”）</strong>：故障排除可以细分为两个子类别：开发期间的排除和使用期间的排除。在系统使用之前通过<a href="https://zh.wikipedia.org/wiki/%E9%A9%97%E8%AD%89%E5%8F%8A%E7%A2%BA%E8%AA%8D">验证和确认</a>（V&amp;V）来发现和去除系统中的故障；如果系统已经投入使用，通过维护周期将其消除。</li>
<li><strong>故障容忍（<a href="https://en.wikipedia.org/wiki/Fault_tolerance">fault tolerance</a>，简称“容错”）</strong>：容错是使系统在其某些组件中出现一个或多个故障时能够继续提供服务的能力，尽管该服务可能处于降级级别。容错技术主要是采用<strong>冗余</strong>（<a href="https://en.wikipedia.org/wiki/Redundancy_(engineering)">redundancy</a>）方法来消除故障的影响，冗余的含义是指当系统无故障时取消冗余资源不会影响系统正常运行。</li>
<li><strong>故障预报（fault forecasting）</strong>：通过收集故障数据，建立可靠性建模，预测可能的故障。</li>
</ul>
<p>针对软件可靠性设计，软件故障避免技术，包括采用优秀的软件设计方法、使用强类型的程序设计语言、全面的编译器检查等；软件故障排除技术，主要是代码评审和软件测试；故障预报，能提高硬件可靠性，但是很少应用于软件可靠性。</p>
<p>系统的资源包括硬件资源、软件资源、信息资源、时间资源，所以冗余区分 4 种方式：</p>
<ul>
<li><strong>硬件冗余</strong>（hardware redundancy）：通过配置额外的硬件组件实现冗余。</li>
<li><strong>软件冗余</strong>（software redundancy）：通过配置额外的软件版本实现冗余，例如 N 版本编程（<a href="https://en.wikipedia.org/wiki/N-version_programming">NVP</a>）。</li>
<li><strong>信息冗余</strong>（information redundancy）：通过对信息中外加一部分信息码或将信息存放在多个内存单元或将信息进行备份等实现冗余，例如循环冗余校验码、数据库备份等。</li>
<li><strong>时间冗余</strong>（time redundancy）：多次执行相同的操作（重试）实现冗余，例如多次执行程序或传输数据的多个副本。</li>
</ul>
<p>硬件冗余和软件冗余被合称为结构冗余（structural redundancy）。相对与时间冗余，硬件冗余、软件冗余、信息冗余被合称为空间冗余（space redundancy）。硬件冗余比较常见，而软件冗余相对少见。</p>
<p>在工程领域，利用冗余提高可靠性的例子很多，比如汽车的备胎、大货车的多个轮子、飞机的四台发动机或双台发动机、火箭的多台引擎和多台计算机等。《像火箭科学家一样思考》书中的“为什么冗余不是多余的”小节<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>中有这样一段阐述：</p>
<blockquote>
<p>航天器上的计算机也使用冗余装置。在地球上，电脑往往免不了崩溃或死机，而在有压力的太空环境中，计算机发生故障的概率有增无减，因为计算机在太空中要经历无数振动、冲击、变化的电流和波动的温度。正因为如此，航天飞机的计算机是4倍冗余的，即飞机上有4台计算机在运行着同样的软件。这4台计算机会通过一个多数投票系统就下一步动作进行单独投票。如果其中一台计算机发生故障，开始乱输出数据，其他3台计算机就会投票将其排除在外（没错，伙计们，火箭科学比你想象的更民主）。<br>
冗余装置要正常工作，就必须独立运行。一架航天飞机配备4台计算机，这听起来非常棒，但由于它们运行着相同的软件，所以只要一个软件出现错误，4台计算机就会同时瘫痪。因此，航天飞机还配备了第5个备用飞行系统。该系统安装有一款不同的软件，而这款软件由不同于其他4款软件的分包商提供。如果某个一般性的软件错误使4台相同的主计算机瘫痪，则备用系统将启动，并会将航天飞机送回地球。</p>
</blockquote>
<p>在航天飞机上配备 4 台计算机属于硬件冗余，第 5 个备用飞行系统属于软件冗余。</p>
<p>IDC 数据中心等级划分（<a href="https://en.wikipedia.org/wiki/Data_centre_tiers">data centre tiers</a>）主要是根据线路、电源、冷却等核心组件的冗余程度而划分的，不同的等级代表不同的可靠性和可用性。按 Uptime Institute 和 TIA-942 标准的建议，数据中心由低到高划分为 T1、T2、T3、T4 共 4 个等级，T1 级为基本型、T2 级为冗余型、T3 级为可并行维护冗余型、T4 级为容错型。4 个等级的冗余程度分别是，T1 级无冗余，T2 级部分 N+1 冗余，T3 级全部 N+1 冗余，T4 级 2N 或 2N+1 冗余。按我国国家标准《GB 50174-2017 数据中心设计规范》，数据中心由高到低划分为 A、B、C 三级，A 级为容错型，B 级为冗余型，C 级为基本型。不同的数据中心等级的对比，如下表所示（表格参考自<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>）：</p>
<img width="700" alt="数据中心等级划分" title="数据中心等级划分" src="https://static.nullwy.me/data-centre-tiers.png">
<p>大多数商业数据中心都介于 T3 级和 T4 级之间，平衡了建设成本和可靠性。金融等行业的数据中心，如银行的数据中心，通常会同时遵循最高等级的国家标准 A 级和 Uptime Institute 的 Tier 4 级标准来建设。</p>
<p>在生物学中，冗余是生物体的一种重要特征。生物体中的冗余结构和功能可以提高生物体的适应性和生存能力。例如，人体的很多器官是冗余的，比如耳朵、眼睛、肾、肺。冗余的器官如果出现“故障”，虽然不会让人完全失去该器官的机能，但会导致机能降级。其中一个眼睛如果完全失去视力，不会让人失明，不过视觉上无法识别远近。其中一个耳朵如果完全没有听力，不会让人失聪，但无法透过耳朵识别声音的位置。</p>
<p>尽管冗余是一种很好的提高可靠性的措施，但额外的冗余增加到某种程度之后，就会无谓地增加设备的复杂性和成本，遵循边际效益递减规律。典型的例子是客机，随着发动机本身可靠性的提高，出于安全性和成本之间的权衡，之前的四发动机的客机越来越少见，逐渐被更省油、更低维护成本的双发动机的客机取代。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>秦咏红，吕乃基：工程系统可靠性的演进，东北大学学报，2011年第4期295-299，<a href="https://kns.cnki.net/kcms2/article/abstract?v=zcLOVLBHd2wIt8gpzydgP6J3pB-hC88RrjSmTExnvcHvDDGG-WWagNHfY8JcfcgvEZjVrR4jQJ5Duh_KjbIUFWmw0rDVJqeHyfZG93hQC7B8vh91-Q5vECPlrcF0-t_l&amp;uniplatform=NZKPT&amp;flag=copy">cnki</a>，<a href="https://qikan.cqvip.com/Qikan/Article/Detail?id=38777595">cqvip</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>可靠性概论，工信部电子第五研究所潘勇，2015，<a href="https://book.douban.com/subject/26870237/">豆瓣</a>：第11章 可靠性标准 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2022-09 【标准解读】用标准语言解读装备“六性” <a href="https://mp.weixin.qq.com/s/FqfLL_ovGIZ-GO998HB4uw">https://mp.weixin.qq.com/s/FqfLL_ovGIZ-GO998HB4uw</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2021-07 张健：装备通用质量特性关系概述 <a href="https://mp.weixin.qq.com/s/nXmrTrz7c5EnEh4C_h4JEg">https://mp.weixin.qq.com/s/nXmrTrz7c5EnEh4C_h4JEg</a> <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a> <a href="#fnref4:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>可靠性工程师手册，中国质量协会，第2版 2017，<a href="https://book.douban.com/subject/10607952/">豆瓣</a> <a href="#fnref5" class="footnote-backref">↩︎</a> <a href="#fnref5:1" class="footnote-backref">↩︎</a> <a href="#fnref5:2" class="footnote-backref">↩︎</a> <a href="#fnref5:3" class="footnote-backref">↩︎</a> <a href="#fnref5:4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>2018-01 北航康锐：可靠性的历史与今世 | 可靠性系统工程三部曲（上） <a href="https://mp.weixin.qq.com/s/275pk9Z-V4T3lntI-ZzYCA">https://mp.weixin.qq.com/s/275pk9Z-V4T3lntI-ZzYCA</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>可靠性工程（Reliability Engineering），Kapur &amp; Pecht，2014，<a href="https://book.douban.com/subject/30619305/">豆瓣</a>：第1章 21世纪的可靠性工程 <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>2002-03 褚善元：failure和fault的定名问题 <a href="http://www.term.org.cn/CN/abstract/abstract10076.shtml">http://www.term.org.cn/CN/abstract/abstract10076.shtml</a> <a href="#fnref8" class="footnote-backref">↩︎</a> <a href="#fnref8:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>2002-03 朱美娴：关于failure和fault定义的研讨 <a href="http://www.term.org.cn/CN/abstract/abstract10081.shtml">http://www.term.org.cn/CN/abstract/abstract10081.shtml</a> <a href="#fnref9" class="footnote-backref">↩︎</a> <a href="#fnref9:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>System Reliability Theory, Rausand, etc., 3rd 2020，<a href="https://book.douban.com/subject/35473900/">豆瓣</a>：3 Failures and Faults, Figure 3.3 Illustration of the difference between failure and fault for a degrading item. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>2021-09 揭秘：SSD 的“可靠性”到底可不可靠 <a href="https://memblaze.com/innovate/technical-articles/169.html">https://memblaze.com/innovate/technical-articles/169.html</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>实用可靠性工程（Practical Reliability Engineering），O'Connor, etc.，第5版2012，<a href="https://book.douban.com/subject/35263950/">豆瓣</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>陈光宇，黄锡滋：软件可靠性学科发展现状及展望，电子科技大学学报社科版，2002年第3期99-102，<a href="https://kns.cnki.net/kcms2/article/abstract?v=zcLOVLBHd2zqRn-SkRJjlRMqbVpWEZ7eixyUtZPjIkGDWM0ZZEly0jGgd6xE2xxgo1E7iX46uLXaMFUfS0eD7b9dTozKwVt_XXdd_svP-taFGshzUvzPODSCvVkd2rIz&amp;uniplatform=NZKPT&amp;flag=copy">cnki</a>，<a href="https://qikan.cqvip.com/Qikan/Article/Detail?id=6859748">cqvip</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>SRE：Google运维解密，Beyer, etc. 2016，<a href="https://book.douban.com/subject/26875239/">豆瓣</a>：序言 <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>SRE原理与实践：构建高可靠性互联网应用，张观石，2022，<a href="https://book.douban.com/subject/36202918/">豆瓣</a>：第1章 互联网软件可靠性概论 <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>软件工程：实践者的研究方法，Pressman，第8版2014，<a href="https://book.douban.com/subject/26918148/">豆瓣</a>：第21章 软件质量保证，21.7 软件可靠性 <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>2010-11 John Allspaw: MTTR is more important than MTBF (for most types of F) <a href="https://www.kitchensoap.com/2010/11/07/mttr-mtbf-for-most-types-of-f/">https://www.kitchensoap.com/2010/11/07/mttr-mtbf-for-most-types-of-f/</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2023-07 LigaAI：研发质量指标大 PK：MTTR vs MTBF，谁是靠谱王？ <a href="https://segmentfault.com/a/1190000043971564">https://segmentfault.com/a/1190000043971564</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>像火箭科学家一样思考，Ozan Varol，2020，<a href="https://book.douban.com/subject/35228079/">豆瓣</a>：第1章 与不确定性共舞，为什么冗余不是多余的 <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>2020-12 艾瑞咨询：2020年中国数据中心行业研究报告 <a href="https://report.iresearch.cn/report/202012/3699.shtml">https://report.iresearch.cn/report/202012/3699.shtml</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>可靠性</tag>
        <tag>SRE</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站的性能和可伸缩性</title>
    <url>/2023/12/website-performance-scalability/</url>
    <content><![CDATA[<p>互联网网站在初期用户量和访问量一般都很小，往往只需要采用最简单的技术架构就能对外提供稳定服务。最简单的架构通常采用的是单机应用服务器、单机数据库服务器这样的单体架构。成功的互联网网站，比如电商平台，流量、用户量、交易量等核心指标是呈指数增长的，所以就需要提升网站系统的性能，来应对更大的负载。通过向系统中增加资源来提升系统性能的能力，被称为可伸缩性（<a href="https://en.wikipedia.org/wiki/Scalability">scalability</a>）。为了提升系统的可伸缩性，典型的大型网站，比如 eBay、Amazon 和淘宝等，几乎都经历过从单体架构向分布式架构演进的过程。本文主要关注大型网站或 Web 服务这类系统，解释系统的性能和可伸缩性相关的核心概念，并介绍系统的性能指标、系统的扩展策略和分布式架构风格，同时也总结分析典型大型网站的可扩展性架构演进案例，案例包括 eBay、Amazon、淘宝等。</p>
<span id="more"></span>
<h1 id="术语与概念">术语与概念</h1>
<p>让我们先看下，<strong>系统的性能和可伸缩性的相关的概念</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<ul>
<li><strong>性能（<a href="https://en.wikipedia.org/wiki/Computer_performance">performance</a>）</strong>，是系统在指定时间和使用资源的条件下所完成工作量。度量性能的最重要指标是，吞吐量和响应时间。</li>
<li><strong>吞吐量（throughput）</strong>，是在单位时间内系统能够处理的工作负载（workload）的量。对于文件 I/O 来说，吞吐量可以用每秒字节量来表示。对于企业应用来说，吞吐量通常用每秒事务数（TPS）来度量。</li>
<li><strong>响应时间（response time）</strong>，是一次操作完成的时间，包括用于等待服务的时间（wait time）和服务时间（service time），也包括用来传送结果的时间（transmission time）。</li>
<li><strong>延时（latency）</strong>：是描述操作里用来等待服务的时间（wait time）。在某些情况下，它可以指的是整个操作时间，等同于响应时间。</li>
<li><strong>系统的容量（capacity）</strong>，是指最大有效负载或吞吐量的指标。它可以是一个绝对最大值或性能衰减至低于一个可接受的阈值之前的临界点。</li>
<li><strong>瓶颈（<a href="https://en.wikipedia.org/wiki/Bottleneck_%28software%29">bottleneck</a>）</strong>：在系统性能里，瓶颈指的是限制系统性能的那个资源。分辨和移除系统瓶颈是系统性能的一项重要工作。</li>
<li><strong>工作负载（workload）</strong>：系统的输入或者是对系统所施加的负载叫做工作负载。比如，对于数据库来说，工作负载就是客户端发出的数据库请求量。</li>
<li><strong>可伸缩性（scalability）</strong>，是指通过向系统中增加资源来应对增长的工作负载的能力。</li>
</ul>
<p>系统的可伸缩性与性能紧密相关，性能关注的是系统执行当前工作负载有多快，而可伸缩性关注的是当负载增长或者资源增加时系统性能会如何变化。也就是说，可伸缩性关注的是性能变化曲线，曲线是在给定资源的条件下的负载-性能曲线和在给定负载条件下的资源-性能曲线，而性能只是曲线上的一个点。</p>
<p>可伸缩性通常要考虑的问题是，“如何应对工作负载的增长，有哪些措施”，“如何向系统增加资源来处理额外的工作负载”<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<p>严格意义上，术语“scalability”同时包含伸和缩两方面能力<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，即同时包含增强系统处理能力和缩减系统处理能力。当术语“scalability”同时表示伸和缩时，翻译为“可伸缩性”更准确。不过很多英文资料<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup><sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>在使用术语“scalability”时，所指的含义只是增强系统处理能力，而不考虑缩减系统处理能力，所以很多中文资料会把“scalability”翻译为“可扩展性”。另外，“large-scale”通常会被翻译为“规模化”、“大规模”或“大型”。类似的，“large-scale distributed system”通常被翻译为“大规模分布式系统”或“大型分布式系统”。</p>
<p>术语“scalability”会被翻译为“可扩展性”，而术语“<a href="https://en.wikipedia.org/wiki/Extensibility">extensibility</a>”在很多中文资料中也会被翻译为“可扩展性”，容易混淆，需要注意区分。“extensibility”指的是系统增加新的功能以及修改现有功能的能力。可扩展性的实现模式有很多<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>，典型的是插件（<a href="https://en.wikipedia.org/wiki/Plug-in_%28computing%29">plugin</a>），比如浏览器、编辑器、IDE 等的“扩展”（extension），或直接称为“插件”（plugin）。插件与核心应用程序分开开发，运行时动态加载，使第三方开发人员能够扩展应用程序。除了插件模式外，拦截过滤器（Intercepting Filter）设计模式，也是实现可扩展性的经典模式，通过过滤器对某逻辑做扩展。“<a href="https://en.wikipedia.org/wiki/Software_quality#Maintainability">maintainability</a>”（可维护性）是相对“extensibility”含义更广的特性。可维护性是指系统可被修改（modification）的难易程度，修改包括纠正（correction）、改进（improvement）和适应（adaption）。可维护性中的改进性的修改，可以认为等同于“extensibility”。</p>
<p>性能、可伸缩性等特性都属于系统的<strong>架构特性</strong>（architecture characteristics）<sup class="footnote-ref"><a href="#fn7" id="fnref7:1">[7:1]</a></sup>，这些特性实现的是系统的非功能性需求，是影响系统是否成功的至关重要的关注点。除了被命名为架构特性外，很多时候也被统称为系统的质量属性（<a href="https://en.wikipedia.org/wiki/List_of_system_quality_attributes">quality attributes</a>）。</p>
<h1 id="性能指标">性能指标</h1>
<p>吞吐量和响应时间是度量性能的最重要指标，两者之间有着非常复杂的关系<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。假设某系统吞吐量是每秒执行 1000 个任务，不能简单的认为每个任务的平均响应时间为 1 ms。假设处理此吞吐量的系统有 1000 个并行、独立、同构的服务通道，在这种情况下，每个请求可能正好消耗 1 秒。所以，不能从吞吐量推算出响应时间，必须单独测量。假设在单 CPU 计算机上执行某任务耗时 1 ms，如果任务请求被很好地串行化，那么理想情况是在 1 秒的时间内能执行该任务 1000 次，吞吐量是每秒执行 1000 个任务。但实际情况这些任务很可能是随机请求的，CPU 调度程序和任务对共享资源的竞争可能会将吞吐量限制在远低于每秒 1000 个任务的数量。所以，也不能从响应时间推算出吞吐量，必须单独测量。总体来说，任务的响应时间越短，系统所能达到的吞吐量就越高。</p>
<p>统计服务的响应时间，常见的使用平均响应时间。平均响应时间，计算的是多次请求的响应时间的算术平均值。不过平均响应时间并不是很合适的统计值，<a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0">百分位数</a>（percentile）能更好反应人类的延迟体验。假设响应时间的第 90 百分位数（90th percentile）的值是 100 ms，意味着 90% 请求的响应时间小于 100 ms，10% 请求的响应时间大于 100 ms。常见百分位数有第 50、90、95、99 和 99.9 百分位数，分布缩写为 P50、P90、P95、P99 和 P99.9，其中第 50 百分位数叫做<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BD%8D%E6%95%B8">中位数</a>（median）。百分位数相对算术平均值的优点是能排除<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E5%B8%B8%E5%80%BC">异常值</a>（outlier）。假设有一组共 10 个的响应时间数据分别是（递增排序，单位 ms）：<code>[924, 928, 954, 957, 961, 965, 972, 979, 987, 2373]</code>。可以明显看到最后一个值 <code>2373</code> 和其他所有值都有较大差别，这个值是异常值，可能是因为网络异常而引入，需要排除。如果计算这组响应时间数据的算术平均值（平均响应时间 1100 ms），这个异常值会导致统计结果与真实情况偏差。而这组数据计算的 P50 中位数响应时间是 961 ms，P90 响应时间是 987 ms，百分位数能排除异常值，统计值结果更加可信。</p>
<h1 id="资源过载与峰值流量">资源过载与峰值流量</h1>
<p>典型的系统负载增加下的吞吐量变化曲线和响应时间变化曲线<sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup>：</p>
<img width="400" alt="吞吐量 vs. 负载" title="吞吐量 vs. 负载" src="https://static.nullwy.me/scalability-throughput-vs-load.png">
<img width="400" alt="性能下降" title="性能下降" src="https://static.nullwy.me/scalability-performance-degradation.png">
<p>在开始的一段时间内，随着工作负载增加，吞吐量也随着线性增加。但是随着到达某一点，也就是“拐点”（knee），即图中两条曲线的分界点，负载对于资源的争夺开始影响性能，偏离了线性变化，甚至出现吞吐量不增加反而下降的现象。这种现象通常是由于系统中一种或者多种重要资源极度过载（overload）无法有效工作而造成的。一个说明这种现象的例子是多线程执行计算密集型任务，当线程数小于等于 CPU 核数时，通过增加线程数来并发执行更多任务（增加工作负载）吞吐量也会随着线性增长，但是在全部 CPU 核都接近 100% 使用率后，更多的线程会导致更多的线程上下文切换，额外消耗 CPU 资源，结果实际完成的任务数会变少，整体吞吐量反而下降。</p>
<p>响应时间的变化曲线也是类似。如果出现 CPU 过载，会导致响应时间慢速下降。如果出现内存过载，系统利用磁盘换页（或者使用 swap）来补充内存的时候，会导致响应时间快速下降。</p>
<p><strong>工作负载过大导致系统性能出现拐点的情况，显然是需要尽量避免的</strong>，应对策略有两种：</p>
<ul>
<li>(1) 通过过载保护，避免达到那样的工作负载级别。</li>
<li>(2) 通过提升系统性能，让系统能有效处理这样的工作负载级别。</li>
</ul>
<p>第一种策略，在应对超预期的突发流量时比较常见，通过限流、降级等方式避免系统过载。不过这种策略的问题是降低了用户体验。第二种策略，应对的是预期内的正常的负载增长，针对可能的过载资源，通过性能调优或扩展硬件资源解决。</p>
<p>应对瞬间的峰值流量，最有代表性的场景是秒杀抢购。<strong>类似的，秒杀抢购系统的设计的两种策略是，排队限流和提升扣减库存性能</strong>。通常真实抢购的秒杀系统会结合使用多种策略，但有所侧重。主要策略采用排队限流，典型的案例是小米抢购限流峰值系统<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>。主要策略采用提升扣减库存性能，典型的案例是淘宝秒杀系统。具体实现上，淘宝秒杀系统早期是基于 Redis（Tair）实现扣减库存<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>，后来针对扣减库存场景优化数据库内核的性能，直接在数据库上实现扣减库存<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>。</p>
<p>本质上来看，<strong>互联网应用的峰值流量的应对策略，与日常生活中的峰值流量的应对策略类似</strong>，典型的就是节假日和春运期间的交通系统。临时应对策略无非就是增加购票和安检处理窗口、增加车辆班次、以及增加值班人员让排队更加有序等等，长期对应策略主要就是增强交通基础设施的流量处理能力，包括扩建火车站、修建高铁、修建高速公路等等。</p>
<h1 id="系统扩展策略">系统扩展策略</h1>
<h2 id="垂直伸缩与水平伸缩">垂直伸缩与水平伸缩</h2>
<p>扩展系统的硬件资源有两种策略，(1) 垂直伸缩（vertical scaling），也叫做向上伸缩（scaling up）； (2) 水平伸缩（horizontal scaling），也叫做向外伸缩（scaling out）。</p>
<ul>
<li><strong>垂直伸缩</strong>，意味着向单个服务器添加资源，提高单个服务器节点的性能（吞吐量、响应时间）。</li>
<li><strong>水平伸缩</strong>，意味着向系统添加更多服务器节点，提高系统的吞吐量。</li>
</ul>
<p>垂直伸缩，通常是给服务器添加 CPU、内存或存储等，比如更新服务器获得更多处理器或者更多虚拟核，通过增加内存减少 I/O 操作，通过切换到 SSD（固态硬盘）改善 I/O 访问速度，通过升级网络设备提高网络吞吐能力。<strong>如果系统急切需要扩展，垂直伸缩可能是最容易的，但是垂直伸缩会随着规模增长而越来越昂贵</strong>。另外的问题是<strong>垂直伸缩是有极限的</strong>。无论你愿意花多少钱，内存都不可能无限地增加下去。类似的限制还有 CPU 的速度，每台服务器的虚拟核数目，硬盘的速度。简单说来，到了某个极限，没有任何硬件能力能够继续增加。</p>
<p>水平扩展不需要购买更加昂贵的硬件设备，而是需要增加额外的相对廉价的服务器节点。<strong>水平伸缩总是可以增加更多服务器，而不会像垂直伸缩那样遭遇到单台服务器的极限</strong>。但是与垂直伸缩不同，为了让系统架构能支持水平扩展，必须付出相当的开发代价。</p>
<p>总的来说，更多硬件资源意味着更高的吞吐量和更好的响应时间，同时要付出更高的成本。考虑到成本和性能之间的基本关系，通常要用最少量的硬件，让系统满足性能目标。水平伸缩和垂直伸缩的成本对比，如下图所示，X 轴表示系统的计算能力（容量），Y 轴表示单位计算能力（容量）的价格，虚线表示垂直伸缩的成本，实线表示水平伸缩的成本<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>。</p>
<img width="400" alt="水平伸缩与垂直伸缩成本对比" title="水平伸缩与垂直伸缩成本对比" src="https://static.nullwy.me/scalability-vertical-and-horizontal-scaling-costs.png">
<p>另外，需要注意的是，向上伸缩（scaling up）的相反方向是向下伸缩（scaling down），向外伸缩（scaling out）的相反方向是向内伸缩（scaling in）。向上伸缩或向外伸缩，增强系统处理能力；向下伸缩或向内伸缩，缩减系统处理能力。需要缩容的场景，比较典型的是为了处理短期大流量的扩容之后的缩容，比如大促，<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E8%89%B2%E6%98%9F%E6%9C%9F%E4%BA%94_(%E8%B4%AD%E7%89%A9)">黑色星期五</a>（Black Friday）和<a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%8D%81%E4%B8%80">双十一</a>等。在大促期间，通常需要增强系统处理能力，即扩容，而在大促结束后，流量回归日常，为了避免资源浪费，需要缩容。</p>
<h2 id="扩展立方体模型">扩展立方体模型</h2>
<p><a href="https://www.linkedin.com/in/martyabbott/">Martin Abbott</a> 曾经在 eBay 工作 6 年（1999 ~ 2005），并担任 CTO 等职位。基于 eBay 架构的扩展的实践经验<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup><sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>，Abbott 在《可扩展的艺术》（The Art of Scalability，2009）书中总结了三个维度的扩展方法，创造出<strong>扩展立方体模型</strong>（<a href="https://en.wikipedia.org/wiki/Scale_cube">scale cube</a>），如下图所示（图片来源<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>）。</p>
<img width="600" alt="扩展立方体" title="扩展立方体" src="https://static.nullwy.me/scalability-scale-cube.png">
<p>扩展立方体模型的三个维度代表的含义分别是：</p>
<ul>
<li><strong>X轴扩展</strong>：通过克隆或复制扩展，即通过克隆服务或复制数据库以分散负载。
<ul>
<li>克隆服务，在多个服务实例之间实现请求的负载均衡。</li>
<li>复制数据库，一种方法是在数据库的前面加缓冲层，减轻数据库的负载。另外的方法是数据库的主从复制，主库可读可写，从库只读，主从读写分离，在多个从库实例之间实现读请求的负载均衡。主从读写分离的问题是无法分散写请求。</li>
</ul>
</li>
<li><strong>Y轴扩展</strong>：通过拆分不同的东西来扩展，即按功能拆分服务和数据库。按功能拆分服务，是 SOA 和微服务架构所推崇的架构风格，这种架构风格推荐的是每个服务都拥有自己的数据库（<a href="https://microservices.io/patterns/data/database-per-service.html">database per service</a>）。另外，也可以选择不拆分服务，只拆分数据库。</li>
<li><strong>Z轴扩展</strong>：通过拆分类似的东西来扩展。通常是拆分非常大而且类似的数据集，也被称为数据分区（partitioning）或数据分片（sharding）。</li>
</ul>
<p>Y轴的拆分，也被成为垂直拆分，Z轴的拆分，也被成为水平拆分。容易发现，<strong>这三个维度都属于水平伸缩</strong>。三个维度的扩展有不同优缺点：</p>
<ul>
<li>X 轴扩展的成本最低并且最易于实施。</li>
<li>Y 轴扩展的成本和实施难度较高，但是相对 X 轴，除了进一步提高系统吞吐量外，额外的好处是有助于系统解耦和故障隔离，并且有助于团队成员的职责拆分和团队规模化。</li>
<li>Z 轴扩展的成本最高并且实施最困难，但带来最大扩展性。</li>
</ul>
<h1 id="SOA-与微服务">SOA 与微服务</h1>
<p>本质上来看，微服务架构是一种特殊的 SOA 架构，在“微服务”术语诞生之前，亚马逊的 SOA 架构实现被认为是“SOA done right”（正确实现的 SOA）<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>。Netflix 的 SOA 架构实现也在“微服务”术语诞生之前，Netflix 认为自己实现架构的是“fine-grained SOA”（细粒度的 SOA）<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>。James Lewis 和 Martin Fowler 等人是“微服务”概念的早期提倡者，他们将亚马逊和 Netflix 的 SOA 架构实现归类为微服务的经典案例<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>。所以，<strong>SOA 和微服务的关系可以简单理解为，微服务是“fine-grained SOA”或“SOA done right”</strong>。</p>
<p>根据 Martin Fowler 的解释<sup class="footnote-ref"><a href="#fn19" id="fnref19:1">[19:1]</a></sup><sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>，SOA 与微服务的关系，如下图所示：</p>
<img width="400" alt="SOA 与微服务的关系" title="SOA 与微服务的关系" src="https://static.nullwy.me/soa-vs-microservices.svg">
<p><strong>注意，解决网站的可扩展性问题，不一定需要演进为服务化架构</strong>。架构服务化意味着将完整的单体服务按业务的功能领域做垂直拆分，而实际上在应用服务层可以通过部署多个相同副本的单体服务的方式实现系统的水平扩展，网站的可扩展性问题主要在数据存储层上。<strong>拆分应用服务的好处更多在于能实现组织团队的规模化，拆分后的小团队独立维护各自的微服务，能有效提升研发效率</strong>。解决数据库的扩展性的策略有，数据复制（数据缓存、数据库主从读写分离）、数据垂直拆分、数据水平拆分（也叫数据分片，sharding）。数据库被拆分后，如果单个事务内的数据分散在多个节点就要解决分布式事务问题，但是实现分布式事务代价太大，通常的选择是牺牲一致性，仅满足最终一致性（<a href="https://en.wikipedia.org/wiki/Eventual_consistency">BASE</a>）。对于无或弱事务要求的非关系型的数据，也可以选择存储在可扩展性能力更强的 NoSQL 数据库。</p>
<p>没有拆分应用服务，始终采用单体架构的经典案例是 Instagram，2019 年 Instagram 在技术博客上有这样一段话<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>：</p>
<blockquote>
<p>Our server app is a monolith, one big codebase of several million lines and a few thousand Django endpoints, all loaded up and served together. A few services have been split out of the monolith, but we don’t have any plans to aggressively break it up.</p>
</blockquote>
<p>Instagram 解决可扩展性问题，主要在数据存储层<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup><sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>。在 Instagram，PostgreSQL 被用于存储用户信息、媒体元数据、用户关系等数据，照片媒体数据存储在亚马逊 S3 服务上。Instagram 对 PostgreSQL 数据库做了主从读写分离、数据垂直拆分和数据水平分片。另外，Instagram 从 2012 年开始使用 Cassandra 数据库，Cassandra 被用于存储 Feed 流、活动等数据。类似的，Reddit 也是单体架构，在数据存储层做了可扩展性改造<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>。对 PostgreSQL 数据库做了主从读写分离和垂直拆分，拆分为四个主数据库，链接、帐户、子版块、评论、投票和杂项，每个主数据库都从数据库。另外，投票数据存储在 Cassandra 数据库。</p>
<h1 id="自动弹性伸缩">自动弹性伸缩</h1>
<p>与“可伸缩性”（scalability）类似的特性是“弹性”（elasticity），<strong>弹性是按需自动增加或减少资源的能力，可伸缩性和弹性的区别是，可伸缩性的系统不必须具备自动伸缩的能力，而弹性的系统需要具备自动伸缩的能力</strong><sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup><sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>。所谓的“按需”，主要就是根据系统负载进行自动伸缩。来看下，微软 Azure 的 AZ-900 培训文档对术语“scalability”和“elasticity”的定义<sup class="footnote-ref"><a href="#fn4" id="fnref4:2">[4:2]</a></sup>：</p>
<blockquote>
<p><strong>Scalability</strong>: The ability to increase or decrease resources for any given workload. You can add additional resources to service a workload (known as scaling out), or add additional capabilities to manage an increase in demand to the existing resource (known as scaling up). Scalability doesn’t have to be done automatically.<br>
<strong>Elasticity</strong>: The ability to automatically or dynamically increase or decrease resources as needed. Elastic resources match the current needs, and resources are added or removed automatically to meet future needs when it’s needed (and from the most advantageous geographic location). A distinction between scalability and elasticity is that elasticity is done automatically.</p>
</blockquote>
<p><strong>可伸缩性是系统架构层面的能力，而弹性是基础设施层面的能力，弹性伸缩的基础设施，让系统的可伸缩性能力进一步提升</strong>。2011 年 9月，NIST 发布文档 SP 800-145 “The NIST Definition of Cloud Computing”，文档给出云计算的定义，该定义是目前最被广泛认同的云计算定义。定义包含云计算模型，模型中描述了云计算的五个基本特性，其中“快速的伸缩性”（rapid elasticity）就是五个基本特性之一。弹性是云计算的基本特性之一，也是云计算的一个最重要的优势和价值之一。亚马逊 AWS 在 2006 年推出的 EC2（Elastic Compute Cloud）就以弹性作为其关键词。类似的，阿里云的云服务器 ECS（Elastic Compute Service），也是以弹性作为其关键词。</p>
<p>在云环境下，根据系统负载自动增加或减少资源的功能特性，被称为<a href="https://zh.wikipedia.org/wiki/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9">弹性伸缩</a>（elastic scaling 或 auto scaling）。静态伸缩与弹性伸缩的对比，如下图所示<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>。</p>
<p><img src="https://static.nullwy.me/scalability-vs-elasticity.png" alt="静态伸缩与弹性伸缩的对比"></p>
<p>云环境的弹性伸缩的具体方案有，亚马逊 AWS 的“<a href="https://aws.amazon.com/cn/autoscaling/">Auto Scaling</a>”、阿里云的<a href="https://www.alibabacloud.com/help/zh/auto-scaling">弹性伸缩 ESS</a> 、基于 Kubernetes 的容器弹性伸缩等。弹性能力上，云虚拟机可以实现分钟级弹性响应，而以容器技术为基础的云原生技术架构可以实现秒级甚至毫秒级的弹性响应。</p>
<p>维基百科的“<a href="https://zh.wikipedia.org/wiki/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9">弹性伸缩</a>”词条，给出了弹性伸缩的 5 点优势：</p>
<blockquote>
<ul>
<li>对于服务运行在自建机房的公司，弹性伸缩通常意味着允许一些服务器在低负载时进入睡眠状态，从而节省电费（以及用于冷却机器的水费和水费）。</li>
<li>对于使用在托管在云上的机房的公司而言，自动扩展可能意味着更低的费用，因为大多数云提供商都基于总使用量而不是最大容量进行收费。</li>
<li>即使对于不能在任何给定时间减少运行或支付的总计算能力的公司，它们也可以在低流量时降低服务器的负载。</li>
<li>弹性伸缩解决方案（例如Amazon Web Services提供的解决方案）还可以用来替换异常状态的实例，从而在一定程度上防止硬件，网络和应用程序故障。</li>
<li>在生产工作负载经常变化且不可预测的情况下，弹性伸缩可以提供更长的正常运行时间和更高的可用性。</li>
</ul>
</blockquote>
<p>简单来说，弹性伸缩的主要优势是，节省服务器成本，并且能应对不可预测的突发流量，还有能容忍服务器故障。</p>
<p>2011 年 11 月，Amazon 网站全部都迁移到了 AWS 云服务器上<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup>。迁移到 AWS 上最大的动机是能利用  AWS 云服务器的弹性伸缩能力，从而节省成本。如果没有弹性伸缩能力，在淡季时，总体上服务器资源容量的利用率是 61%，无法有效利用的容量是 39%，到购物季的 11 月，无法有效利用的容量高到 76%。引入弹性伸缩技术后，可以按网站的实际流量负载情况，供应恰当的容量，避免资源浪费。Amazon 网站在淡季和购物季时的静态伸缩与弹性伸缩，如下图所示<sup class="footnote-ref"><a href="#fn27" id="fnref27:1">[27:1]</a></sup><sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup>。</p>
<img width="600" alt="Amazon 网站的典型的周流量分布" title="Amazon 网站的典型的周流量分布" src="https://static.nullwy.me/amazon-typical-weekly-traffic.png">
<img width="600" alt="Amazon 网站的静态伸缩" title="Amazon 网站的静态伸缩" src="https://static.nullwy.me/amazon-november-traffic-static-scaling.png">
<img width="600" alt="Amazon 网站的弹性伸缩" title="Amazon 网站的弹性伸缩" src="https://static.nullwy.me/amazon-november-traffic-elastic-scaling.png">
<p>类似的，阿里淘宝、天猫电商系统，为了应对双 11 大促，2015 年开始采用混合云弹性架构，即专有云+公共云，当本地保有云无法支撑时，就快速在公有云上扩容，当流量过去后，再还资源给公有云。2019 年双 11，阿里电商的全部核心应用迁移到公共云，到 2021 年双 11，阿里电商系统实现了 100% 上公共云<sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>性能之巅：系统、企业与云可观测性，Brendan Gregg，第2版2013，<a href="https://book.douban.com/subject/35934902/">豆瓣</a>：第2章 方法 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a> <a href="#fnref1:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>数据密集型应用系统设计 DDIA，Martin Kleppmann，2015，<a href="https://book.douban.com/subject/30329536/">豆瓣</a>：第1章 可靠、可扩展与可维护的应用系统 <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>构建可伸缩的Web应用，Artur Ejsmont，2015，<a href="https://book.douban.com/subject/26906846/">豆瓣</a>：1 核心概念 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2020-10 Azure AZ-900 Training: Some key cloud concepts <a href="https://www.azureguru.org/some-key-cloud-concepts-2/">https://www.azureguru.org/some-key-cloud-concepts-2/</a> <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a> <a href="#fnref4:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>AWS Well-Architected Framework: Concepts <a href="https://wa.aws.amazon.com/wellarchitected/2020-07-02T19-33-23/wat.concepts.wa-concepts.en.html">https://wa.aws.amazon.com/wellarchitected/2020-07-02T19-33-23/wat.concepts.wa-concepts.en.html</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>软件系统架构：使用视点和视角与利益相关者合作，Nick Rozanski &amp; Eoin Woods，第2版2011，<a href="https://book.douban.com/subject/24530471/">豆瓣</a>：第26章 性能和可伸缩性视角 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>软件架构：架构模式、特征及实践指南，Mark Richards &amp; Neal Ford，2020，<a href="https://book.douban.com/subject/35487561/">豆瓣</a>：第4章 现有的架构特征 <a href="#fnref7" class="footnote-backref">↩︎</a> <a href="#fnref7:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>2007-10 Gavin Terrill：你真的明白什么是可伸缩性吗？ <a href="https://www.infoq.cn/article/2007/10/whatisscalability">https://www.infoq.cn/article/2007/10/whatisscalability</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>2022-04 CMU SEI: Extensibility <a href="https://insights.sei.cmu.edu/library/extensibility/">https://insights.sei.cmu.edu/library/extensibility/</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>2010-09 Cary Millsap: Thinking Clearly about Performance <a href="https://queue.acm.org/detail.cfm?id=1854041">https://queue.acm.org/detail.cfm?id=1854041</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>2015-12 小米马利超：小米抢购限流峰值系统「大秒」架构解密 <a href="https://mp.weixin.qq.com/s/enRMYmss6Y5AUCvAMfpHtA">https://mp.weixin.qq.com/s/enRMYmss6Y5AUCvAMfpHtA</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>2011-07 jianchen：秒杀相关知识以及技术（淘宝秒杀） <a href="https://www.iteye.com/blog/jianchen-1113296">https://www.iteye.com/blog/jianchen-1113296</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>2016-03 淘宝许令波：淘宝大秒系统设计详解 <a href="https://www.toutiao.com/article/6260281405876470273">https://www.toutiao.com/article/6260281405876470273</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>2006-11 Randy Shoup, Dan Pritchett: The eBay Architecture (SDForum2006, slides, 37p) <a href="https://www.modb.pro/doc/116040">https://www.modb.pro/doc/116040</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>2008-06 Randy Shoup：可伸缩性最佳实践：来自 eBay 的经验 <a href="https://www.infoq.cn/article/ebay-scalability-best-practices">https://www.infoq.cn/article/ebay-scalability-best-practices</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>微服务架构设计模式，Chris Richardson，2018，豆瓣：第1章 逃离单体地狱，1.4.1 扩展立方体和服务，图1-3 扩展立方体 <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>2007-06 SOA done right: the Amazon strategy <a href="https://www.zdnet.com/article/soa-done-right-the-amazon-strategy/">https://www.zdnet.com/article/soa-done-right-the-amazon-strategy/</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2011-05 How the cloud helps Netflix (interview Adrian Cockcroft) <a href="http://radar.oreilly.com/2011/05/netflix-cloud.html">http://radar.oreilly.com/2011/05/netflix-cloud.html</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>2014-03 James Lewis &amp; Martin Fowler: Microservices <a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a> <a href="#fnref19" class="footnote-backref">↩︎</a> <a href="#fnref19:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>2014-11 Microservices • Martin Fowler • GOTO 2014 <a href="https://youtu.be/wgdBVIX9ifA?t=880">https://youtu.be/wgdBVIX9ifA?t=880</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>2019-08 Static Analysis at Scale: An Instagram Story <a href="https://instagram-engineering.com/8f498ab71a0c">https://instagram-engineering.com/8f498ab71a0c</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>2013-03 Instagram 5位传奇工程师背后的技术揭秘 <a href="https://web.archive.org/web/0/http://www.csdn.net/article/2013-03-28/2814698-The-technologie-%20behind-Instagram">https://web.archive.org/web/0/http://www.csdn.net/article/2013-03-28/2814698-The-technologie- behind-Instagram</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>2017-03 Lisa Guo: Scaling Instagram Infrastructure（QCon London 2017, 87p） <a href="https://www.infoq.com/presentations/instagram-scale-infrastructure/">https://www.infoq.com/presentations/instagram-scale-infrastructure/</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>2013-08 Reddit: Lessons Learned from Mistakes Made Scaling to 1 Billion Pageviews a Month <a href="http://highscalability.com/blog/2013/8/26/reddit-lessons-learned-from-mistakes-made-scaling-to-1-billi.html">http://highscalability.com/blog/2013/8/26/reddit-lessons-learned-from-mistakes-made-scaling-to-1-billi.html</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>2016-11 What is the difference between scalability and elasticity? <a href="https://stackoverflow.com/a/9610186/689699">https://stackoverflow.com/a/9610186/689699</a> <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>2020-03 AZ-900: Cloud Concepts - Scalability and Elasticity <a href="https://www.skylinesacademy.com/blog/2020/3/6/az-900-cloud-concepts-scalability-and-elasticity">https://www.skylinesacademy.com/blog/2020/3/6/az-900-cloud-concepts-scalability-and-elasticity</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>2011-07 2011 AWS Tour Australia, Closing Keynote: How Amazon migrated to AWS, by Jon Jenkins <a href="https://www.slideshare.net/AmazonWebServices/2011-aws-tour-australia-closing-keynote-how-amazoncom-migrated-to-aws-by-jon-jenkins">https://www.slideshare.net/AmazonWebServices/2011-aws-tour-australia-closing-keynote-how-amazoncom-migrated-to-aws-by-jon-jenkins</a> <a href="#fnref27" class="footnote-backref">↩︎</a> <a href="#fnref27:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>2017-03 AWS: Elasticity and Management <a href="https://www.slideshare.net/AmazonWebServices/elasticity-and-management">https://www.slideshare.net/AmazonWebServices/elasticity-and-management</a> <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>2021-11 2021天猫双11：首个100%的云上双11，体验如丝般顺滑 <a href="https://www.sohu.com/a/500431383_114930">https://www.sohu.com/a/500431383_114930</a> <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>可扩展性</tag>
        <tag>微服务</tag>
        <tag>SOA</tag>
        <tag>可伸缩性</tag>
        <tag>性能</tag>
        <tag>弹性</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站的稳定性、可靠性和韧性</title>
    <url>/2023/12/website-scalability-reliability-resilience/</url>
    <content><![CDATA[<p>为了应对负载的增长，提升系统性能，目前大型网站普遍都是分布式架构，采用微服务架构风格。分布式系统的最重要的架构特性是<strong>伸缩性</strong>（scalability），伸缩性的系统具备应对增长的工作负载的能力。关于性能和伸缩性，可以参阅笔者的文章《<a href="https://nullwy.me/2023/12/website-performance-scalability/">大型网站的性能和可伸缩性</a>》。相对于采用单体架构的系统，分布式系统中有大量的服务器及设备，各服务之间存在错综复杂的依赖关系，存在更多的不确定性。整个系统的故障率会随服务节点的增加而呈指数级增加，单一节点问题可能会被无限放大，日常运行过程中一定会伴随故障发生。所以构建分布式系统需要关注的另外一个重要架构特性是<strong>稳定性</strong>（stability）。有关减少系统故障以及快速从故障中恢复的工程实践，国内通常称为“稳定性建设”，而国外类似的工程实践更多称为“站点可靠性工程”（SRE, <a href="https://en.wikipedia.org/wiki/Site_reliability_engineering">Site reliability engineering</a>）。稳定性（stability）、可靠性（reliability）、韧性（resilience）、可用性（availability）等架构特性，相似并且相关，虽然严格区分的话，含义并不相同，但是很多时候在探讨这些架构特性时往往涵盖的是类似的内容。本文的内容主要是总结稳定性、可靠性、韧性这些架构特性的内涵，以及如何建设分布式系统的这些特性。</p>
<span id="more"></span>
<p>性能、伸缩性、稳定性、可靠性、韧性、可用性等特性都属于系统的<strong>架构特性</strong>（architecture characteristics）（或翻译为架构特征），这些特性实现的是系统的非功能性需求，是影响系统是否成功的至关重要的关注点<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。除了被统称为架构特性外，很多时候也被统称为系统的<strong>质量属性</strong>（<a href="https://en.wikipedia.org/wiki/List_of_system_quality_attributes">quality attributes</a>）。</p>
<h1 id="术语与概念">术语与概念</h1>
<h2 id="稳定性概念">稳定性概念</h2>
<p>先来看下术语“稳定性”（<a href="https://en.wikipedia.org/wiki/Stability">stability</a>）的含义。国家标准 <a href="https://std.samr.gov.cn/gb/search/gbDetailed?id=71F772D7805FD3A7E05397BE0A0AB82A">GB/T 11457-2006</a>《信息技术 软件工程术语》对术语“稳定性”的定义如下：</p>
<blockquote>
<p>2.1559 稳定性 stability<br>
a) 在有干扰或破坏事件影响下仍能保持不变的能力。<br>
b) 在干扰或破坏性事件之后返回到原始状态的能力。</p>
</blockquote>
<p>这个“稳定性”定义区分 a) 和 b) 两种类型的稳定性，关注点分别是“保持”和“恢复”。</p>
<p>除了软件系统涉及“稳定性”概念外，在其他领域的系统也会涉及“稳定性”概念。1995 年出版的经典著作《系统论：系统科学哲学》的第 15 章“系统稳定性原理”中，对“稳定性”概念有如下阐述<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<blockquote>
<p>系统稳定性原理指的是，在外界作用下开放系统具有一定的自我稳定能力，能够有一定范围内自我调节，从而保持和恢复原来的有序状态、保持和恢复原有的结构和功能。</p>
</blockquote>
<p>可以看到，这个定义同时涉及“保持”和“恢复”两个动词，正好对应了国家标准 GB/T 11457 的“稳定性”定义中的 a) 和 b) 两种类型的稳定性。</p>
<p>这两种类型的稳定性，在生态系统领域下，对应<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%85%8B%E7%A9%A9%E5%AE%9A%E6%80%A7">生态稳定性</a>的两种类型，并有专门的术语，分别是“<a href="https://zh.wikipedia.org/wiki/%E6%8A%B5%E6%8A%97%E5%8A%9B%E7%A9%A9%E5%AE%9A%E6%80%A7">抵抗力稳定性</a>”（resistance stability）和“<a href="https://zh.wikipedia.org/wiki/%E6%81%A2%E5%BE%A9%E5%8A%9B%E7%A9%A9%E5%AE%9A%E6%80%A7">恢复力稳定性</a>”（resilience stability）。英文术语“<a href="https://en.wikipedia.org/wiki/Resilience_(engineering_and_construction)">resilience</a>”被翻译为“恢复力”，但在软件工程领域，更加常见的是把“resilience”被翻译为“韧性”或“弹性”。</p>
<p><strong>简单概括来看，稳定性是承受干扰的能力，分为两种类型，抵抗力稳定性和和恢复力稳定性</strong>。对软件系统来说，干扰指的是故障的组件、瞬时高负载、持续高负载等。</p>
<p>对于稳定性的概念，也可以从系统的业务数据指标角度来理解<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p>
<blockquote>
<p>稳定性是指在一定工作条件下，业务服务成功率（反向对应失败率）、业务量的指标（如订单数、营收、PCU、QPS等）保持一致可预期的趋势，指标曲线呈现周期性或稳定在同一水平。与稳定性相对应的是异常波动性。系统稳定性代表软件系统能抵御各种异常因素造成系统核心指标抖动的能力。异常波动性度量一般是看实际曲线偏离预期稳定曲线的程度。</p>
</blockquote>
<p>如图，曲线 A 的指标呈现周期性变化，表明系统能保持稳定；而曲线 B 的指标在时间 t2 至 t3 之间出现异常波动，表明系统无法保持稳定，是不稳定的。稳定性的反义词是波动性（volatility）。</p>
<img width="600" alt="稳定性与异常波动" title="稳定性与异常波动" src="https://static.nullwy.me/stability-vs-volatility0.png">
<p>如果业务核心指标出现异常波动，说明很可能出现了故障。互联网应用的典型的故障定级标准的依据就是对业务核心指标的影响情况的判断。阿里的技术文档，给出了故障等级的参考定义<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，故障区分 4 个等级，P1 是最严重的故障，P4 是最轻微的故障。当业务量级为大体量时：对于核心功能，P1 级故障是成功率下跌 30% 及以上，P2 级故障是成功率下跌 20% ~ 30%，P3 级故障的定级标准是成功率下跌 20% 以下；对于非核心功能，P2 级故障是成功率下跌 30% 及以上，P3 级故障是成功率下跌 20%～30%，P4 级故障是成功率下跌 20% 以下。</p>
<h2 id="稳定性与可靠性">稳定性与可靠性</h2>
<p>由中国信息通信研究院牵头，并联合多个行业的多家单位（其中互联网公司包括阿里云、华为云、百度、蚂蚁、腾讯、字节跳动、京东、哈啰等），共同参与编制《分布式系统稳定性建设指南》<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，在 2022 年 6 月发布。该指南对系统稳定性有如下描述：</p>
<blockquote>
<p><strong>三、分布式系统稳定性建设目标</strong><br>
<strong>(一) 稳定性建设目标</strong><br>
稳定性建设目标：稳定性工作贯穿软件生命周期的全过程，从故障的视角来看稳定性建设的最终目标是“降发生”和“降影响”，稳定性建设目标可以通过评价指标实现量化。<br>
...<br>
降发生，即降低故障发生的概率。<br>
降影响，即降低故障发生后的影响范围。</p>
</blockquote>
<p>中国信通院的指南，是对“系统稳定性”的权威阐述。<strong>对稳定性建设的阐述，是从故障的视角看的，稳定性建设的目标是故障的“降发生”和“降影响”</strong>。这两个目标也与上文的稳定性定义的“保持”和“恢复”相对应。</p>
<img width="500" alt="中国信通院的分布式系统稳定性建设目标" title="中国信通院的分布式系统稳定性建设目标" src="https://static.nullwy.me/stability-goals-caict.png">
<p>故障的“降发生”和“降影响”，其实也是“可靠性工程”（<a href="https://en.wikipedia.org/wiki/Reliability_engineering">reliability engineering</a>）的目标。对“可靠性工程”的理解，区分狭义可靠性工程或者广义可靠性工程。狭义可靠性工程的目标仅是提高系统无故障运行的能力，即提高可靠性。而广义可靠性工程的目标除了提高可靠性外，还包括提高从故障中恢复运行能力，即维修性（maintainability），同时还包括其他围绕故障展开的各种能力，如可用性（availability）、保障性（supportability）等。<strong>通常提及“可靠性工程”时，大都是指广义可靠性工程，而提及“可靠性”时，更多是指狭义可靠性，即系统无故障运行的能力</strong>。从故障中恢复运行的能力，对于硬件产品通常被称为“维修性”（maintainability），但在软件系统下通常称为“<strong>韧性</strong>”（resilience）。术语“maintainability”，在硬件上下文中通常被翻译为“维修性”，而在软件上下文中通常被翻译为“维护性”或“可维护性”，软件可维护性指的是软件可被修改的能力，修改可能包括修复缺陷、增加或完善功能等。关于“可靠性工程”更加全面的阐述，可以参阅笔者的文章《<a href="https://nullwy.me/2023/10/reliability-engineering/">可靠性工程概述</a>》。</p>
<h2 id="韧性概念">韧性概念</h2>
<p>上文对韧性做了简单解释，现在让我们再展开来看看韧性的含义。根据维基百科的“<a href="https://en.wikipedia.org/wiki/Resilience_(engineering_and_construction)">Resilience</a>”词条的解释，在字典中，韧性（resilience）是“从困难或干扰中恢复的能力”（the ability to recover from difficulties or disturbance）。韧性一词的根源在拉丁语“resilio”中找到，意思是回到一个状态或反弹。但是很多时候术语“韧性”所代表的含义是对原始含义扩展后的含义。维基百科对术语“Resilience”的完整定义是：</p>
<blockquote>
<p>the ability to respond, absorb, and adapt to, as well as recover in a disruptive event<br>
在破坏性事件中做出响应、承受和适应以及恢复的能力</p>
</blockquote>
<p>“AWS Well-Architected Framework”文档，对“Resiliency”术语的定义是<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>：</p>
<blockquote>
<p>The ability for a system to recover from a failure induced by load, attacks, and failures.</p>
</blockquote>
<p>微软的 Azure 韧性白皮书，对“韧性”的解释<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>：</p>
<blockquote>
<p>韧性指系统从故障中恢复正常并继续工作的能力。它不仅指避免故障的能力，还包括在故障发生时避免停机或数据丢失的故障响应能力。韧性的目标是避免故障，并在无法避免故障时，使应用程序恢复至故障发生前完全正常的状态。<br>
Resiliency is the ability of a system to recover from failures and continue to function. It's not just about avoiding failures but responding to failures in a way that avoids downtime or data loss. The goal of resiliency is to avoid failures and if they still occur, return the application to a fully functioning state following an occurrence.</p>
</blockquote>
<p>Google 的《构建安全可靠的系统》一书对术语“韧性”（弹性）的解释是<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>：</p>
<blockquote>
<p>“弹性”代表的是系统承受重大故障或中断的能力。具备弹性的系统可以自动从系统的部分故障（或者整个系统的故障）中恢复，并在问题解决后恢复正常运行。理想情况下，弹性系统中的服务在整个事件过程中保持运行状态，但可能处于降级模式。将弹性嵌入到系统中每一层的设计中，有助于保护系统免受意外故障和攻击的影响。</p>
</blockquote>
<p>综合概括来看，<strong>狭义韧性，指的是自动或快速从故障中恢复运行的能力；而广义韧性，除了从故障中恢复运行的能力外，还包括故障容忍能力</strong>。故障容忍（<a href="https://en.wikipedia.org/wiki/Fault_tolerance">fault tolerance</a>，简称“容错”），是使系统在其某些组件中出现一个或多个故障时能够继续提供服务的能力，从客户的角度来看，该服务仍能完全正常运行，或可能降级运行。AWS 对韧性定义是属于狭义韧性，而维基百科、微软和 Google 对韧性定义都属于广义韧性。另外，值得注意的是，广义韧性的故障“恢复”和“容忍”的这两种能力，其实也对应着上文在解释“稳定性”术语时提到的恢复力和抵抗力。<strong>广义韧性的含义与稳定性的含义相似</strong>。</p>
<p>综合上文对各个概念的解释，<strong>可以将稳定性简单理解为，稳定性 = (狭义) 可靠性 + (狭义) 韧性</strong>。稳定性、可靠性与韧性的区别，如下图所示：</p>
<img width="400" alt="稳定性、可靠性与韧性的区别" title="稳定性、可靠性与韧性的区别" src="https://static.nullwy.me/stability-vs-reliability-vs-resilience.svg">
<p>可靠性和韧性的侧重点不同。<strong>可靠性工程的目标是尽可能减少系统中的故障，保证系统无故障运行。而韧性工程，接受故障总会发生的现实，关注的是如何降低故障带来的损失以及如何从故障中恢复</strong>。分布式系统，100% 的可靠性是不存在的，必须拥抱故障，提升系统的韧性，可靠性和韧性必须同时关注。不过在将“可靠性”和“韧性”的含义扩展后，很多时候这两个术语背后的内涵是等价的。</p>
<h2 id="可用性概念">可用性概念</h2>
<p>可用性（<a href="https://en.wikipedia.org/wiki/Availability">availability</a>）是衡量可靠性和韧性的综合性指标，可以表示为总可用时间除以总可用时间与总不可用时间之和，也可以通过平均无故障时间（MTTF，Mean Time To Failure）和平均故障恢复时间（MTTR，Mean Time To Repair）计算。可用性的计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>availability</mtext><mo>=</mo><mfrac><mtext>total uptime</mtext><mrow><mtext>total uptime</mtext><mo>+</mo><mtext>total downtime</mtext></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi></mrow><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>+</mo><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{availability} = \frac{\text{total uptime}}{\text{total uptime} + \text{total downtime}} = \frac {MTTF} {MTTF + MTTR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">availability</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4133em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total uptime</span></span><span class="mbin mtight">+</span><span class="mord text mtight"><span class="mord mtight">total downtime</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">total uptime</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2757em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">MTTF</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">MTTR</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">MTTF</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>高可用性（<a href="https://en.wikipedia.org/wiki/High_availability">high availability</a>）的系统，通常将可用性目标设定为 N 个 9，常见的可用性目标和不可用分钟数，如下表所示：</p>
<table>
<thead>
<tr>
<th>可用性</th>
<th>年不可用分钟数</th>
<th>月不可用分钟数</th>
</tr>
</thead>
<tbody>
<tr>
<td>99.5% (2.5 个 9)</td>
<td>2635</td>
<td>219</td>
</tr>
<tr>
<td>99.9% (3 个 9)</td>
<td>526</td>
<td>43.83</td>
</tr>
<tr>
<td>99.95% (3.5 个 9)</td>
<td>263</td>
<td>21.92</td>
</tr>
<tr>
<td>99.99% (4 个 9)</td>
<td>52.60</td>
<td>4.38</td>
</tr>
<tr>
<td>99.995% (4.5 个 9)</td>
<td>26.30</td>
<td>2.19</td>
</tr>
</tbody>
</table>
<p>很多云服务平台在服务级别协议（SLA）中规定了服务可用性承诺，比如 AWS EC2 服务 <a href="https://aws.amazon.com/cn/compute/sla/">SLA 协议</a>，区域级 SLA 承诺的每月可用性至少是 99.99%，实例级 SLA 承诺的每月可用性至少是 99.5%，若低于该承诺值，会作相应的赔偿，可用性越低，赔偿额度越高，若低于 95% 全额赔偿。一些互联网公司会在公司内部设定自己业务系统的 SLA 可用性目标，比如笔者所在的公司设定的年度 SLA 可用性目标是 99.99%，然后考核技术团队绩效的依据之一就是对这个可用性目标的达成情况。</p>
<p>想要提高系统的可用性，需要做的是<strong>延长无故障时间（MTTF）和缩短故障恢复时间（MTTR）</strong>。</p>
<h2 id="站点可靠性工程">站点可靠性工程</h2>
<p>站点可靠性工程（SRE, <a href="https://en.wikipedia.org/wiki/Site_reliability_engineering">Site reliability engineering</a>），起源于 Google，2003 年 Ben Treynor Sloss 在加入 Google 后组建了最早的 SRE 团队。在《SRE：Google运维解密》<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>（2016 年出版，该书是关于 SRE 的第一本书）中 Ben Treynor Sloss 解释了 SRE 的内涵：</p>
<blockquote>
<p>SRE 究竟是如何在 Google 起源的呢？其实我的答案非常简单：SRE 就是让软件工程师来设计一个新型运维团队的结果。... 从本质上来说，SRE 就是在用软件工程的思想和方法论完成以前由运维团队手动完成的任务。这些 SRE 倾向于通过设计、构建自动化工具来取代人工操作。... 我们可以认为 DevOps 是 SRE 核心理念的普适版，可以用于更广范围内的组织结构、管理结构和人员安排。同时，SRE 是 DevOps 模型在 Google 的具体实践，带有一些特别的扩展。</p>
</blockquote>
<p>对于 Google 来说，SRE 的内涵主要局限在 IT 运维（IT operations，也翻译为 IT 运营）实践上，SRE 是 DevOps 在 Google 的具体实践，即“class SRE implements interface DevOps”。不过，很多资料扩展了站点可靠性工程的内涵<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup><sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>，典型的代表是微软，微软对站点可靠性工程的定义是<sup class="footnote-ref"><a href="#fn11" id="fnref11:1">[11:1]</a></sup>：</p>
<blockquote>
<p>Site Reliability Engineering is an engineering discipline devoted to helping an organization sustainably achieve the appropriate level of reliability in their systems, services, and products.<br>
站点可靠性工程是一门工程学科，致力于帮助组织可持续地实现其系统、服务和产品的适当可靠性水平。</p>
</blockquote>
<p>可以看到，这个定义没有与“运维”强绑定，实现可靠性水平相关的工程实践都属于站点可靠性工程。扩展内涵后的站点可靠性工程，除了用软件工程方式完成运维任务外，还涉及韧性架构设计，可靠性工作贯穿软件生命周期的全过程<sup class="footnote-ref"><a href="#fn3" id="fnref3:2">[3:2]</a></sup><sup class="footnote-ref"><a href="#fn12" id="fnref12:1">[12:1]</a></sup>。SRE 工程师的技能要求，如下图所示<sup class="footnote-ref"><a href="#fn12" id="fnref12:2">[12:2]</a></sup>。</p>
<img width="550" alt="SRE 工程师的技能要求" title="SRE 工程师的技能要求" src="https://static.nullwy.me/sre-skills.jpg">
<p><strong>可以认为，Google 诠释的站点可靠性工程是狭义站点可靠性工程，而扩展后的站点可靠性工程是广义站点可靠性工程。简单来说，广义站点可靠性工程等价于中国信通院的指南的分布式系统稳定性建设，两者涵盖相同的内容。</strong></p>
<p>《SRE：Google运维解密》最早介绍了 SRE 的可靠性层级模型。前 Google SRE 工程师 Nat Welch 在《SRE生存指南》（Real World SRE, <a href="https://www.packtpub.com/product/real-world-sre/9781788628884">2018</a>）一书中对可靠性层级模型做了更加系统全面的阐述。可靠性层级模型是前 Google SRE 工程师 <a href="https://en.wikipedia.org/wiki/Mikey_Dickerson">Mikey Dickerson</a> 为了解释如何提高系统可靠性而提出来的。模型的各个层次从低到高分别是：韧性架构设计（design resilient architecture）、监控（monitoring）、事故响应（incident response）、事后回顾（postmortems）、测试与发布（test/release processes）、容量规划（capacity planning）、开发（development）、用户体验（UX）。类似于<a href="https://zh.wikipedia.org/wiki/%E9%9C%80%E6%B1%82%E5%B1%82%E6%AC%A1%E7%90%86%E8%AE%BA">马斯洛需求层次模型</a>，可靠性层级模型的不同层次代表不同的优先级，低层是基本需求，高层是高级需求，在满足可靠性需求时，需要按部就班，在到达更高层次之前必须先满足每个低层次的需求。SRE 的可靠性层级模型，如下图所示。</p>
<img width="450" alt="SRE 的可靠性层级模型" title="SRE 的可靠性层级模型" src="https://static.nullwy.me/sre-reliability-hierarchy.svg">
<p>需要注意的是，Dickerson 原始的可靠性层级模型的最低层是监控，而不是韧性架构设计，之所以加上了韧性架构设计，参考的是微软的技术培训师 Unai Huete Beloki 写的关于 SRE 的书籍<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>。</p>
<h1 id="可靠性和韧性设计">可靠性和韧性设计</h1>
<p>基于 AWS 的经验，对于分布式系统的故障，亚马逊 CTO Werner Vogels 有如下总结<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>：</p>
<blockquote>
<p>Failures are a given and everything will eventually fail over time: from routers to hard disks, from operating systems to memory units corrupting TCP packets, from transient errors to permanent failures. This is a given, whether you are using the highest-quality hardware or lowest cost components. ... We needed to build systems that embrace failure as a natural occurrence even if we did not know what the failure might be. Systems need to keep running even if the “house is on fire.” It is important to be able to manage pieces that are impacted without the need to take the overall system down.<br>
故障是注定的；随着时间的流逝，一切终将归于失败：从路由器到硬盘，从操作系统到存储单元损坏的TCP数据包，从瞬时误差到永久失效，无论你用的是最高质量的硬件还是最低成本的组件，这都是理所当然的。... 因此，我们需要构建的是将故障视为自然发生的系统，即使我们并不知道故障是什么。这个系统应该要做到，即使在“后院已经着火”的情况下依然可以继续运行。重要的是在不需要引起整个系统宕机的情况下就能管理好受影响的局部组件。</p>
</blockquote>
<p>Werner Vogels 的名言是，“Everything fails, all the time”。<strong>分布式系统，100% 的可靠性是不存在的，必须拥抱故障，假设一切都会失败，面向故障设计，这样没什么会真正失败（design for failure and nothing will really fail）</strong>。面向故障设计（design for failure），或翻译为“面向失败设计”、“防故障设计”等，接受故障总会发生的现实，以提升系统的韧性为目标，也叫做<strong>韧性设计</strong>（design for resilience）。面向故障设计，是亚马逊 AWS 的关于在云环境下构建应用的白皮书“Architecting for The Cloud: Best Practices”中总结的第一条最佳架构实践<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup><sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>。目前这个白皮书已经被最新的“AWS Well-Architected Framework”白皮书替代。</p>
<p>AWS 的 <a href="https://aws.amazon.com/cn/architecture/well-architected/">Well-Architected 框架</a>，最早在 2015 年 10 月发布<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>，描述了用于在云中设计和运行工作负载的关键概念、设计原则和架构最佳实践。受亚马逊 AWS 的影响和启发，其他云平台也相继发布类似的在云环境下的架构最佳实践的框架，<a href="https://cloud.google.com/architecture/framework?hl=zh-cn">Google Cloud 架构框架</a>（2015.10）、<a href="https://learn.microsoft.com/zh-cn/azure/well-architected/">Microsoft Azure Well-Architected 框架</a>（2020.08）、<a href="https://help.aliyun.com/product/2362200.html">阿里云卓越架构</a>（2023.06）。这些框架都由五个或六个支柱组成，内容上大同小异。AWS 的 Well-Architected 框架基于六大支柱，其中两个支柱是<strong>可靠性支柱（Reliability Pillar）<strong>和</strong>卓越运营支柱（Operational Excellence Pillar）</strong>。可靠性支柱侧重于执行预期职能的工作负载，以及如何从故障快速恢复以满足需求。类似的，Google Cloud 架构框架由六大支柱组成，其中两个支柱是可靠性和卓越运营。Azure 架构良好的框架的由五大要素组成，其中两个要素是可靠性和卓越运营。阿里云卓越架构包含五个架构最佳实践支柱，其中两个支柱是<strong>稳定性</strong>和<strong>卓越运营</strong>。可靠性或稳定性支柱涵盖的内容相对偏向上文提到的<strong>面向故障设计</strong>或<strong>韧性架构设计</strong>，而卓越运营支柱涵盖的内容相对偏向上文提到的<strong>狭义 SER</strong> 或 <strong>DevOps</strong>，不过两个支柱涉及的内容有很重叠的部分。</p>
<p><strong>按故障的根因（root cause）分类，主要有如下类型：硬件故障（hardware failure）、网络故障（network failure）、软件 bug（software bug）、配置错误（misconfiguration）、运维操作错误（operator error）、过载（overload）、依赖服务（dependency service）等</strong>。故障原因的分类，不同的组织各有不同，有些分类可能会把配置错误和运维操作错误一起归类为人为错误（human error）。另外，本质上来看，软件 bug 也是开发时的人为错误引入的，但一般都不把人为错误和软件故障区分为两种类型的故障。</p>
<p>下图所示的是造成谷歌某大型互联网服务可检测到的服务中断所有事件的一个粗略分类，以及故障原因的分布比例<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>。容易发现，故障更多是由软件错误、错误的配置和人为错误造成的，而非机器或网络故障。由硬件故障导致的服务级别故障占比之所以很低，主要不是依靠这些系统硬件组件的可靠性，而是因为容错技术在防止组件故障影响上层系统行为方面是相当成功的。硬件设备故障以外的因素更容易导致服务级别中断，是因为构建能容忍已知硬件故障的服务相对容易，而处理一般的软件错误和运维人员误操作则比较难。</p>
<img width="550" alt="谷歌某一主要服务最可能的故障原因分布" title="谷歌某一主要服务最可能的故障原因分布" src="https://static.nullwy.me/stability-google-service-failures-distribution.png">
<p>提高系统可靠性的方法分为：</p>
<ul>
<li><strong>故障避免（fault avoidonce，简称“避错”）</strong>：在系统的设计和实现过程中使用一些开发方法来减少故障发生，并在系统部署使用之前进行验证和确认来发现和去除程序中的故障。避错技术包括通过优秀的软件设计方法、编译器检查、技术评审、代码评审、测试等。</li>
<li><strong>故障容忍（fault tolerance，简称“容错”）</strong>：容错是使系统在其某些组件中出现一个或多个故障时能够继续提供服务的能力，尽管该服务可能处于降级级别。容错技术主要是采用<strong>冗余</strong>（<a href="https://en.wikipedia.org/wiki/Redundancy_(engineering)">redundancy</a>）方法来消除故障的影响，冗余的含义是指当系统无故障时取消冗余资源不会影响系统正常运行。</li>
</ul>
<p>系统的资源包括硬件资源、软件资源、信息资源、时间资源，所以冗余区分 4 种方式：</p>
<ul>
<li><strong>硬件冗余</strong>（hardware redundancy）：通过配置额外的硬件组件实现冗余。</li>
<li><strong>软件冗余</strong>（software redundancy）：通过配置额外的软件版本实现冗余，例如 N 版本编程（<a href="https://en.wikipedia.org/wiki/N-version_programming">NVP</a>）。</li>
<li><strong>信息冗余</strong>（information redundancy）：通过对信息中外加一部分信息码或将信息存放在多个内存单元或将信息进行备份等实现冗余，例如循环冗余校验码、数据复制、数据库备份等。</li>
<li><strong>时间冗余</strong>（time redundancy）：多次执行相同的操作（重试）实现冗余，例如多次执行程序或传输数据的多个副本。</li>
</ul>
<p>硬件冗余和软件冗余被合称为结构冗余（structural redundancy）。相对与时间冗余，硬件冗余、软件冗余、信息冗余被合称为空间冗余（space redundancy）。硬件冗余比较常见，而软件冗余相对少见。</p>
<p><strong>应对各种故障的具体典型的可靠性和韧性策略</strong><sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5:1">[5:1]</a></sup><sup class="footnote-ref"><a href="#fn7" id="fnref7:1">[7:1]</a></sup>：</p>
<ul>
<li><strong>硬件和网络故障</strong>：
<ul>
<li>避错：通过提高硬件的<strong>质量</strong>实现避错</li>
<li>容错：通过<strong>冗余</strong>实现容错，具体的措施包括硬件冗余、数据复制（replication）、数据库备份（backup）、重试（retry）等</li>
<li>快恢：自动主备、主从或多活<strong>流量切换</strong></li>
</ul>
</li>
<li><strong>软件 bug</strong>：
<ul>
<li>避错：技术评审、代码评审、测试等实现避错</li>
<li>快恢：通过<strong>重启</strong>处理导致崩溃（<a href="https://en.wikipedia.org/wiki/Crash_%28computing%29">crash</a>）、夯死（<a href="https://en.wikipedia.org/wiki/Hang_%28computing%29">hang</a>）的软件故障，通过<strong>回滚</strong>代码快速修复 bug</li>
</ul>
</li>
<li><strong>人为错误</strong>：包括配置错误和运维操作错误
<ul>
<li>避错：更好的人；消除人为因素，即自动化；预先检测等</li>
<li>快恢：通过<strong>回滚</strong>配置或操作修复错误</li>
</ul>
</li>
<li><strong>服务过载</strong>：典型的是在<strong>大促</strong>期间可能出现服务过载
<ul>
<li>避错：通过提前的<strong>容量规划</strong>（capacity planning）、<strong>压测</strong>（stress testing）实现避错</li>
<li>容错：通过<strong>弹性扩容</strong>（elastic scaling）实现负载均衡，通过<strong>限流</strong>（rate limiting）、<strong>优雅降级</strong>（graceful degradation）来降低负载</li>
</ul>
</li>
<li><strong>依赖服务</strong>：主要策略是<strong>故障隔离</strong>，将故障的影响限制在较小的范围内，避免发生<strong>连锁故障</strong>（<a href="https://en.wikipedia.org/wiki/Cascading_failure">cascading failure</a>）
<ul>
<li>避错：通过<strong>服务功能拆分</strong>、<strong>服务依赖资源隔离</strong>、<strong>服务强弱依赖治理</strong>等实现故障隔离</li>
<li>容错：通过<strong>熔断</strong>（circuit breaker）实现故障隔离，通过快速失败（fail fast）的方式，避免请求大量阻塞，从而保护调用方</li>
</ul>
</li>
</ul>
<p>云环境的硬件基础设施，比如 AWS、Azure、阿里云等，按物理隔离程度区分<strong>可用区</strong>（<a href="https://en.wikipedia.org/wiki/Availability_zone">Availability Zone</a>, AZ）和<strong>地域</strong>（Region，也叫区域）。<strong>地域</strong>指数据中心所在的地理区域，通常按照数据中心所在的城市划分。例如阿里云<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>，华北 1（青岛）地域表示数据中心所在的城市是青岛。<strong>可用区</strong>是指在同一地域内独立的物理分区，每个可用区包含一个或多个数据中心，这些数据中心配置独立电源、冷却和网络。例如阿里云，华北 1（青岛）地域支持 2 个可用区，包括青岛可用区 B 和青岛可用区 C。在同一地域内，可用区与可用区之间内网互通。各可用区之间可以实现故障隔离，即如果一个可用区出现故障，则不会影响其他可用区的正常运行。</p>
<p>按故障的影响范围，可以区分组件级、可用区级和地域级共三个级别的故障，这三个级别故障的具体的容错措施是：</p>
<ul>
<li>组件级故障：实现组件冗余，避免单点故障</li>
<li>可用区级故障：实现跨可用区冗余，复制组件和数据到其他可用区，经典案例是同城灾备、同城双活/多活</li>
<li>地域级故障：实现跨地域冗余，复制组件和数据到其他区域，经典案例是异地灾备、异地双活/多活</li>
</ul>
<p>另外，从故障的<strong>直接原因</strong>角度来看，故障主要由<strong>变更</strong>触发。根据 Google SRE 经验，由变更触发的生产事故占比大概 70%<sup class="footnote-ref"><a href="#fn9" id="fnref9:1">[9:1]</a></sup>。为了提高系统稳定性，Google SRE 总结了<strong>变更管理</strong>（change management）的三点最佳实践：</p>
<ul>
<li>采用渐进式发布机制</li>
<li>迅速而准确地检测到问题的发生</li>
<li>当出现问题时，安全迅速地回退改动</li>
</ul>
<p>阿里将这三点变更管理最佳实践总结概括为简单易记的“<strong>变更三板斧</strong>”，可灰度、可监控、可回滚<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup><sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>。另外一个提高系统稳定性的变更管理最佳实践是，在重保活动等重要事件的时候开启<strong>封版</strong>（<a href="https://en.wikipedia.org/wiki/Freeze_%28software_engineering%29">change freeze</a>）策略，在封版期间除了特殊的紧急发布外禁止生产环境的全部变更。</p>
<p>在<strong>故障响应</strong>（incident response）方面，提高系统稳定性的最核心的目标就是<strong>缩短故障恢复时间（MTTR）</strong>。阿里的稳定性实践是把这个目标量化，提出“1-5-10 故障快恢”目标，1 分钟发现及启动响应，5 分钟定位，10 分钟恢复<sup class="footnote-ref"><a href="#fn21" id="fnref21:1">[21:1]</a></sup><sup class="footnote-ref"><a href="#fn22" id="fnref22:1">[22:1]</a></sup>。阿里的 1-5-10 能力图谱，如下图所示<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>：</p>
<img width="750" alt="阿里“1-5-10 故障快恢”能力图谱" title="阿里“1-5-10 故障快恢”能力图谱" src="https://static.nullwy.me/stability-response-alibaba-1-5-10.png">
<p>类似的，哈啰的故障响应目标是 5-5-10：5 分钟响应、5 分钟定位、10 分钟恢复<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>。</p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>软件架构：架构模式、特征及实践指南，Mark Richards &amp; Neal Ford，2020，<a href="https://book.douban.com/subject/35487561/">豆瓣</a>：第4章 现有的架构特征 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>系统论：系统科学哲学，曾国屏、魏宏森，1995，<a href="https://book.douban.com/subject/1008370/">豆瓣</a>：第三篇 系统论的基本原理，15 系统稳定性原理 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>SRE原理与实践：构建高可靠性互联网应用，张观石，2022，<a href="https://book.douban.com/subject/36202918/">豆瓣</a>：第1章 互联网软件可靠性概论 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a> <a href="#fnref3:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>阿里云卓越架构：卓越运营支柱：故障管理：故障等级定义的制定和录入 <a href="https://help.aliyun.com/document_detail/2536143.html">https://help.aliyun.com/document_detail/2536143.html</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2022-06 中国信通院：分布式系统稳定性建设指南（2022年） <a href="http://www.caict.ac.cn/kxyj/qwfb/ztbg/202206/t20220620_404604.htm">http://www.caict.ac.cn/kxyj/qwfb/ztbg/202206/t20220620_404604.htm</a> <a href="https://mp.weixin.qq.com/s/OkG3_pjtaQcB-cOupCNe-w">https://mp.weixin.qq.com/s/OkG3_pjtaQcB-cOupCNe-w</a> <a href="#fnref5" class="footnote-backref">↩︎</a> <a href="#fnref5:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>AWS Well-Architected Framework: Concepts: Resiliency <a href="https://wa.aws.amazon.com/wellarchitected/2020-07-02T19-33-23/wat.concept.resiliency.en.html">https://wa.aws.amazon.com/wellarchitected/2020-07-02T19-33-23/wat.concept.resiliency.en.html</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2022-01 Microsoft Azure 韧性白皮书（Resilience in Azure whitepaper） <a href="https://www.modb.pro/doc/109965">https://www.modb.pro/doc/109965</a> <a href="https://web.archive.org/web/0/https://azure.microsoft.com/en-us/resources/resilience-in-azure-whitepaper/">https://web.archive.org/web/0/https://azure.microsoft.com/en-us/resources/resilience-in-azure-whitepaper/</a> <a href="#fnref7" class="footnote-backref">↩︎</a> <a href="#fnref7:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Google 构建安全可靠的系统，2021，<a href="https://book.douban.com/subject/35585206/">豆瓣</a>：第8章 弹性设计 <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>SRE：Google运维解密，Beyer, etc. 2016，<a href="https://book.douban.com/subject/26875239/">豆瓣</a>、<a href="https://sre.google/sre-book/table-of-contents/">英文版</a> <a href="#fnref9" class="footnote-backref">↩︎</a> <a href="#fnref9:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>The Art of Site Reliability Engineering (SRE) with Azure, Unai Huete Beloki, 2022, <a href="https://link.springer.com/book/10.1007/978-1-4842-8704-0">springer</a>: Chapter 1: The Foundation of Site Reliability Engineering <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Microsoft Azure: Site reliability engineering documentation <a href="https://learn.microsoft.com/en-us/azure/site-reliability-engineering/">https://learn.microsoft.com/en-us/azure/site-reliability-engineering/</a> <a href="#fnref11" class="footnote-backref">↩︎</a> <a href="#fnref11:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Becoming a Rockstar SRE, Proffitt &amp; Anami, 2023, <a href="https://www.packtpub.com/product/becoming-a-rockstar-sre/9781803239224">packtpub</a>: Chapter 1: SRE Job Role – Activities and Responsibilities <a href="#fnref12" class="footnote-backref">↩︎</a> <a href="#fnref12:1" class="footnote-backref">↩︎</a> <a href="#fnref12:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>The Art of Site Reliability Engineering (SRE) with Azure, Unai Huete Beloki, 2022, <a href="https://link.springer.com/book/10.1007/978-1-4842-8704-0">springer</a>: Chapter 4: Architecting Resilient Solutions in Azure, 4.1 What Is Resiliency?: Figure 4-1. Customized hierarchy of reliability <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>2016-03 Amazon CTO Werner Vogels: 10 Lessons from 10 Years of Amazon Web Services <a href="https://www.allthingsdistributed.com/2016/03/10-lessons-from-10-years-of-aws.html">https://www.allthingsdistributed.com/2016/03/10-lessons-from-10-years-of-aws.html</a> <a href="https://aws.amazon.com/cn/blogs/china/10-lessons-from-10-years-of-aws/">https://aws.amazon.com/cn/blogs/china/10-lessons-from-10-years-of-aws/</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>2010-01 Jinesh Varia: Architecting for the Cloud: Best Practices (AWS whitepaper) <a href="https://web.archive.org/web/0/https://aws.amazon.com/blogs/aws/new-whitepaper-architecting-for-the-cloud-best-practices/">https://web.archive.org/web/0/https://aws.amazon.com/blogs/aws/new-whitepaper-architecting-for-the-cloud-best-practices/</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>2010-04 Jinesh Varia: Architecting for the Cloud: Best Practices <a href="https://www.slideshare.net/AmazonWebServices/aws-architectingdesantislondon">https://www.slideshare.net/AmazonWebServices/aws-architectingdesantislondon</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>2015-10 The AWS Well-Architected Framework <a href="https://www.infoq.com/news/2015/10/aws-well-architected-framework/">https://www.infoq.com/news/2015/10/aws-well-architected-framework/</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>数据中心一体化最佳实践，Barroso, Hölzle, Ranganathan，第3版2018，<a href="https://book.douban.com/subject/34950732/">豆瓣</a>：第7章 故障处理与维修 <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>云系统管理：大规模分布式系统设计与运营，<a href="https://en.wikipedia.org/wiki/Tom_Limoncelli">Tom Limoncelli</a>，2014，<a href="https://book.douban.com/subject/26865122/">豆瓣</a>：第6章 弹性设计模式 <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>阿里云：地域和可用区 <a href="https://help.aliyun.com/document_detail/40654.html">https://help.aliyun.com/document_detail/40654.html</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>2020-03 阿里陈鑫：阿里巴巴DevOps文化浅谈 <a href="https://mp.weixin.qq.com/s/h-F8dopr23pgvSoXjWfE8A">https://mp.weixin.qq.com/s/h-F8dopr23pgvSoXjWfE8A</a> <a href="#fnref21" class="footnote-backref">↩︎</a> <a href="#fnref21:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>阿里云卓越架构：稳定性支柱：稳定性设计方案 <a href="https://help.aliyun.com/document_detail/2573820.html">https://help.aliyun.com/document_detail/2573820.html</a> <a href="#fnref22" class="footnote-backref">↩︎</a> <a href="#fnref22:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>2021-05 阿里暴晓亚若厉：阿里巴巴GOC稳定性保障介绍（slides, 26p） <a href="https://www.modb.pro/doc/31443">https://www.modb.pro/doc/31443</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>2022-04 哈啰技术：稳定性建设系列文章1_大纲&amp;方法论 <a href="https://segmentfault.com/a/1190000041671012">https://segmentfault.com/a/1190000041671012</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>可靠性</tag>
        <tag>SRE</tag>
        <tag>稳定性</tag>
        <tag>韧性</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 和 Kafka 的数据分片和复制策略</title>
    <url>/2024/01/rocketmq-kafka-sharding-replication/</url>
    <content><![CDATA[<p>为了提升系统的<strong>可扩展性</strong>（scalability），分布式数据库或分布式存储系统通常支持数据<strong>分区</strong>（partitioning）或<strong>分片</strong>（sharding），即将完整的数据拆分存放在多个服务器节点上，拆分后的部分数据称为“partition”或“<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">shard</a>”。数据被拆分后多个服务器节点能分摊负载压力，从而提升系统性能。“分区”和分片”，这两个术语，在很多情况下不区分，可以混用。如果严格区分的话，<strong>分片</strong>拆分的数据分布在多个服务器节点上，而<strong>分区</strong>拆分的数据在单个服务器节点。另外，<strong>复制</strong>（<a href="https://en.wikipedia.org/wiki/Replication_%28computing%29">replication</a>）也典型的分布式技术，多个数据副本能实现读请求的负载均衡，提升系统性能。同时复制也提供了冗余容错的能力，提升系统的<strong>可用性</strong>（availability）。本文关注消息中间件的消息存储系统，解析并对比 RocketMQ 和 Kafka 的消息数据的分片和复制的具体实现策略。</p>
<span id="more"></span>
<p>MySQL 等传统关系数据库支持<strong>表分区</strong>（<a href="https://dev.mysql.com/doc/refman/8.0/en/partitioning.html">partition</a>），但原生不支持<strong>分片</strong>（sharding），拆分后的表分区都分布在同一个服务器节点上。为了解决数据库的水平扩展问题，出现很多数据库分片方案。其中一类是基于传统关系数据库的“分库分表”中间件，如 <a href="https://github.com/vitessio/vitess">Vitess</a>、<a href="https://github.com/apache/shardingsphere">ShardingSphere</a>、阿里 TDDL 和 DRDS 等。另外一类是非关系型的 <a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a> 数据库，如 BigTable、Dynamo、HBase、Cassandra 等。以及采用全新架构的 <a href="https://en.wikipedia.org/wiki/NewSQL">NewSQL</a> 数据库，如 Google Spanner、CockroachDB、TiDB 等；或基于云服务的 NewSQL 数据库，如 Amazon Aurora、阿里 PolarDB 等。</p>
<p>术语分片（shard）或分区（partition），在具体的不同系统下有着不同的称呼，例如它对应于 MongoDB、Elasticsearch 和 SolrCloud 中的 <code>shard</code>，HBase 中的 <code>region</code>，Bigtable 中的 <code>tablet</code>，Cassandra 和 Riak 中的 <code>vnode</code>，以及 Couchbase 中 的 <code>vBucket</code>。总体而言，分片和分区使用最普遍。</p>
<p>分布式数据库不是本文关注的主题，不再展开。消息中间件的消息存储系统与分布式数据库系统类似，为了系统可扩展性和可用性，也需要支持数据分片和复制特性。</p>
<h1 id="历史演进时间线">历史演进时间线</h1>
<p>RocketMQ 和 Kafka 的历史演进时间线：</p>
<ul>
<li>2007，淘宝自研 Notify，最早底层的消息存储采用本地文件存储，参考 ActiveMQ 实现了单机 kv 存储引擎，2008 年底层的消息存储改用 Oracle，2010 年从 Oracle 迁移到高可用 MySQL 存储集群<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</li>
<li><a href="https://www.linkedin.com/blog/member/archive/open-source-linkedin-kafka">2011.01</a>，LinkedIn 公司在 Github 上开源 Kafka 项目，项目地址 kafka-dev/<a href="https://github.com/kafka-dev/kafka">kafka</a>。
<ul>
<li>同年，淘宝基于 Kafka 的设计用 Java 完全重写并内部发布 MetaQ 1.0。</li>
</ul>
</li>
<li>2011.07，Kafka 成为 Apache 孵化器项目。</li>
<li><a href="https://www.infoq.cn/article/2012/03/metamorphosis">2012.03</a>，淘宝对外开源 MetaQ 1.x，项目名为 Metamorphosis（<a href="https://web.archive.org/web/20120312015328/http://code.taobao.org/p/metamorphosis/wiki/intro/">淘蝌蚪</a>、<a href="https://github.com/killme2008/Metamorphosis">GitHub</a>），版本号为 1.4.0。
<ul>
<li>Metamorphosis <a href="https://web.archive.org/web/20120312015318/http://code.taobao.org/p/metamorphosis/wiki/changelist/">1.0.1</a> 开始实现高可用的 HA 方案，支持同步和异步复制，复制特性类似于 MySQL 的主从复制。</li>
<li>Kafka 的复制特性，直到 2013.12 发布的 0.8.0 版本才开始支持。Kafka 实现的复制是集群间的分区复制（Intra-cluster Replication），复制的副本粒度是分区（partition），参见 <a href="https://issues.apache.org/jira/browse/KAFKA-50">KAFKA-50</a>。</li>
</ul>
</li>
<li>2012.09，淘宝内部发布 MetaQ 2.0 版本，MetaQ 2.0 对架构进行了重新设计，为了解决分区文件数增加后的性能下降问题，对消息日志文件存储目录结构做了改造<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。改造后的 MetaQ 架构与 Kafka 存在很大差异，这个版本的 MetaQ 可以认为是第一代的 RocketMQ。</li>
<li>2012.10，Kafka 从孵化器项目毕业，成为 Apache 顶级项目。</li>
<li>2013.07，淘宝内部发布 MetaQ 3.0 版本。</li>
<li>2013.09，淘宝对外开源发布 RocketMQ 3.0，项目地址 alibaba/<a href="https://web.archive.org/web/20170506102903/https://github.com/alibaba/RocketMQ">RocketMQ</a>。RocketMQ 3.0 和 MetaQ 3.0 等价，阿里内部使用的称为 MetaQ 3.0，外部开源称之为 RocketMQ 3.0<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</li>
<li>2013.12，Kafka 发布版本 0.8.0，开始支持集群间的分区复制。</li>
<li><a href="https://www.oschina.net/news/89061">2016.11</a>，RocketMQ 成为 Apache 孵化器项目。</li>
<li><a href="https://www.oschina.net/news/89061">2017.09</a>，RocketMQ 从孵化器毕业，正式成为 Apache 顶级项目。</li>
<li><a href="https://www.oschina.net/news/105805">2019.04</a>，RocketMQ 4.5 发布，开始支持 Borker 节点的自动选主，实现自动故障转移，自动选主模块被命名为 DLedger，DLedger 是基于 Raft 协议实现的轻量级 <a href="https://github.com/openmessaging/dledger/wiki">Java Library</a>，被集成到各个 Borker 节点的进程中。</li>
<li>2019.10，Kafka 社区开始尝试用基于 Raft 的控制器替换基于 ZooKeeper 的控制器，新控制器叫作 KRaft，KRaft 模块被集成到 Borker 节点的进程中，去掉了对 ZooKeeper 的依赖，简化了整体架构，具体参见 <a href="https://issues.apache.org/jira/browse/KAFKA-9119">KIP-500</a>。
<ul>
<li>2021.04，Kafka 2.8 发布，KRaft 模式的早期访问版可用。</li>
<li>2022.10，Kafka 3.3 发布，KRaft 模式被标记为生产环境可用。</li>
<li>2023.06，Kafka 3.5 发布，ZooKeeper 模式被标记为废弃，计划在 Kafka 4.0 删除。</li>
</ul>
</li>
<li>2022.09，RocketMQ 5.0 发布，自动选主开始支持 DLedger Controller 模式，Controller 可以独立部署，也可以嵌入在 Nameserver 中，具体参见 <a href="https://github.com/apache/rocketmq/wiki/RIP-44-Support-DLedger-Controller">RIP-44</a>。</li>
</ul>
<h1 id="RocketMQ">RocketMQ</h1>
<p><strong>RocketMQ 的数据分片和复制策略</strong><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>：</p>
<ul>
<li><strong>分片策略</strong>：
<ul>
<li><strong>分片术语命名</strong>：<a href="https://rocketmq.apache.org/zh/docs/domainModel/03messagequeue/">消息队列</a>（message queue）
<ul>
<li>将单个 Topic 的消息日志拆分到多个消息队列中。</li>
</ul>
</li>
<li><strong>键-分片的分配关系</strong>：默认轮询（round-robin）分配
<ul>
<li>默认按 Topic 消息的写入次序轮询分配给各个消息队列，也可以自定义消息队列选择器（MessageQueueSelector）。</li>
<li>相关源码：DefaultMQProducerImpl#<a href="https://github.com/apache/rocketmq/blob/rocketmq-all-4.9.0/client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java#L554">sendDefaultImpl</a>、DefaultMQProducerImpl#<a href="https://github.com/apache/rocketmq/blob/rocketmq-all-4.9.0/client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java#L1134">sendSelectImpl</a></li>
</ul>
</li>
<li><strong>分片-机器的分配关系</strong><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：可配置某 Topic 在某 Borker 服务器节点的消息队列数。
<ul>
<li>若发送消息时自动创建 Topic，配置项 <code>autoCreateTopicEnable</code> 开启，会在发送消息时轮询选择其中一台 Master Borker，在该 Borker 上分配消息队列。消息队列数由全局配置项 <code>defaultTopicQueueNums</code> 控制，默认值 <code>4</code>。
<ul>
<li>相关源码：MQClientInstance#<a href="https://github.com/apache/rocketmq/blob/rocketmq-all-4.9.0/client/src/main/java/org/apache/rocketmq/client/impl/factory/MQClientInstance.java#L605">updateTopicRouteInfoFromNameServer</a>、AbstractSendMessageProcessor#<a href="https://github.com/apache/rocketmq/blob/rocketmq-all-4.9.0/broker/src/main/java/org/apache/rocketmq/broker/processor/AbstractSendMessageProcessor.java#L166">msgCheck</a>、TopicConfigManager#<a href="https://github.com/apache/rocketmq/blob/rocketmq-all-4.9.0/broker/src/main/java/org/apache/rocketmq/broker/topic/TopicConfigManager.java#L156">createTopicInSendMessageMethod</a></li>
</ul>
</li>
<li>若预先手动创建 Topic，执行 <code>mqadmin updateTopic</code> 命令，可以通过命令行参数指定在某个 Master Borker 上分配消息队列。也可以通过命令行参数指定 cluster，在 cluster 下的全部的 Master Borker 上分配消息队列，每个 Borker 的消息队列的数量相同。默认队列数 <code>8</code>。
<ul>
<li>相关源码：<a href="https://github.com/apache/rocketmq/blob/rocketmq-all-4.9.0/tools/src/main/java/org/apache/rocketmq/tools/command/topic/UpdateTopicSubCommand.java#L90">UpdateTopicSubCommand</a></li>
</ul>
</li>
<li>Topic 的消息队列的主副本分布在各个 Master Borker，某 Topic 的分区总数量是该 Topic 分布在各个 Master Borker 上的消息队列的数量的总和。</li>
</ul>
</li>
<li><strong>分片再均衡策略</strong>：手动再均衡
<ul>
<li>在扩容添加新 Broker 节点后，在创建新 Topic 时，可以自动或指定在新 Broker 节点上分配消息队列，而旧的 Topic 也可以通过执行 <code>mqadmin updateTopic</code> 命令，在新的 Broker 节点上分配消息队列。</li>
</ul>
</li>
</ul>
</li>
<li><strong>复制策略</strong>：主从（Master/Slave）模式，类似于 MySQL 的主从复制。Borker 节点分为主从（Master/Slave）两种角色，由一个 Master Borker 和零到多个 Slave Borker 组成复制组，复制组内的 Broker 数据保持同步。
<ul>
<li><strong>复制单位</strong>：以机器为单位</li>
<li><strong>复制系数</strong>：即复制组内的服务器节点数量</li>
<li><strong>副本更新传播策略</strong>：支持异步复制（默认）和同步复制两种复制模式。配置项 <code>brokerRole</code> 用于配置节点的主从角色和复制模式，默认值为 <code>ASYNC_MASTER</code>，可配置为 <code>SYNC_MASTER</code>/<code>ASYNC_MASTER</code>/<code>SLAVE</code>。</li>
<li><strong>消息可靠性</strong><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>：主要影响的配置项是主从节点的副本复制方式和磁盘刷盘方式。
<ul>
<li>对于 <code>Borker</code> 单点故障情况，若采用主从异步复制，可保证 99% 的消息不丢，但是仍然会有极少量的消息可能丢失。若采用主从同步复制可以完全避免单点，但相对损失影响性能，适合对消息可靠性要求极高的场合。</li>
<li>配置项 <code>FlushDiskType</code> 用于控制磁盘刷盘方式，可配置为异步刷盘 <code>ASYNC_FLUSH</code>（默认）和同步刷盘 <code>SYNC_FLUSH</code>。同步刷盘会损失很多性能，但是也更可靠。</li>
<li>生产环境下的<strong>推荐配置</strong>是<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>，把主从节点的磁盘刷盘方式都配置为<strong>异步刷盘</strong>，主从节点之间复制方式配置为<strong>同步复制</strong>，这种配置方式是相对兼顾了性能和可靠性。如果对消息丢失零容忍，则建议配置为同步复制、同步刷盘方式。</li>
<li>对于副本系统来说，在系统设计或配置时，必须要在副本一致性和延迟（性能）之间做<strong>权衡</strong>，参见 <a href="https://en.wikipedia.org/wiki/PACELC_theorem">PACELC</a> 理论（CAP 理论的扩展版）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>请求路由寻址</strong>：Master Borker 可写可读，Slave Borker 不可写、默认不可读，仅用于备份
<ul>
<li><strong>读写分离</strong><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>：配置项 <code>slaveReadEnable</code> 用于配置是否允许消息从从节点读取，默认 <code>false</code>。如果 <code>slaveReadEnable=true</code>，并且当前消息堆积量超过物理内存 40%（由配置项 <code>accessMessageInMemoryMaxRatio</code> 控制），则建议从 Slave Borker 拉取消息，否则还是从 Master Borker 拉取消息。
<ul>
<li>相关源码：PullMessageProcessor#<a href="https://github.com/apache/rocketmq/blob/rocketmq-all-4.9.0/broker/src/main/java/org/apache/rocketmq/broker/processor/PullMessageProcessor.java#L266">processRequest</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>集群配置和协调</strong>：由 NameServer 集群和 DLedger 模块负责
<ul>
<li>NameServer 集群负责存储消息队列路由信息、Borker 集群注册信息等元数据，是 ZooKeeper 的轻量级替代。</li>
<li><strong>自动选举主节点</strong><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup><sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>：
<ul>
<li><strong>Raft 模式</strong>：RocketMQ 4.5 开始，DLedger 模块被集成到各个 Borker 节点的进程中，用于 Borker 节点的自动选主，实现自动故障转移，自动选主基于 Raft 协议。</li>
<li><strong>Controller 模式</strong>：RocketMQ 5.0 开始，自动选主支持 DLedger Controller 模式，Controller 可以独立部署，也可以嵌入在 Nameserver 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>RocketMQ 架构，以及各个 Borker 下的分区和副本分布示例，如下图所示：</p>
<img width="800" alt="RocketMQ 架构与分区和副本分布示例" title="RocketMQ 架构与分区和副本分布示例" src="https://static.nullwy.me/rocketmq-architecture.png">
<h1 id="Kafka">Kafka</h1>
<p><strong>Kafka 的数据分片和复制策略</strong><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup><sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>：</p>
<ul>
<li><strong>分片策略</strong>：
<ul>
<li><strong>分片术语命名</strong>：分区（partition）
<ul>
<li>将单个 Topic 的消息日志拆分到多个分区</li>
</ul>
</li>
<li><strong>键-分片的分配关系</strong>：按 Hash 拆分或轮询分配。
<ul>
<li>若消息 key 有值，按 key 的 Hash 值拆分；若消息 key 值为 null 时，轮询分配给各个分。也可以自定义分区策略。Hash 拆分具体实现是，根据 murmur2 算法计算消息 key 的 Hash 值，然后对总分区数求模得到消息要被发送到的目标分区号。
<ul>
<li>相关源码：<a href="https://github.com/apache/kafka/blob/2.3.0/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java">DefaultPartitioner</a>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>分片-机器的分配关系</strong>：可配置某 Topic 的分区总数量。
<ul>
<li>在创建 Topic 时把各个分区和分区副本<strong>轮询分配</strong>给各个 Broker 节点。分配的目标是尽量让各个分区和分区副本分布在不同的 Broker 节点上。举例来说，假设 Topic 的分区数为 2，复制系数为 3。给某 Topic 分配 Broker 节点，先随机选择一个 Broker（假设是 Broker0），然后使用轮询的方式给每个 Broker 分配分区 leader。于是，partition0 的 leader 在 Broker0 上，partition1 的 leader 在 Broker1 上。接下来，依次分配 follower 副本。如果 partition0 的 leader 在 Broker0 上，那么它的第一个 follower 副本就在 Broker1 上，第二个跟随者副本就在 Broker2 上。如果 partition1 的 leader 在 Broker1 上，那么它的第一个 follower 副本就在 Broker2 上，第二个跟随者副本在 Broker3 上。如下图的 <code>topic1</code> 的分区和分区副本的分布。
<ul>
<li>相关源码：AdminUtils#<a href="https://github.com/apache/kafka/blob/3.6.1/server-common/src/main/java/org/apache/kafka/admin/AdminUtils.java#L46">assignReplicasToBrokers</a></li>
</ul>
</li>
<li>若发送消息时自动创建 Topic，由配置项 <code>num.partitions</code> 控制 Topic 的默认分区总数量，默认值 <code>1</code>。</li>
<li>若预先手动创建 Topic，执行 <code>kafka-topics.sh --create</code> 命令，由 <code>--partitions</code> 命令行参数控制该 Topic 的分区总数量。</li>
</ul>
</li>
<li><strong>分片再均衡策略</strong>：手动再均衡
<ul>
<li>在扩容添加新 Broker 节点后，新的分区和分区副本能自动分配到新的 Broker 节点上，但已有的旧分区和节点的分配关系的固定的。如果要让旧的分区和分区副本能分配新的 Broker 节点，需要手动执行分区重分配命令 <code>kafka-reassign-partitions.sh</code>。
<ul>
<li>相关源码：<a href="https://github.com/apache/kafka/blob/3.7.0-rc2/tools/src/main/java/org/apache/kafka/tools/reassign/ReassignPartitionsCommand.java">ReassignPartitionsCommand</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>复制策略</strong>：
<ul>
<li><strong>复制单位</strong>：以分区为单位</li>
<li><strong>复制系数</strong>：
<ul>
<li>自动创建 Topic 时，由配置项 <code>default.replication.factor</code> 全局控制 Topic 的默认副本个数，默认值 <code>1</code>。</li>
<li>手动创建 Topic 时，执行 <code>kafka-topics.sh --create</code> 命令，由 <code>--replication-factor</code> 命令行参数控制该 Topic 的分区副本的复制系数。</li>
<li>复制系数必须等于或小于可用 Broker 节点数，如果大于可用 Broker 节点数，在创建 Topic 时会报异常。</li>
<li>推荐的复制系数的配置值是 &gt;= 3，通常配置为 <code>3</code>。复制系数配置为 &gt;= 3 的原因是，允许集群内同时发生一次计划内停机和一次计划外停机，配置为 <code>3</code> 是在避免消息丢失和过度复制之间的常见的权衡选择。HBase（基于 HDFS）和 Cassandra 等分布式存储系统默认的复制系数也是 <code>3</code>。</li>
</ul>
</li>
<li><strong>副本更新传播策略</strong>：副本分为主从（leader-follower）两种角色，一个 leader，零到多个 follower。复制策略类似于微软的 PacificA 复制协议，Elasticsearch 的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.12/docs-replication.html">分片复制</a>也采用 PacificA 协议。
<ul>
<li>Kafka 动态维护<strong>同步副本集合</strong>（in-sync replica set），简称 <strong>ISR 集合</strong>。如果一个 follower 副本落后 leader 的时间超过 <code>replica.lag.time.max.ms</code> 配置值（Kafka 2.5 开始从默认 10 秒改为 30 秒），那么该 follower 副本会被认为是“不同步副本”（out-of-sync replica，OSR），会被移除 ISR 集合。在消息 commit 之前必须保证 ISR 集合中的全部节点都完成同步复制。这种机制确保了只要 ISR 中有一个或者以上的 follower，一条被 commit 的消息就不会丢失。ISR 集合大小由 Broker 端的配置项 <code>min.insync.replicas</code> 控制，默认值 <code>1</code>，即只需要 leader。</li>
<li>Producer 端的配置项 <code>acks</code>，用于控制在确认一个请求发送完成之前需要收到的反馈信息的数量。<code>min.insync.replicas</code> 配置项只有在 <code>acks=all</code> 时才生效。
<ul>
<li><code>acks=0</code>：表示 Producer 不等待 Broker 返回确认消息。</li>
<li><code>acks=1</code>（Kafka &lt; v3.0 默认）：表示 leader 节点会将记录写入本地日志，并且在所有 follower 节点反馈之前就先确认成功。</li>
<li><code>acks=all</code>（Kafka &gt;= v3.0 默认）：表示 leader 节点会等待所有同步中的副本（ISR集合）确认之后再确认这条记录是否发送完成。</li>
</ul>
</li>
<li>与异步复制、半同步复制、同步复制的对应关系：
<ul>
<li>当 <code>acks=0</code> 或 <code>acks=1</code> 时，相当于<strong>异步复制</strong>。</li>
<li>当 <code>acks=all</code> 并且 <code>min.insync.replicas</code> 值大于 <code>1</code> 并小于 Broker 节点总数时，相当于<strong>半同步复制</strong>。</li>
<li>当 <code>acks=all</code> 并且 <code>min.insync.replicas</code> 值等于 Broker 节点总数时，相当于<strong>全同步复制</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>消息可靠性</strong>：
<ul>
<li>优先考虑消息可靠性（无消息丢失）又同时兼顾性能的常用的配置是，复制系数的配置值为 <code>3</code>，ISR 集合大小的配置值为 <code>min.insync.replicas=2</code>，消息发送确认的配置值为 <code>acks=all</code><sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup><sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>。</li>
<li>Kafka 默认异步刷盘，没有直接的同步刷盘相关配置项。Kafka 会在重启之前和关闭日志片段（默认 1 GB 大小时关闭）时将消息冲刷到磁盘上，或者等到 Linux 系统页面缓存被填满时冲刷。虽然 Kafka 提供刷盘的时间间隔和刷盘的消息条数的配置项，但是官方文档不建议设置，推荐将刷盘的工作交给操作系统完成<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>。相对于刷盘，复制提供了更强的可靠性保障。</li>
</ul>
</li>
</ul>
</li>
<li><strong>请求路由寻址</strong>：leader 副本可写可读，follower 副本不可写、默认不可读，仅用于备份
<ul>
<li><strong>读写分离</strong>：
<ul>
<li>Kafka 2.4 之前，leader 副本可写可读，follower 副本不可写、不可读，仅用于备份。消息消费者只允许读取 leader 副本，follower 副本不处理来自消费者的请求。当 leader 所在的节点发生崩溃，其中一个 follower 就会被 Controller 选举为新 leader。</li>
<li>Kafka 2.4 开始（2019.12 发布）支持读取 follower 副本来消费消息，参见 <a href="https://issues.apache.org/jira/browse/KAFKA-8443">KIP-392</a>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>集群配置和协调</strong>：由 <strong>Controller 控制器</strong>负责
<ul>
<li><strong>ZooKeeper 模式</strong><sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>：ZooKeeper 负责存储元数据，包括 Broker、Topic、分区、副本、路由等信息，以及负责选举 Controller 角色的 Broker，整个集群只有一个 Controller 角色的 Broker。Controller 角色的 Broker 节点的主要职责是 Broker 集群成员管理、Topic 管理（创建、删除、增加分区）、分区重分配、选举新的分区 leader 副本等，这些职责的实现重度依赖 ZooKeeper。</li>
<li><strong>KRaft 模式</strong><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>：Kafka 2.8 开始，Kafka 开始用基于 Raft 的控制器替换基于 ZooKeeper 的控制器，新控制器叫作 KRaft。KRaft 模块被集成在 Borker 节点的进程中，去掉了对 ZooKeeper 的依赖，简化了整体架构。</li>
</ul>
</li>
</ul>
<p>Kafka 在 ZooKeeper 模式下的架构图，以及各个 Borker 下的分区和副本分布示例，如下图所示：</p>
<img width="800" alt="Kafka 架构与分区和副本分布示例" title="Kafka 架构与分区和副本分布示例" src="https://static.nullwy.me/kafka-architecture.png">
<p>Kafka 在 KRaft 模式下的架构图，如下图所示<sup class="footnote-ref"><a href="#fn18" id="fnref18:1">[18:1]</a></sup>：</p>
<img width="600" alt="Kafka 的 KRaft 模式" title="Kafka 的 KRaft 模式" src="https://static.nullwy.me/kafka-kraft-mode.png">
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>2017-11 阿里林清山隆基：阿里消息中间件架构演进之路：notify和metaq <a href="https://zhuanlan.zhihu.com/p/302600352">https://zhuanlan.zhihu.com/p/302600352</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>2013-07 淘宝张乐伟韩彰：淘宝消息中间件技术演变：MetaQ 1.0、MetaQ 2.0、MetaQ 3.0（slides, 30p）<a href="https://www.modb.pro/doc/109298">https://www.modb.pro/doc/109298</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2017-03 阿里冯嘉鼬神：Apache RocketMQ背后的设计思路与最佳实践 <a href="https://developer.aliyun.com/article/71889">https://developer.aliyun.com/article/71889</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Apache RocketMQ 4.9.x开发者指南 <a href="https://github.com/apache/rocketmq/blob/4.9.x/docs/cn">https://github.com/apache/rocketmq/blob/4.9.x/docs/cn</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2019-03 张乘辉：深度解析RocketMQ Topic的创建机制 <a href="https://objcoding.com/2019/03/31/rocketmq-topic/">https://objcoding.com/2019/03/31/rocketmq-topic/</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Apache RocketMQ 4.9.x开发者指南：特性：4 消息可靠性 <a href="https://github.com/apache/rocketmq/blob/4.9.x/docs/cn/features.md">https://github.com/apache/rocketmq/blob/4.9.x/docs/cn/features.md</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2016-04 Kafka vs RocketMQ——单机系统可靠性 <a href="https://web.archive.org/web/0/http://jm.taobao.org/2016/04/28/kafka-vs-rocktemq-4">https://web.archive.org/web/0/http://jm.taobao.org/2016/04/28/kafka-vs-rocktemq-4</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>2018-12 How much memory should we use for broker and namesrv when using cluster mode? #614 <a href="https://github.com/apache/rocketmq/issues/614">https://github.com/apache/rocketmq/issues/614</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>2019-09 张乘辉：RocketMQ主从读写分离机制 <a href="https://objcoding.com/2019/09/22/rocketmq-read-write-separation/">https://objcoding.com/2019/09/22/rocketmq-read-write-separation/</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>2019-08 金融通、武文良：RocketMQ 实现高可用多副本架构的关键：DLedger—基于raft协议的commitlog存储库 <a href="https://mp.weixin.qq.com/s/0nmWq29FN17vNzt0njRE-Q">https://mp.weixin.qq.com/s/0nmWq29FN17vNzt0njRE-Q</a> <a href="https://www.infoq.cn/article/7xeJrpDZBa9v*GDZOFS6">https://www.infoq.cn/article/7xeJrpDZBa9v*GDZOFS6</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>2022-09 金融通：RocketMQ 5.0：面向消息与流的云原生高可用架构 <a href="https://mp.weixin.qq.com/s/bb6cGUxpsAoU-IqBgmSJHw">https://mp.weixin.qq.com/s/bb6cGUxpsAoU-IqBgmSJHw</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Kafka 2.8 权威指南，第2版2021，<a href="https://book.douban.com/subject/36161660/">豆瓣</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Kafka 文档 <a href="https://kafka.apachecn.org/">https://kafka.apachecn.org/</a> <a href="https://kafka.apache.org/36/documentation.html">https://kafka.apache.org/36/documentation.html</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Optimize Confluent Cloud Clients for Durability <a href="https://docs.confluent.io/cloud/current/client-apps/optimizing/durability.html">https://docs.confluent.io/cloud/current/client-apps/optimizing/durability.html</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>2019-06 胡夕：Kafka 2.3 核心技术与实战：11 | 无消息丢失配置怎么实现？ <a href="https://time.geekbang.org/column/article/102931">https://time.geekbang.org/column/article/102931</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Kafka Documentation: Application vs. OS Flush Management <a href="https://kafka.apache.org/36/documentation.html#appvsosflush">https://kafka.apache.org/36/documentation.html#appvsosflush</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>2019-08 胡夕：Kafka 2.3 核心技术与实战：26 | 你一定不能错过的Kafka控制器（Controller） <a href="https://time.geekbang.org/column/article/111339">https://time.geekbang.org/column/article/111339</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2022-04 Jun Rao: The Apache Kafka Control Plane (ZooKeeper vs. KRaft) <a href="https://developer.confluent.io/courses/architecture/control-plane/">https://developer.confluent.io/courses/architecture/control-plane/</a> <a href="#fnref18" class="footnote-backref">↩︎</a> <a href="#fnref18:1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>可扩展性</tag>
        <tag>分布式</tag>
        <tag>可靠性</tag>
        <tag>可伸缩性</tag>
        <tag>中间件</tag>
        <tag>RocketMQ</tag>
        <tag>Kafka</tag>
        <tag>可用性</tag>
      </tags>
  </entry>
</search>
