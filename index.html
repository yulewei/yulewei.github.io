<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png">
  <link rel="mask-icon" href="/favicon.png" color="#222">
  <meta name="baidu-site-verification" content="qxFtDn0ziX">
  <meta name="sogou_site_verification" content="Wj1N74IImQ" /> 

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nullwy.me","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullwy&#39;s blog">
<meta property="og:url" content="https://nullwy.me/index.html">
<meta property="og:site_name" content="nullwy&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="nullwy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://nullwy.me/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>nullwy's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4LE29KVMN"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Y4LE29KVMN');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?928b3d50428cc362a2d2ed846517583e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="nullwy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">nullwy's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2024/02/java-synchronization-implementation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/java-synchronization-implementation/" class="post-title-link" itemprop="url">Java 线程同步实现原理深度解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-10 15:58:00" itemprop="dateCreated datePublished" datetime="2024-02-10T15:58:00+08:00">2024-02-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2024/02/java-synchronization-implementation/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/02/java-synchronization-implementation/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于 Java 线程同步的实现原理，官方有很多介绍资料[<sup>1][</sup>2][<sup>3][</sup>4][<sup>5][</sup>6]，值得阅读。</p>
<h1 id="基础概念">基础概念</h1>
<p>在并发编程模型中，需要处理的两个最关键的问题就是<strong>通信</strong>（communication）和<strong>同步</strong>（synchronization）。通信指线程可用于获得其他线程产生的信息的各种机制。通信机制通常都基于<strong>共享内存</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_memory">shared memory</a>）或<strong>消息传递</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Message_passing">message passing</a>）。在共享内存的编程模型中，某些或全部程序变量可以由多个线程访问。如果一对线程之间需要通信，只要一个线程将值写入某个变量，另一线程来读它即可。在消息传递编程模型中，不同线程没有公共的状态。当一对线程之间需要通信时，其中的一个必须执行一次明确的 send 操作，将数据传送给另一个线程。</p>
<p>同步[^1]是控制不同线程之间操作发生的相对顺序的各种机制，用以排除导致不正确结果的交错。消息传递模型中的同步通常是隐式的，消息的发送必须在接收之前。如果某个线程企图接收一个尚未发送的消息，那么它就必须等到发送方赶上来。在共享内存编程模型中，同步通常不是隐式的，除非我们做了某些特殊的事情，否则“接收方”就可能在某个变量被“发送方“修改之前读到其中的“老”值。</p>
<p>并发和同步相关的基础概念，本文不再展开，综述类文章或章节可以阅读，全面介绍性的书籍可以阅读。同步相关的基础概念的思维导图，如下图所示：</p>
<p><img src="media/synchronization-mindmap.svg" alt="同步基础概念思维导图"></p>
<h1 id="线程管理">线程管理</h1>
<p>操作系统线程的实现区分用户空间线程和内核空间线程，两者的映射关系被称为<strong>线程模型</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_%28computing%29#Threading_models">threading model</a>）。目前主流的操作系统的线程模型都是 <code>1:1</code>，即每个用户空间线程都对应单独的内核空间线程。早期部分操作系统还支持<code> M:1</code>、<code>M:N</code> 模型，但因为过于复杂，逐渐被废弃。比如，Solaris 8 之前采用 <code>M:N</code> 线程模型，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Oracle_Solaris">Solaris</a> 8 （2000.02 发布）开始支持新的 <code>1:1</code> 线程模型，Solaris 9（2002.05 发布）默认采用 <code>1:1</code> 模型。类似的，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> 8（2009.11 发布）开始不再支持 <code>M:N</code> 模型，只支持<code>1:1</code> 模型。</p>
<p>在 Java 虚拟机层面，<strong>线程模型</strong>是指 Java 线程与操作系统线程的映射关系。当前，Hotspot 虚拟机实现的线程模型在各个操作系统平台下都采用 <code>1:1</code> 模型[^1]。总体上，Java 线程模型是 <code>1:1:1</code>。</p>
<p>Java 早期版本（JDK 1.1 到 JDK 1.2），Java 线程被称为<strong>绿色线程</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Green_thread">green thread</a>），采用的线程模型是 <code>M:1</code>，即全部 Java 线程底层共享同一个操作系统线程。JDK 1.3 开始（2000.05 发布），绿色线程被废弃，改为 <code>1:1</code> 线程模型。JDK 21 开始（2023.09 发布），Java 平台开始同时支持<strong>虚拟线程</strong>（virtual thread），采用的线程模型是 <code>M:N</code>，参见 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/444">JEP-444</a>。其他编程语言也支持类似的轻量级线程的特性，比如 2009 年诞生的 Go 语言，不支持 <code>1:1</code> 线程模型，在诞生之初内置实现的是轻量级线程 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Go_(programming_language)#Concurrency:_goroutines_and_channels">goroutine</a>，采用的线程模型是 <code>M:N</code>。</p>
<p>Java 创建线程，<code>java.lang.Thread.start()</code> 的实现原理：</p>
<ul>
<li><strong>功能描述</strong>：使该线程开始执行，Java 虚拟机调用该线程的 run 方法。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_StartThread(JNIEnv* env, jobject jthread)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Thread.c#L43">Thread.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L2816">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：构造 <code>JavaThread</code> 对象，然后调用 <code>os::create_thread(..)</code> 函数，构造 <code>OSThread</code> 对象，并创建与操作系统相关的线程。<code>os::create_thread(..)</code> 函数在不同操作系统平台下的实现
<ul>
<li><strong>类 Unix 系统</strong>：调用 POSIX 函数 <code>pthread_create</code>（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">man</a>），创建 <code>pthread</code> 线程，并在线程中运行 <code>java_start</code> 函数，<code>java_start</code> 函数内部会通过 <code>JavaCalls::call_virtual</code> 调用 <code>java.lang.Thread.run()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L865">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk8u/blob/jdk8u402-ga/hotspot/src/os/bsd/vm/os_bsd.cpp#L757">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L1091">os_solaris.cpp</a>）
<ul>
<li>实际上，Solaris 系统下的实现默认是基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Light-weight_process">LWP</a> 线程，而不是 Pthreads 线程，API 与 Pthreads 类似。创建线程调用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E86824_01/html/E54766/thr-create-3c.html">thr_create</a> 函数。</li>
<li>通过 JVM 参数选项 -XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseLWPSynchronization">UseLWPSynchronization</a> 控制，默认开启，若关闭，则改为基于 Pthreads 线程。JDK 15 开始（2020.09 发布），Java 平台删除对 Solaris 系统的支持，参见 <a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8241787">JEP-381</a>。</li>
</ul>
</li>
<li><strong>Windows 系统</strong>：调用函数 <code>_beginthreadex</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170">doc</a>），创建 Windows 线程，并在线程中运行 <code>java_start</code> 函数，<code>java_start</code> 函数内部会通过 <code>JavaCalls::call_virtual</code> 调用 <code>java.lang.Thread.run()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L517">os_windows.cpp</a>）</li>
</ul>
</li>
</ul>
<h1 id="基于-synchronized-线程同步">基于 synchronized 线程同步</h1>
<h2 id="偏向锁、轻量级锁和重量级锁">偏向锁、轻量级锁和重量级锁</h2>
<p>基于 <code>synchronized</code> 关键字的线程同步，HotSpot 虚拟机底层实现基于三种锁定技术，按适用的线程竞争程度由低至高依次为：偏向锁（Biased Lock）、轻量级锁（Lightweight Lock）和重量级锁（Heavyweight Lock）。基于三种锁定技术的线程同步的成本也依次增高。加锁时，先尝试偏向锁，若失败再升级为轻量级锁，最后再升级为重量级锁。</p>
<table>
<thead>
<tr>
<th><strong>锁定技术</strong></th>
<th><strong>官方支持时间</strong></th>
<th><strong>使用场景</strong></th>
<th><strong>相对其他锁定技术的优缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>重量级锁</strong></td>
<td>最早版本的 Java（1995.05）</td>
<td>有竞争</td>
<td>实现 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29">Monitor</a>，在无竞争场景下，性能较差</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>最早版本的 HotSpot（<a target="_blank" rel="noopener" href="https://web.archive.org/web/19991005170608/http://java.sun.com/pr/1999/04/pr990427-01.html">1999.04</a>）</td>
<td>有共享、无竞争</td>
<td>在无竞争场景下，避免创建 Monitor，从而提升性能</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>Java 6 开始支持（2006.12），Java 15 开始废弃（2020.09）</td>
<td>无共享、无竞争</td>
<td>相对轻量级锁，需要更少的 CAS 原子操作，除第一次加偏向锁外，锁重入和解锁都<strong>无需 CAS 原子操作</strong></td>
</tr>
</tbody>
</table>
<p>Java 的 <code>synchronized</code> 关键字的线程同步实现的是<strong>管程</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29">Monitor</a>，或翻译为“监视器”）。管程是 Brinch Hansen 和 Hoare 在 1970 年代初期发明的，1974 年 Brinch Hansen 在 Concurrent Pascal 编程语言上首次实现了管程。之后，Modula（1977）和 Mesa（1980）等编程语言也实现了管程。管程，是一种编程语言级别的高级同步机制，由<strong>互斥锁</strong>（mutual exclusion，缩写为“mutex”）和至少一个<strong>条件变量</strong>（condition variable，有时缩写为“condvar”）组成，<strong>Monitor = Mutex + Condvar</strong>。当条件变量为真时，按是否阻塞发 signal 的线程区分 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29#Blocking_condition_variables">Hoare 风格</a>（阻塞）和 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29#Nonblocking_condition_variables">Mesa 风格</a>（不阻塞）。Hoare 风格较难实现，目前大部分编程语言都是 Mesa 风格，Java 实现的是也是 <strong>Mesa 风格</strong>。Java 的所有对象都可以是 Monitor。另外，原始版本的 Monitor 有多个显式的条件变量，而 Java 实现的 Monitor <strong>只有单个隐式的条件变量</strong>。</p>
<p>早期版本的 Java 实现的管程的<strong>性能较差</strong>。典型的例子是，早期 Java 标准库中的 <code>Hashtable</code>、<code>Vector</code>、<code>StringBuffer</code> 等类存在<strong>过度同步</strong>（over-synchronized）问题，这些类的全部方法都用 <code>synchronized</code> 关键字包裹，即便是在单个线程无竞争的场景下运行，内部也总是执行同步逻辑。于是就有了针对<strong>无竞争（uncontended）场景</strong>下的同步的性能优化，出现了<strong>轻量级锁定</strong>（lightweight locking）技术。</p>
<p>轻量级锁定技术最早源自一篇发表于 1998 年的名为“<strong>瘦锁</strong>”（Thin Lock）的论文<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，作者来自 IBM 研究院，最早在 IBM 版的 JDK 1.1 中实现。相对的，在论文中完整版的 Monitor 实现被称为<strong>胖锁</strong>（Fat Lock）或<strong>膨胀锁</strong>（Inflated Lock）。瘦锁实现只需要维护在对象头中的 24 位的锁字（Lock Word）结构，而 Monitor 实现底层需要维护持有锁的线程、锁重入计数器、锁竞争队列、条件变量等待队列等复杂数据结构，所以被形象地命名为胖锁和瘦锁。原始版的瘦锁的实现可以参阅论文，本文不展开。HotSpot 虚拟机实现的轻量级锁定与瘦锁的核心思想类似，但有实现细节略微区别。HotSpot 实现的轻量级锁<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，多路复用对象头中 <code>Mark Word</code> 字段，并且为了提升性能在<strong>线程栈</strong>上维护<strong>锁记录</strong>（lock record, 或叫 on-stack lock record），所以 HotSpot 实现的轻量级锁也被叫做<strong>栈锁</strong>（Stack Lock）。</p>
<p>轻量级锁定技术优化的是<strong>无竞争（uncontended）场景</strong>，偏向锁定技术进一步优化了<strong>无共享（unshared）场景</strong>。研究发现大多数对象锁在对象生命周期内总是<strong>只有单个线程持有</strong>（即无共享），基于这个观察，2002 年 IBM 研究实验室提出<strong>锁保留</strong>（Lock Reservation）<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>技术的优化。Java 官方最早在 2006 年发布 Java 6 的 HotSpot 中实现偏向锁定技术，默认开启，核心思想类似于锁保留，同时还实现了批量重偏向和撤销<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>。<strong>偏向锁定技术的核心思想是，总是偏向于第一个获得它的线程，或者说锁总是保留给第一个线程，即便该线程已经释放锁</strong>。相对与轻量级锁定的优点是，<strong>偏向锁定需要更少的 CAS 原子操作，除第一次加偏向锁外，锁重入和解锁都无需 CAS 原子操作</strong>。2020 年 Java 15 发布后，<strong>偏向锁被废弃</strong>。原因是过去看到的性能提升在今天不再那么明显，变化主要包括早期标准库过度同步的类被新的无同步类、并发集合类等替代，以及硬件支持的 CAS 原子操作性能的提升等。另外，偏向锁定在同步子系统中引入了大量复杂的代码，给同步子系统的代码理解和设计变更带来障碍。具体参见 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/374">JEP-374</a>。</p>
<p>HotSpot 虚拟机的对象是否加锁以及底层使用哪种锁定技术通过对象头（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#objectHeader">object header</a>）中的 <strong><a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#markWord">Mark Word</a></strong> 字段区分。在未加锁时，<code>Mark Word</code> 字段用于记录对象的 <code>identity hash code</code> 和垃圾回收的年龄（age）。之所以多路复用 <code>Mark Word</code> 字段的功能，而不是在对象头中添加额外的字段，是为了<strong>避免增加对象的大小</strong>。在 32 位机器上的 <code>Mark Word</code> 格式，如下图所示<sup class="footnote-ref"><a href="#fn3" id="fnref3:2">[3:2]</a></sup>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/oops/markOop.hpp">markOop.hpp</a>）。对象头内共两个字段，除了 <code>Mark Word</code> 外，另外一个字段是 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#klassPointer">Klass Pointer</a>，是指向类元数据的指针。</p>
<p><img src="media/java-mark-word.png" alt="Mark Word 字段的各种状态"></p>
<p><strong>偏向锁（Biased Lock）</strong>，也叫<strong>锁保留（Lock Reservation）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：无共享（unshared）、无竞争（uncontended）</li>
<li><strong>加锁实现</strong>：如果 JVM 开启偏向锁选项，那么新对象创建分配的对象头的 <code>Mark Word</code> 状态是<strong>未偏向、可偏向状态</strong>（unbiased, biasable）或叫<strong>匿名偏向状态</strong>（anonymously biased），最低的三位值为 <code>101</code>，偏向的线程 Thread ID 值为 <code>0</code>。第一次加偏向锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>当前线程 Thread ID</strong> 实现。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>偏向锁定状态</strong>（biased, biasable）。若 CAS 原子操作失败，表明是另外一个线程去尝试获取这个锁，则<strong>撤销偏向锁</strong>（revoke bias）（不考虑批量重偏向的情况）。如果偏向线程不存活或不在同步块中，则先将锁对象设置为<strong>无锁状态</strong>（unlocked, unbiasable）。如果偏向线程还存活且还在同步块中，则将锁对象<strong>升级为轻量级锁</strong>。撤销偏向锁是 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#VMOperations">VM 操作</a>，需要等到 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint">safepoint</a> 的时候由 VM 线程执行。在 safepoint 没有 Java 线程执行字节码。
<ul>
<li><strong>锁重入</strong>：当偏向线程<strong>锁重入</strong>时，只需要检测比较 <code>Mark Word</code> 中的 <strong>Thread ID</strong> 是否相同，若相同则重入成功，<strong>不需要执行 CAS 原子更新操作</strong>。</li>
<li><strong>批量重偏向和撤销</strong>：偏向锁技术，不支持单个对象的重偏向，偏向线程不能从一个线程转移到另一个线程，但支持<strong>批量重偏向</strong>（bulk rebias）。HotSpot 虚拟机基于 epoch 概念实现了<strong>批量重偏向</strong>（bulk rebias）和<strong>批量撤销</strong>（bulk revoke）。</li>
</ul>
</li>
<li><strong>解锁实现</strong>：无需 CAS 原子操作，不需要更新对象头的 <code>Mark Word</code> 字段，<strong>依然偏向第一个获取偏向锁的线程</strong>。需要释放线程栈的<strong>锁记录</strong>，将<strong>锁记录</strong>中的指向持有锁对象的指针设置为 <code>NULL</code> 空。</li>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseBiasedLocking">UseBiasedLocking</a>，是否开启偏向锁，默认开启。</li>
</ul>
<p><strong>轻量级锁（Lightweight Lock）</strong>，也叫<strong>栈锁（Stack Lock）或瘦锁（Thin Lock）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：有共享（shared）、无竞争（uncontended）。即<strong>多个线程交替执行</strong>同步块，当某线程持有锁时没有其他线程尝试获取这个锁。</li>
<li><strong>加锁实现</strong>：从无锁或偏向锁升级到轻量级锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>指向锁记录的指针</strong>。同时，锁记录上需要写入两个字段，第一个字段被称为 <code>Displaced Mark Word</code>，或叫 <code>Displaced Header</code>，包含原始的对象头的 <code>Mark Word</code> 字段（记录 <code>hash</code> 和 <code>age</code> 信息），第二个字段是指向持有锁对象的指针。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>轻量级锁定状态</strong>（lightweight locked）。如果 CAS 原子修改失败，表明锁已经被其他线程占用，需要将轻量级锁膨胀为<strong>重量级锁。</strong>
<ul>
<li><strong>锁重入</strong>：将重入的<strong>锁记录</strong>中的 <code>Displaced Mark Word</code>值设置为 <code>NULL</code>（值为 <code>0</code>）。<code>Displaced Mark Word</code> 值为 <code>NULL</code> 的锁记录的数量，就是锁重入的次数。</li>
</ul>
</li>
<li><strong>解锁实现</strong>：释放<strong>锁记录</strong>，将<strong>锁记录</strong>中的指向持有锁对象的指针设置为 <code>NULL</code> 空。若 <code>Displaced Mark Word</code> 值非 <code>NULL</code>，表明不是锁重入的释放，同时还要通过 CAS 原子操作将<strong>锁记录</strong>中的 <code>Displaced Mark Word</code> 值还原到对象头中的 <code>Mark Word</code> ，即将 <code>Mark Word</code> 还原为<strong>无锁状态</strong>（unlocked, unbiasable）。</li>
</ul>
<p><strong>重量级锁（Heavyweight Lock）</strong>，也叫<strong>重量级管程（Heavyweight Monitor）、膨胀锁（Inflated Lock）或胖锁（Fat Lock）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：有竞争（contended）</li>
<li><strong>升级膨胀</strong>：从轻量级锁升级到重量级锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>指向 Monitor 对象的指针</strong>。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>重量级锁定状态</strong>（heavyweight locked）。</li>
<li><strong>降级收缩</strong>：虚拟机会在 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint">safepoint</a> 点会扫描全部 Monitor，找出全部 idle 状态的 Monitor，并将这些 Monitor 关联的锁对象还原为<strong>无锁状态</strong>（unlocked, unbiasable），即将在 Monitor 中保存的 <code>Displaced Mark Word</code> 还原到对象头中的 <code>Mark Word</code>。idle 状态的 Monitor 的持有锁的线程、锁竞争队列、等待队列等全部字段都为空。</li>
<li><strong>加锁和解锁实现</strong>：管程底层由 <code>ObjectMonitor</code> 类实现，内部维护持有锁的线程、锁重入计数器、锁竞争队列、条件变量等待队列等字段。管程内部的加锁和解锁实现的完整阐述参见下文。</li>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseHeavyMonitors">UseHeavyMonitors</a>，是否只使用重量级锁，默认 false，开启后禁用偏向和轻量锁 。</li>
</ul>
<p><strong>hashcode 与偏向锁定状态的冲突</strong>：偏向锁复用了对象头的 <code>Mark Word</code> 字段，但是与轻量级锁和重量级锁不同，偏向锁没有额外维护 <code>Displaced Mark Word</code>，所以 hashcode 与偏向状态无法共存，当需要计算对象的  <code>identity hash code</code> 时，会撤销偏向锁，并升级为重量级锁。调用 <code>java.lang.Object.hashCode()</code> 或 <code>java.lang.System.identityHashCode(Object)</code> 会触发 <code>identity hash code</code> 的计算，需要读取对象头的 <code>Mark Word</code> 中的 hash 值。如果计算对象的 hashcode 值调用的是被覆盖后的 <code>hashCode()</code> 方法，则不会读取 <code>Mark Word</code> 中的 hash 值，可以继续使用偏向锁。相关实现源码解析（参见 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L601">synchronizer.cpp</a>）：</p>
<ul>
<li>调用 <code>java.lang.Object.hashCode()</code> 或 <code>java.lang.System.identityHashCode(Object)</code> 计算对象的 hashcode，在 JVM 层实现都会先调用 <code>JVM_IHashCode(..)</code> 函数，然后再调用 <code>ObjectSynchronizer::FastHashCode(..)</code> 函数，该函数会返回存储在对象头的 <code>Mark Word</code> 中的 hash 值。如果对象处于偏向锁定状态，会撤销偏向锁，并升级为重量级 Monitor，然后再返回在维护在 Monitor 中的 <code>Displaced Mark Word</code> 字段内的 hash 值。</li>
</ul>
<p>三种锁定技术下的 <code>Mark Word</code> 字段的状态流转，如下图所示[^2]：</p>
<p><img src="media/java-mark-word-state-transitions.gif" alt="Mark Word 字段的状态流转"></p>
<p>三种锁定技术下的 <code>Mark Word</code> 和 <code>Lock Record</code> 字段值，如下图所示[^6]<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：</p>
<p><img src="media/java-mark-word-biased-lock.png" alt="偏向锁的 Mark Word 和 Lock Record"></p>
<p><img src="media/java-mark-word-lightweight-lock.png" alt="轻量级锁的 Mark Word 和 Lock Record"></p>
<p><img src="media/java-mark-word-heavyweight-lock.png" alt="重量级锁的 Mark Word、Lock Record 和 ObjectMonitor"></p>
<p><strong>相关实现源码</strong>：</p>
<ul>
<li>对象头的 <code>Mark Word</code> 字段对应的实现类是 <code>markOopDesc</code> 和 <code>markOop</code> 类，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/oops/markOop.hpp">markOop.hpp</a>
<ul>
<li><code>markOop</code> 类是 <code>markOopDesc</code> 的指针类，定义是 <code>typedef class markOopDesc* markOop;</code></li>
</ul>
</li>
<li>线程栈上锁记录对应的实现类是 <code>BasicObjectLock</code>类，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/basicLock.hpp">basicLock.hpp</a>。
<ul>
<li>在锁记录上维护两个字段。第一个字段，被称为 <code>Displaced Mark Word</code>，或叫 <code>Displaced Header</code>，包含原始的对象头的 <code>Mark Word</code> 字段（记录 <code>hash</code> 和 <code>age</code> 信息），字段定义源码 <code>BasicLock _lock</code>。第二个字段，是指向持有锁对象的指针，字段定义源码 <code>oop _obj</code>。</li>
<li><code>BasicLock</code> 类的 <code>void set_displaced_header(markOop header)</code> 方法，用于修改锁记录的 <code>Mark Word</code> 字段值</li>
</ul>
</li>
<li><strong>synchronized 加锁的实现源码</strong>：
<ul>
<li><strong>字节码指令</strong>：<code>monitorenter</code></li>
<li><strong>JVM 层实现源码入口</strong>：
<ul>
<li><code>TemplateTable::monitorenter()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorenter)</code>。虚拟机实现两种解释器，模板解释器和字节码解释器，默认使用模板解释器，但是字节码解释器代码可读性更高，模板解释器参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3596">templateTable_x86_64.cpp</a>，字节码解释器参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1686">bytecodeInterpreter.cpp</a></li>
<li>实现上，先尝试<strong>偏向锁</strong>，若失败再升级为<strong>轻量级锁</strong>，若加<strong>轻量级锁</strong>失败，再膨胀为<strong>重量级锁</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>synchronized 解锁的实现源码</strong>：
<ul>
<li><strong>字节码指令</strong>：<code>monitorexit</code></li>
<li><strong>JVM 层实现源码入口</strong>：
<ul>
<li><code>TemplateTable::monitorexit()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorexit)</code>。参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3690">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1720">bytecodeInterpreter.cpp</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重量级-Monitor-的实现">重量级 Monitor 的实现</h2>
<p><img src="media/java-heavyweight-monitor-internals.png" alt="Java 重量级 Monitor 的底层实现（默认策略）"></p>
<p>Hotspot 虚拟机的重量级 Monitor 实现的最核心类是 <code>ObjectMonitor</code>，<code>ObjectMonitor</code>类定义的部分核心字段（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.hpp#L77">objectMonitor.hpp</a> 和 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L185">objectMonitor.cpp</a>）：</p>
<ul>
<li><code>header</code>（字段名 <code>_header</code>）：持有锁对象的对象头中的原始 <code>Mark Word</code>，即 <code>Displaced Mark Word</code>。</li>
<li><code>object</code>（字段名 <code>_object</code>）：指向持有锁对象的指针。</li>
<li><code>owner</code>（字段名 <code>_owner</code>）：持有锁的线程。</li>
<li><code>succ</code>（字段名 <code>_succ</code>）：假定继承人线程（heir presumptive），或叫“successor”线程。</li>
<li><code>cxq</code>（字段名 <code>_cxq</code>）：“contention queue”的缩写，锁竞争队列。</li>
<li><code>EntryList</code>（字段名 <code>_EntryList</code>）：锁竞争队列。
<ul>
<li>区分两个锁竞争队列 <code>cxq</code> 和 <code>EntryList</code> 的原因是，为了优化出队列操作的时间。多个线程并发入队到 <code>cxq</code> 队列，而只有持有锁的线程可以在 <code>cxq</code> 队列上执行出队列操作。只有持有锁的线程可以访问和修改 <code>EntryList</code> 队列，在 <code>EntryList</code> 队列上的操作都是无锁的（lock-free）。参见源码注释的解释：
<ul>
<li>“We use two distinct lists to improve the odds of a constant-time dequeue operation after acquisition (in the ::enter() epilog) and to reduce heat on the list ends.” [ref <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L234">objectMonitor.cpp</a>]</li>
</ul>
</li>
</ul>
</li>
<li><code>WaitSet</code>（字段名 <code>_WaitSet</code>）：条件变量的等待（waiting）队列。</li>
<li><code>recursions</code>（字段名 <code>_recursions</code>）：锁重入计数器。</li>
</ul>
<p><strong>Monitor 加锁的 JVM 层实现源码解析</strong>：</p>
<ul>
<li>(1) 调用 <code>TemplateTable::monitorenter()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorenter)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3596">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1686">bytecodeInterpreter.cpp</a>）
<ul>
<li>先尝试<strong>偏向锁</strong>，若失败再升级为<strong>轻量级锁</strong>，若加<strong>轻量级锁</strong>失败，再膨胀为<strong>重量级锁</strong>。</li>
</ul>
</li>
<li>(2) 依次调用 <code>InterpreterRuntime::monitorenter(..)</code>、<code>ObjectSynchronizer::fast_enter(..)</code>、<code>ObjectSynchronizer::slow_enter(..)</code>，再调用 <code>ObjectSynchronizer::inflate(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L166">synchronizer.cpp</a>）
<ul>
<li>在 <code>inflate(..)</code> 函数内部，执行将轻量级锁膨胀为重量级锁的逻辑，函数内部构造 <code>ObjectMonitor</code> 对象并返回。</li>
</ul>
</li>
<li>(3) 调用 <code>ObjectMonitor::enter(..)</code>，再调用 <code>ObjectMonitor::EnterI(..)</code>，执行<strong>重量级锁的加锁逻辑</strong>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L479">objectMonitor.cpp</a>）
<ul>
<li>加锁的互斥操作，通过 CAS 原子操作将 <code>ObjectMonitor</code> 对象的 <code>_owner</code> 字段从 <code>null</code> 修改为当前线程（<code>Self</code>），若失败则<strong>自适应自旋</strong>（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#adaptiveSpinning">adaptive spinning</a>）重试。
<ul>
<li>相关源码：<code>Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL);</code></li>
</ul>
</li>
<li>若自旋竞争锁失败，将线程加到 <code>ObjectMonitor</code> 对象的 <code>cxq</code> <strong>锁竞争队列的队头</strong>，并 <code>ParkEvent::park()</code> 阻塞当前线程。</li>
</ul>
</li>
</ul>
<p><strong>Monitor 解锁的 JVM 层实现源码解析</strong>：</p>
<ul>
<li>(1) 调用 <code>TemplateTable::monitorexit()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorexit)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3690">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1720">bytecodeInterpreter.cpp</a>）</li>
<li>(2) 调用 <code>InterpreterRuntime::monitorexit(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/interpreterRuntime.cpp#L586">interpreterRuntime.cpp</a>）</li>
<li>(3) 调用 <code>ObjectSynchronizer::fast_exit()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L183">synchronizer.cpp</a>）
<ul>
<li>释放<strong>轻量级锁</strong>，通过 CAS 原子操作将<strong>锁记录</strong>中的 <code>Displaced Mark Word</code>值还原到对象头中的 <code>Mark Word</code> ，即将 <code>Mark Word</code> 还原为<strong>无锁状态</strong>。</li>
</ul>
</li>
<li>(4) 调用 <code>ObjectMonitor::exit(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L933">objectMonitor.cpp</a>）
<ul>
<li>释放<strong>重量级锁</strong>，将 <code>ObjectMonitor</code> 对象的 <code>owner</code> 字段设置为 <code>null</code>
<ul>
<li>相关源码：<code>OrderAccess::release_store_ptr (&amp;_owner, NULL);</code></li>
</ul>
</li>
<li><strong>默认的锁竞争队列出队策略是</strong>，唤醒在 <code>EntryList</code> <strong>锁竞争队列</strong>的队头的线程，如果 <code>EntryList</code> 为空，则将 <code>cxq</code> 中的节点全部移到 <code>EntryList</code> 中，然后再去 <code>ParkEvent::unpark()</code> 唤醒 <code>EntryList</code> 的队头的线程。被 <code>ParkEvent::unpark()</code> 唤醒的线程，被称为“successor”或“heir presumptive”（假定继承人）线程，successor 线程会去尝试竞争锁。锁竞争队列出队策略，底层由 <code>Knob_QMode</code> 字段控制，策略依次为：
<ul>
<li><strong>出队策略 0</strong>：若 <code>EntryList</code> 非空，取 <code>EntryList</code> 队头线程并唤醒；若 <code>EntryList</code> 空，先将 <code>cxq</code> 全部移到 <code>EntryList</code>，再取 <code>EntryList</code> 队头线程并唤醒（<strong>默认策略</strong>）</li>
<li><strong>出队策略 1</strong>：若 <code>EntryList</code> 非空，取 <code>EntryList</code> 队头线程并唤醒；若 <code>EntryList</code> 空，先将<strong>反转后的</strong> <code>cxq</code> 全部移到 <code>EntryList</code>，再取 <code>EntryList</code> 队头线程并唤醒</li>
<li><strong>出队策略 2</strong>：直接取 <code>cxq</code> 队头线程并唤醒</li>
<li><strong>出队策略 3</strong>：先将 <code>cxq</code> 全部移到 <code>EntryList</code> 尾部，再取 <code>EntryList</code> 队头线程并唤醒</li>
<li><strong>出队策略 4</strong>：先将 <code>cxq</code> 全部移到 <code>EntryList</code> 头部，再取 <code>EntryList</code> 队头线程并唤醒</li>
</ul>
</li>
</ul>
</li>
<li><strong>重量级锁的降级收缩（deflation）的实现源码</strong>：
<ul>
<li>调用<code>ObjectSynchronizer::deflate_idle_monitors()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L1498">synchronizer.cpp</a>）</li>
<li>降级某个 Monitor 调用 <code>ObjectSynchronizer::deflate_monitor(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L1422">synchronizer.cpp</a>）</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--">wait</a>()、java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-">wait</a>(long timeout) 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L515">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析：</strong>
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::wait(..)</code>（参见源码 synchronizer.cpp）</li>
<li>(2) 调用 <code>ObjectMonitor::wait(..)</code>（参见源码 objectMonitor.cpp）
<ul>
<li>将当前线程加入 <code>WaitSet</code> <strong>条件变量等待队列的队尾</strong>，并 <code>ParkEvent::park()</code> 阻塞自己</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--">notify</a>() 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：唤醒在此对象监视器上等待的单个线程。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorNotify(JNIEnv* env, jobject handle)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L526">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析：</strong>
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::notify(..)</code>（参见源码 synchronizer.cpp）</li>
<li>(2) 调用 <code>ObjectMonitor::notify(..)</code>（参见源码 objectMonitor.cpp）
<ul>
<li>将<code>WaitSet</code> 条件变量等待队列的队头的线程选为<strong>被通知线程</strong>（notifyee），然后根据<strong>移动策略</strong>将被通知线程移到 <code>cxq</code> 或 <code>EntryList</code> 锁竞争队列，默认策略是插入到 <code>cxq</code> 到队头。notifyee 线程的移动策略，底层由 <code>Knob_MoveNotifyee</code> 字段控制，策略依次为：
<ul>
<li><strong>移动策略 0</strong>：将被通知线程加到 <code>EntryList</code> 的队头</li>
<li><strong>移动策略 1</strong>：将被通知线程加到 <code>EntryList</code> 的队尾</li>
<li><strong>移动策略 2</strong>：将被通知线程加到 <code>cxq</code> 的队头（<strong>默认策略</strong>）</li>
<li><strong>移动策略 3</strong>：将被通知线程加到 <code>cxq</code> 的队尾</li>
</ul>
</li>
<li>附注：JDK 1.6 之前的版本，<code>notify</code> 的实现逻辑不是将被通知线程（notifyee）移到锁竞争队列，而是直接唤醒 notifyee 线程。JDK 1.6 优化的原因是，由于 Java 实现的是 Mesa 风格的管程，当前持有锁的线程在调用 <code>notify</code> 后，并不会释放锁，不会阻塞自己，而是继续执行，所以<strong>被唤醒的 notifyee 线程并不能立即获取锁，而总是因为获取锁失败而被阻塞</strong>，唤醒 notifyee 线程是无效的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--">notifyAll</a>() 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：唤醒在此对象监视器上等待的所有线程。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorNotifyAll(JNIEnv* env, jobject handle)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L533">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::notifyall(..)</code>（参见源码 synchronizer.cpp）</li>
<li>(2) 调用 <code>ObjectMonitor::notifyAll(..)</code>（参见源码 objectMonitor.cpp）
<ul>
<li>循环将全部<code>WaitSet</code> 条件变量等待队列的线程移到锁竞争队列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="自适应互斥锁">自适应互斥锁</h2>
<p>线程在竞争互斥锁（mutex）失败后的<strong>等待策略</strong>（waiting policy）分为两种：<strong>自旋</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Busy_waiting">spinning</a>）和<strong>阻塞</strong>（blocking）。</p>
<ul>
<li><strong>自旋</strong>（spinning），或叫<strong>自旋等待</strong>（spin-waiting）或<strong>忙等待</strong>（busy waiting）：线程会循环反复测试是否可以获取锁，会一直在 CPU 上运行。在抢占式调度器的操作系统下（目前<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheduling_%28computing%29#Summary">主流操作系统</a>都是抢占式的），在时间片结束后，调度器会将 CPU 调度给其他线程。线程也可以主动<strong>让出</strong>（yield）CPU，在类 Unix 系统下调用 <code>sched_yield()</code> 函数。一些旧的自旋等待的实现会在循环中调用 <code>sched_yield()</code>，不过在 Linux 下不推荐在自旋循环中调用 <code>sched_yield()</code><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。自旋线程的线程状态一直处于 <code>running</code> 或 <code>runnable</code> 状态（<code>runnable</code> 状态，也被叫做 <code>ready</code> 状态）。</li>
<li><strong>阻塞</strong>（blocking），或叫<strong>睡眠等待</strong>（sleep-waiting）或<strong>基于调度器</strong>（scheduler-based）：线程会主动睡眠（阻塞）自己，请求调度器<strong>取消调度</strong>（deschedule）当前线程，让出 CPU 资源給另外一个线程。线程状态将一直处于 <code>sleeping</code> 状态（也叫 <code>waiting</code> 状态），直到被唤醒，被唤醒后状态为 <code>runnable</code>。</li>
</ul>
<p>阻塞线程相对耗时较大，至少需要执行两次线程上下文切换。自旋会浪费 CPU 资源，所以自旋等待的时间应该尽量短，自旋时间最好小于完成两次上下文切换的耗时。单次请求锁的 CAS 原子操作消耗的 CPU 时钟周期数大概是 15 ~ 30，而单次线程上下文切换的总消耗的 CPU 时钟周期数大概是 10,000 ~ 1,000,000，消耗的 CPU 时钟周期数相差约 100 ~ 10000 倍<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。</p>
<p>自旋和阻塞策略存在各自缺点，所以目前很多操作系统内核的互斥锁实现采用<strong>混合策略</strong>，即“spin-then-block”的等待策略，实现的互斥锁称为<strong>自适应互斥锁</strong>（adaptive mutex）。目前 Solaris、Mac OS X 和 FreeBSD 内核实现的互斥锁，默认都是“adaptive mutex”。另外，pthread 线程库也支持创建<strong>自适应类型的 mutex</strong>。</p>
<p>操作系统内核和 pthread 线程库的自适应互斥锁的历史演进：</p>
<ul>
<li>1992.06，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Oracle_Solaris#Version_history">Solaris</a> 2.0 发布，内核实现的 mutex 默认是“adaptive mutex”<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>。</li>
<li>2000.07，glibc 2.2 版本的 pthread 线程库开始支持创建自适应类型的 mutex，相关类型参数是 <code>PTHREAD_MUTEX_ADAPTIVE_NP</code>（参见 <a target="_blank" rel="noopener" href="https://github.com/bminor/glibc/blob/a88b96f496c0214424db1219d21ce669fbc102a0/linuxthreads/ChangeLog">commit</a>）。不过，默认 mutex 类型是 <code>PTHREAD_MUTEX_NORMAL</code>，等待策略是立即阻塞而不是先自旋。</li>
<li>2007.10，FreeBSD 的 pthread 线程库开始支持自适应类型的 mutex，实现 glibc 的 <code>PTHREAD_MUTEX_ADAPTIVE_NP</code> 类型的 mutex（参见 <a target="_blank" rel="noopener" href="https://github.com/freebsd/freebsd-src/commit/2017a7cdfe8f1a0e38b76e8e8871fe90df07b8f7">commit</a>、<a target="_blank" rel="noopener" href="https://github.com/freebsd/freebsd-src/commit/7416cdabcd0c1dd626ff5b7edfcedf11967ff39f">commit</a>）。FreeBSD 的 pthread 线程库，默认 mutex 类型是 <code>PTHREAD_MUTEX_ERRORCHECK</code>，等待策略是立即阻塞而不是先自旋。</li>
<li>2009.11，FreeBSD 8.0 发布，从 FreeBSD 8.0 开始内核实现的 mutex 默认是“adaptive mutex”，实现类似于 Solaris。</li>
</ul>
<p>Solaris 实现的自适应互斥锁的自旋策略是<sup class="footnote-ref"><a href="#fn8" id="fnref8:1">[8:1]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>：当线程试图去获取一个锁且锁已经被占有时，内核检查当前占有该锁的线程的状态。如果锁的持有者正在某一处理器上运行，申请线程就会旋转；如果锁的持有者当前没有运行，申请线程就会阻塞。Solaris 的自旋次数的配置参数是 <code>LIBTHREAD_ADAPTIVE_SPIN</code>，默认值 1000。FreeBSD 实现的自旋策略与 Solaris 类似（参见 locking <a target="_blank" rel="noopener" href="https://man.freebsd.org/cgi/man.cgi?query=locking&amp;manpath=FreeBSD+10.0-RELEASE">man</a>）。</p>
<p>glibc 的 pthread 实现的自适应互斥锁的自旋策略是<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>：每个自适应 mutex 的自旋次数，基于之前的自旋次数在 0 ~ 100 之间动态调整。最大的自旋次数可配置，配置参数是 <code>glibc.pthread.mutex_spin_count</code>，默认值 100（参见 glibc <a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/manual/html_node/POSIX-Thread-Tunables.html">doc</a>）。</p>
<p>FreeBSD 实现的 pthread 线程库的自适应互斥锁的自旋策略是：先执行固定配置次数的自旋循环，然后执行调用 yield 的自旋循环，最后再睡眠等待。自旋次数的配置参数是 <code>LIBPTHREAD_SPINLOOPS</code>，默认值 2000；调用 yield 的自旋循环，默认不开启，调用 yield 的自旋次数的配置参数是 <code>LIBPTHREAD_YIELDLOOPS</code>，默认值 0（参见 libthr <a target="_blank" rel="noopener" href="https://man.freebsd.org/cgi/man.cgi?query=libthr&amp;manpath=FreeBSD+11.0-RELEASE">man</a>）。</p>
<p>HotSpot 的 Monitor 内部的互斥锁实现的历史演进：</p>
<ul>
<li>2000.05，J2SE 1.3 发布，并同时发布 HotSpot 2.0，从这版本的 HotSpot 开始，Monitor 内部的互斥锁（mutex）实现的锁等待策略是“spin-then-block”，即先自旋重试再阻塞，参见 <a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-4256394">JDK-4256394</a>。自旋策略是<strong>固定自旋</strong>（fixed spinning），按固定配置的次数自旋（默认 10 次）。
<ul>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk6.html?s=UseSpinning">UseSpinning</a>，是否自旋，默认关闭；-XX:<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk6.html?s=PreBlockSpin">PreBlockSpin</a>，阻塞前的自旋次数，默认值 10。Java 6 开始，旧的 -XX:+UseSpinning 和 -XX:PreBlockSpin 等自旋 JVM 参数选项不再有效，Java 7 发布后，相关参数被删除。</li>
</ul>
</li>
<li>2006.12，Java 6 发布，HotSpot 的 Monitor 内部的互斥锁实现的锁等待策略改为“adaptive spin-then-block”，自旋策略改为<strong>自适应自旋</strong>（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#adaptiveSpinning">adaptive spinning</a>），自旋次数在 0 ~ 5000 之间动态调整。每个 Monitor 各自独立维护动态自旋次数，当前的自旋次数根据最近的自旋获得锁的成功/失败率动态调整，如果最近的自旋成功率高，说明当前的自旋也很有可能成功，则尝试更多次数的自旋。若成功率低，则减少自旋次数。最大的自旋次数是 5000。
<ul>
<li>底层实现函数为 <code>ObjectMonitor::TrySpin_VaryDuration(..)</code>，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1905">objectMonitor.cpp</a>。</li>
</ul>
</li>
</ul>
<h2 id="park-unpark-同步原语">park-unpark 同步原语</h2>
<p>Hotspot 的 Monitor 同步子系统的实现，除了用于阻塞和唤醒线程的依赖操作系统平台相关的 <strong>park-unpark 抽象</strong>外，尽量避免使用操作系统原生的同步原语（synchronization primitive）。总体上，Monitor 的实现底层只依赖于 <strong>park-unpark 抽象</strong>和<strong>原子操作</strong>。park-unpark 抽象，由 JVM 的 <code>ParkEvent</code> 和 <code>PlatformEvent</code> 类实现，<code>ParkEvent</code> 是 <code>PlatformEvent</code> 的子类，<code>ParkEvent</code> 与操作系统平台无关，<code>PlatformEvent</code> 与操作系统平台相关。<code>ParkEvent</code> 类的实现，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/park.hpp">park.hpp</a> 和 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/park.cpp">park.cpp</a>。<code>PlatformEvent**</code> 类的实现，概括来说：</p>
<ul>
<li><strong>类 Unix 系统</strong>：基于 pthread 的 mutex 互斥锁和条件变量实现。Linux 系统的线程同步底层基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Futex">futex</a> 系统调用，Solaris 系统的线程同步底层基于 <code>lwp_park</code>、<code>lwp_unpark</code> 系统调用。</li>
<li><strong>Windows 系统</strong>：基于 Windows 的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/sync/event-objects">Event 对象</a>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_%28synchronization_primitive%29">wiki</a>）实现。</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L264">objectMonitor.cpp</a> 代码注释</strong>：</p>
<blockquote>
<p>The monitor synchronization subsystem avoids the use of native synchronization primitives except for the narrow platform-specific park-unpark abstraction. See the comments in os_solaris.cpp regarding the semantics of park-unpark. Put another way, this monitor implementation depends only on atomic operations and park-unpark.</p>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L5938">os_solaris.cpp</a> 代码注释</strong>：</p>
<blockquote>
<p><strong>ObjectMonitor park-unpark infrastructure</strong><br>
We implement Solaris and Linux PlatformEvents with the obvious condvar-mutex-flag triple. Another alternative that works quite well is pipes: Each PlatformEvent consists of a pipe-pair. The thread associated with the PlatformEvent calls park(), which reads from the input end of the pipe. Unpark() writes into the other end of the pipe. The write-side of the pipe must be set NDELAY. Unfortunately pipes consume a large # of handles. Native solaris lwp_park() and lwp_unpark() work nicely, too. Using pipes for the 1st few threads might be workable, however.</p>
</blockquote>
<p><strong>park-unpark 同步原语的具体实现</strong>：</p>
<ul>
<li><strong>阻塞线程</strong>：调用 <code>ParkEvent::park()</code> 或 <code>ParkEvent::park(jlong millis)</code>，实际调用与操作系统相关的父类实现的 <code>os::PlatformEvent::park()</code> 或 <code>os::PlatformEvent::park(jlong millis)</code>
<ul>
<li><strong>类 Unix 系统</strong>：通过调用 POSIX 函数 <code>pthread_cond_wait</code> 或 <code>pthread_cond_timedwait</code>（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html">man</a>） 阻塞线程，等待条件是事件数大于等于 0，在阻塞线程前先调用 <code>pthread_mutex_lock</code> 获取 mutex 互斥锁（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5862">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/bsd/vm/os_bsd.cpp#L4426">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L6092">os_solaris.cpp</a>）</li>
<li><strong>Windows 系统</strong>：通过调用函数 <code>WaitForSingleObject</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">doc</a>）阻塞线程（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L4904">os_windows.cpp</a>）</li>
</ul>
</li>
<li><strong>唤醒线程</strong>：调用 <code>ParkEvent::unpark()</code>，实际调用与操作系统相关的父类实现的 <code>os::PlatformEvent::unpark()</code>
<ul>
<li><strong>类 Unix 系统</strong>：将等待条件的事件数设置为 1，然后通过调用 POSIX 函数 <code>pthread_cond_signal</code> 唤醒线程，在唤醒线程前先调用 <code>pthread_mutex_lock</code> 获取 mutex 互斥锁（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5963">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/bsd/vm/os_bsd.cpp#L4426">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L6136">os_solaris.cpp</a>）</li>
<li><strong>Windows 系统</strong>：通过调用函数 <code>SetEvent</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">doc</a>）唤醒线程（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L4949">os_windows.cpp</a>）</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.cjsdn.net/doc/jdk60/java/util/concurrent/locks/LockSupport.html">http://www.cjsdn.net/doc/jdk60/java/util/concurrent/locks/LockSupport.html</a></p>
<h1 id="基于-AQS-线程同步">基于 AQS 线程同步</h1>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>1998，David F. Bacon, etc: <strong>Thin Locks: Featherweight Synchronization for Java</strong>. PLDI 1998: 258-268，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/pldi/BaconKMS98.html">dblp</a>，<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Thin-locks%3A-featherweight-synchronization-for-Java-Bacon-Konuru/07ab0964c6afca7fec1d1a00df9375de2ae26e1e">semanticscholar</a>：作者来自 IBM 研究院，提出瘦锁（Thin Lock）技术 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>1999，Ole Agesen, etc: <strong>An Efficient Meta-Lock for Implementing Ubiquitous Synchronization</strong>. OOPSLA 1999: 207-222，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/AgesenDGKRW99.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/An-efficient-meta-lock-for-implementing-ubiquitous-Agesen-Detlefs/add4082ea2d5eded2f75a6a3f5b7f622a1f8542a">semanticscholar</a>：作者来自 Sun 公司 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2006，Kenneth B. Russell, David Detlefs: <strong>Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing</strong>. OOPSLA 2006: 263-272：<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/RussellD06.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Eliminating-synchronization-related-atomic-with-and-Russell-Detlefs/356a2d9859520c9161d67828d45e758a24ecce20">semanticscholar</a>、<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf">slides</a>：作者来自 Sun 公司，主要阐述 Java 6 的 HotSpot 虚拟机实现的偏向锁，同时也介绍了轻量级锁的实现 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a> <a href="#fnref3:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2002，Kiyokuni Kawachiya, etc: <strong>Lock Reservation: Java Locks can Mostly do without Atomic Operations</strong>. OOPSLA 2002: 130-141，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/KawachiyaKO02.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/reservation%3A-Java-locks-can-mostly-do-without/884749059cae01a003a4f0d9011df3d4ab7dd166">semanticscholar</a>：作者来自 IBM 研究院，提出锁保留（Lock Reservation）技术 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2014，Marcus Larsson: <strong>Evaluating and improving biased locking in the HotSpot virtual machine</strong>. KTH Master Thesis，<a target="_blank" rel="noopener" href="http://www.diva-portal.org/smash/get/diva2:754541/FULLTEXT01.pdf">pdf</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>2003-05 The right way to yield <a target="_blank" rel="noopener" href="https://lwn.net/Articles/31462/">https://lwn.net/Articles/31462/</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2016-09 Infographics: Operation Costs in CPU Clock Cycles <a target="_blank" rel="noopener" href="http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/">http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Joseph R. Eykholt, etc: <strong>Beyond Multiprocessing: Multithreading the SunOS Kernel</strong>. USENIX Summer 1992，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/usenix/EykholtKBFSSVWW92.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Beyond-Multiprocessing%3A-Multithreading-the-SunOS-Eykholt-Kleiman/c087671a641adbbcb01cb6b59d38a9a43e6da4b5">semanticscholar</a>：介绍 Solaris 2.0 内核的多线程技术 <a href="#fnref8" class="footnote-backref">↩︎</a> <a href="#fnref8:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Solaris 内核结构（Solaris Internals），Richard McDougall &amp; Jim Mauro，第2版2006，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/2161545/">豆瓣</a>：第17章 锁和同步，17.5 互斥锁 <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>What is PTHREAD_MUTEX_ADAPTIVE_NP <a target="_blank" rel="noopener" href="https://stackoverflow.com/q/19863734/689699">https://stackoverflow.com/q/19863734/689699</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2024/02/java-synchronization-implementation.md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/java-synchronization-implementation.md/" class="post-title-link" itemprop="url">Java 线程同步实现原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-10 15:58:00" itemprop="dateCreated datePublished" datetime="2024-02-10T15:58:00+08:00">2024-02-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2024/02/java-synchronization-implementation.md/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/02/java-synchronization-implementation.md/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于 Java 线程同步的实现原理，官方有很多介绍资料<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>，值得阅读。</p>
<h1 id="基础概念">基础概念</h1>
<p>在并发编程模型中，需要处理的两个最关键的问题就是<strong>通信</strong>（communication）和<strong>同步</strong>（synchronization）<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>。通信指线程可用于获得其他线程产生的信息的各种机制。通信机制通常都基于<strong>共享内存</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_memory">shared memory</a>）或<strong>消息传递</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Message_passing">message passing</a>）。在共享内存的编程模型中，某些或全部程序变量可以由多个线程访问。如果一对线程之间需要通信，只要一个线程将值写入某个变量，另一线程来读它即可。在消息传递编程模型中，不同线程没有公共的状态。当一对线程之间需要通信时，其中的一个必须执行一次明确的 send 操作，将数据传送给另一个线程。</p>
<p>同步<sup class="footnote-ref"><a href="#fn8" id="fnref8:1">[8:1]</a></sup>是控制不同线程之间操作发生的相对顺序的各种机制，用以排除导致不正确结果的交错。消息传递模型中的同步通常是隐式的，消息的发送必须在接收之前。如果某个线程企图接收一个尚未发送的消息，那么它就必须等到发送方赶上来。在共享内存编程模型中，同步通常不是隐式的，除非我们做了某些特殊的事情，否则“接收方”就可能在某个变量被“发送方“修改之前读到其中的“老”值。</p>
<p>并发和同步相关的基础概念，本文不再展开，综述类的文章或章节可以阅读<sup class="footnote-ref"><a href="#fn8" id="fnref8:2">[8:2]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup><sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>，全面介绍性的书籍可以阅读<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup><sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>。同步相关的基础概念的思维导图，如下图所示：</p>
<p><img src="media/synchronization-mindmap.svg" alt="同步基础概念思维导图"></p>
<p>Java 线程同步思维导图，如下图所示：<br>
<img src="media/java-synchronization-mindmap.svg" alt="Java 线程同步思维导图"></p>
<h1 id="线程管理">线程管理</h1>
<p>操作系统线程的实现区分用户空间线程和内核空间线程，两者的映射关系被称为<strong>线程模型</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_%28computing%29#Threading_models">threading model</a>）。目前主流的操作系统的线程模型都是 <code>1:1</code>，即每个用户空间线程都对应单独的内核空间线程。早期部分操作系统还支持<code> M:1</code>、<code>M:N</code> 模型，但因为过于复杂，逐渐被废弃。比如，Solaris 8 之前采用 <code>M:N</code> 线程模型，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Oracle_Solaris">Solaris</a> 8 （2000.02 发布）开始支持新的 <code>1:1</code> 线程模型，Solaris 9（2002.05 发布）默认采用 <code>1:1</code> 模型。类似的，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> 8（2009.11 发布）开始不再支持 <code>M:N</code> 模型，只支持<code>1:1</code> 模型。</p>
<p>在 Java 虚拟机层面，<strong>线程模型</strong>是指 Java 线程与操作系统线程的映射关系。当前，Hotspot 虚拟机实现的线程模型在各个操作系统平台下都采用 <code>1:1</code> 模型<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>。总体上，Java 线程模型是 <code>1:1:1</code>。</p>
<p>Java 早期版本（JDK 1.1 到 JDK 1.2），Java 线程被称为<strong>绿色线程</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Green_thread">green thread</a>），采用的线程模型是 <code>M:1</code>，即全部 Java 线程底层共享同一个操作系统线程。JDK 1.3 开始（2000.05 发布），绿色线程被废弃，改为 <code>1:1</code> 线程模型。JDK 21 开始（2023.09 发布），Java 平台开始同时支持<strong>虚拟线程</strong>（virtual thread），采用的线程模型是 <code>M:N</code>，参见 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/444">JEP-444</a>。</p>
<p>其他编程语言也支持类似的轻量级线程的特性，比如 2009 年诞生的 Go 语言，不支持 <code>1:1</code> 线程模型，在诞生之初内置实现的是轻量级线程 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Go_(programming_language)#Concurrency:_goroutines_and_channels">goroutine</a>，采用的线程模型是 <code>M:N</code>。</p>
<p>Java 创建线程，<code>java.lang.Thread.start()</code> 的实现原理：</p>
<ul>
<li><strong>功能描述</strong>：使该线程开始执行，Java 虚拟机调用该线程的 run 方法。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_StartThread(JNIEnv* env, jobject jthread)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Thread.c#L43">Thread.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L2816">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：构造 <code>JavaThread</code> 对象，然后调用 <code>os::create_thread(..)</code> 函数，构造 <code>OSThread</code> 对象，并创建与操作系统相关的线程。<code>os::create_thread(..)</code> 函数在不同操作系统平台下的实现
<ul>
<li><strong>类 Unix 系统</strong>：调用 POSIX 函数 <code>pthread_create</code>（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">man</a>），创建 <code>pthread</code> 线程，并在线程中运行 <code>java_start</code> 函数，<code>java_start</code> 函数内部会通过 <code>JavaCalls::call_virtual</code> 调用 <code>java.lang.Thread.run()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L865">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk8u/blob/jdk8u402-ga/hotspot/src/os/bsd/vm/os_bsd.cpp#L757">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L1091">os_solaris.cpp</a>）
<ul>
<li>实际上，Solaris 系统下的实现默认是基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Light-weight_process">LWP</a> 线程，而不是 Pthreads 线程，API 与 Pthreads 类似。创建线程调用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E86824_01/html/E54766/thr-create-3c.html">thr_create</a> 函数。</li>
<li>通过 JVM 参数选项 -XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseLWPSynchronization">UseLWPSynchronization</a> 控制，默认开启，若关闭，则改为基于 Pthreads 线程。JDK 15 开始（2020.09 发布），Java 平台删除对 Solaris 系统的支持，参见 <a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8241787">JEP-381</a>。</li>
</ul>
</li>
<li><strong>Windows 系统</strong>：调用函数 <code>_beginthreadex</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170">doc</a>），创建 Windows 线程，并在线程中运行 <code>java_start</code> 函数，<code>java_start</code> 函数内部会通过 <code>JavaCalls::call_virtual</code> 调用 <code>java.lang.Thread.run()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L517">os_windows.cpp</a>）</li>
</ul>
</li>
</ul>
<h1 id="基于-synchronized-线程同步">基于 synchronized 线程同步</h1>
<h2 id="偏向锁、轻量级锁和重量级锁">偏向锁、轻量级锁和重量级锁</h2>
<p>基于 <code>synchronized</code> 关键字的线程同步，HotSpot 虚拟机底层实现基于三种锁定技术，按适用的线程竞争程度由低至高依次为：偏向锁（Biased Lock）、轻量级锁（Lightweight Lock）和重量级锁（Heavyweight Lock）。基于三种锁定技术的线程同步的成本也依次增高。加锁时，先尝试偏向锁，若失败再升级为轻量级锁，最后再升级为重量级锁。</p>
<table>
<thead>
<tr>
<th><strong>锁定技术</strong></th>
<th><strong>官方支持时间</strong></th>
<th><strong>使用场景</strong></th>
<th><strong>相对其他锁定技术的优缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>重量级锁</strong></td>
<td>最早版本的 Java（1995.05）</td>
<td>有竞争</td>
<td>实现 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29">Monitor</a>，在无竞争场景下，性能较差</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>最早版本的 HotSpot（<a target="_blank" rel="noopener" href="https://web.archive.org/web/19991005170608/http://java.sun.com/pr/1999/04/pr990427-01.html">1999.04</a>）</td>
<td>有共享、无竞争</td>
<td>在无竞争场景下，避免创建 Monitor，从而提升性能</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>Java 6 开始支持（2006.12），Java 15 开始废弃（2020.09）</td>
<td>无共享、无竞争</td>
<td>相对轻量级锁，需要更少的 CAS 原子操作，除第一次加偏向锁外，锁重入和解锁都<strong>无需 CAS 原子操作</strong></td>
</tr>
</tbody>
</table>
<p>Java 的 <code>synchronized</code> 关键字的线程同步实现的是<strong>管程</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29">Monitor</a>，或翻译为“监视器”）。管程是 Brinch Hansen 和 Hoare 在 1970 年代初期发明的，1974 年 Brinch Hansen 在 Concurrent Pascal 编程语言上首次实现了管程。之后，Modula（1977）和 Mesa（1980）等编程语言也实现了管程。管程，是一种编程语言级别的高级同步机制，由<strong>互斥锁</strong>（mutual exclusion，缩写为“mutex”）和至少一个<strong>条件变量</strong>（condition variable，有时缩写为“condvar”）组成，<strong>Monitor = Mutex + Condvar</strong>。当条件变量为真时，按是否阻塞发 signal 的线程区分 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29#Blocking_condition_variables">Hoare 风格</a>（阻塞）和 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29#Nonblocking_condition_variables">Mesa 风格</a>（不阻塞）。Hoare 风格较难实现，目前大部分编程语言都是 Mesa 风格，Java 实现的是也是 <strong>Mesa 风格</strong>。Java 的所有对象都可以是 Monitor。另外，原始版本的 Monitor 有多个显式的条件变量，而 Java 实现的 Monitor <strong>只有单个隐式的条件变量</strong>。</p>
<p>早期版本的 Java 实现的管程的<strong>性能较差</strong>。典型的例子是，早期 Java 标准库中的 <code>Hashtable</code>、<code>Vector</code>、<code>StringBuffer</code> 等类存在<strong>过度同步</strong>（over-synchronized）问题，这些类的全部方法都用 <code>synchronized</code> 关键字包裹，即便是在单个线程无竞争的场景下运行，内部也总是执行同步逻辑。于是就有了针对<strong>无竞争（uncontended）场景</strong>下的同步的性能优化，出现了<strong>轻量级锁定</strong>（lightweight locking）技术。</p>
<p>轻量级锁定技术最早源自一篇发表于 1998 年的名为“<strong>瘦锁</strong>”（Thin Lock）的论文<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>，作者来自 IBM 研究院，最早在 IBM 版的 JDK 1.1 中实现。相对的，在论文中完整版的 Monitor 实现被称为<strong>胖锁</strong>（Fat Lock）或<strong>膨胀锁</strong>（Inflated Lock）。瘦锁实现只需要维护在对象头中的 24 位的锁字（Lock Word）结构，而 Monitor 实现底层需要维护持有锁的线程、锁重入计数器、锁竞争等待队列、条件变量等待队列等复杂数据结构，所以被形象地命名为胖锁和瘦锁。原始版的瘦锁的实现可以参阅论文，本文不展开。HotSpot 虚拟机实现的轻量级锁定与瘦锁的核心思想类似，但有实现细节略微区别。HotSpot 实现的轻量级锁<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup><sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>，多路复用对象头中 <code>Mark Word</code> 字段，并且为了提升性能在<strong>线程栈</strong>上维护<strong>锁记录</strong>（lock record, 或叫 on-stack lock record），所以 HotSpot 实现的轻量级锁也被叫做<strong>栈锁</strong>（Stack Lock）。</p>
<p>轻量级锁定技术优化的是<strong>无竞争（uncontended）场景</strong>，偏向锁定技术进一步优化了<strong>无共享（unshared）场景</strong>。研究发现大多数对象锁在对象生命周期内总是<strong>只有单个线程持有</strong>（即无共享），基于这个观察，2002 年 IBM 研究实验室提出<strong>锁保留</strong>（Lock Reservation）<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>技术的优化。Java 官方最早在 2006 年发布 Java 6 的 HotSpot 中实现偏向锁定技术，默认开启，核心思想类似于锁保留，同时还实现了批量重偏向和撤销<sup class="footnote-ref"><a href="#fn16" id="fnref16:1">[16:1]</a></sup>。<strong>偏向锁定技术的核心思想是，总是偏向于第一个获得它的线程，或者说锁总是保留给第一个线程，即便该线程已经释放锁</strong>。相对与轻量级锁定的优点是，<strong>偏向锁定需要更少的 CAS 原子操作，除第一次加偏向锁外，锁重入和解锁都无需 CAS 原子操作</strong>。2020 年 Java 15 发布后，<strong>偏向锁被废弃</strong>。原因是过去看到的性能提升在今天不再那么明显，变化主要包括早期标准库过度同步的类被新的无同步类、并发集合类等替代，以及硬件支持的 CAS 原子操作性能的提升等。另外，偏向锁定在同步子系统中引入了大量复杂的代码，给同步子系统的代码理解和设计变更带来障碍。具体参见 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/374">JEP-374</a>。</p>
<p>HotSpot 虚拟机的对象是否加锁以及底层使用哪种锁定技术通过对象头（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#objectHeader">object header</a>）中的 <strong><a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#markWord">Mark Word</a></strong> 字段区分。在未加锁时，<code>Mark Word</code> 字段用于记录对象的 <code>identity hash code</code> 和垃圾回收的年龄（age）。之所以多路复用 <code>Mark Word</code> 字段的功能，而不是在对象头中添加额外的字段，是为了<strong>避免增加对象的大小</strong>。在 32 位机器上的 <code>Mark Word</code> 格式，如下图所示<sup class="footnote-ref"><a href="#fn16" id="fnref16:2">[16:2]</a></sup>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/oops/markOop.hpp">markOop.hpp</a>）。对象头内共两个字段，除了 <code>Mark Word</code> 外，另外一个字段是 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#klassPointer">Klass Pointer</a>，是指向类元数据的指针。</p>
<p><img src="media/java-mark-word.png" alt="Mark Word 字段的各种状态"></p>
<p><strong>偏向锁（Biased Lock）</strong>，也叫<strong>锁保留（Lock Reservation）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：无共享（unshared）、无竞争（uncontended）</li>
<li><strong>加锁实现</strong>：如果 JVM 开启偏向锁选项，那么新对象创建分配的对象头的 <code>Mark Word</code> 状态是<strong>未偏向、可偏向状态</strong>（unbiased, biasable）或叫<strong>匿名偏向状态</strong>（anonymously biased），最低的三位值为 <code>101</code>，偏向的线程 Thread ID 值为 <code>0</code>。第一次加偏向锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>当前线程 Thread ID</strong> 实现。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>偏向锁定状态</strong>（biased, biasable）。若 CAS 原子操作失败，表明是另外一个线程去尝试获取这个锁，则<strong>撤销偏向锁</strong>（revoke bias）（不考虑批量重偏向的情况）。如果偏向线程不存活或不在同步块中，则先将锁对象设置为<strong>无锁状态</strong>（unlocked, unbiasable）。如果偏向线程还存活且还在同步块中，则将锁对象<strong>升级为轻量级锁</strong>。撤销偏向锁是 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#VMOperations">VM 操作</a>，需要等到 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint">safepoint</a> 的时候由 VM 线程执行。在 safepoint 没有 Java 线程执行字节码。
<ul>
<li><strong>锁重入</strong>：当偏向线程<strong>锁重入</strong>时，只需要检测比较 <code>Mark Word</code> 中的 <strong>Thread ID</strong> 是否相同，若相同则重入成功，<strong>不需要执行 CAS 原子更新操作</strong>。</li>
<li><strong>批量重偏向和撤销</strong>：偏向锁技术，不支持单个对象的重偏向，偏向线程不能从一个线程转移到另一个线程，但支持<strong>批量重偏向</strong>（bulk rebias）。HotSpot 虚拟机基于 epoch 概念实现了<strong>批量重偏向</strong>（bulk rebias）和<strong>批量撤销</strong>（bulk revoke）。</li>
</ul>
</li>
<li><strong>解锁实现</strong>：无需 CAS 原子操作，不需要更新对象头的 <code>Mark Word</code> 字段，<strong>依然偏向第一个获取偏向锁的线程</strong>。需要释放线程栈的<strong>锁记录</strong>，将<strong>锁记录</strong>中的指向持有锁对象的指针设置为 <code>NULL</code> 空。</li>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseBiasedLocking">UseBiasedLocking</a>，是否开启偏向锁，默认开启。</li>
</ul>
<p><strong>轻量级锁（Lightweight Lock）</strong>，也叫<strong>栈锁（Stack Lock）或瘦锁（Thin Lock）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：有共享（shared）、无竞争（uncontended）。即<strong>多个线程交替执行</strong>同步块，当某线程持有锁时没有其他线程尝试获取这个锁。</li>
<li><strong>加锁实现</strong>：从无锁或偏向锁升级到轻量级锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>指向锁记录的指针</strong>。同时，锁记录上需要写入两个字段，第一个字段被称为 <code>Displaced Mark Word</code>，或叫 <code>Displaced Header</code>，包含原始的对象头的 <code>Mark Word</code> 字段（记录 <code>hash</code> 和 <code>age</code> 信息），第二个字段是指向持有锁对象的指针。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>轻量级锁定状态</strong>（lightweight locked）。如果 CAS 原子修改失败，表明锁已经被其他线程占用，需要将轻量级锁膨胀为<strong>重量级锁。</strong>
<ul>
<li><strong>锁重入</strong>：将重入的<strong>锁记录</strong>中的 <code>Displaced Mark Word</code>值设置为 <code>NULL</code>（值为 <code>0</code>）。<code>Displaced Mark Word</code> 值为 <code>NULL</code> 的锁记录的数量，就是锁重入的次数。</li>
</ul>
</li>
<li><strong>解锁实现</strong>：释放<strong>锁记录</strong>，将<strong>锁记录</strong>中的指向持有锁对象的指针设置为 <code>NULL</code> 空。若 <code>Displaced Mark Word</code> 值非 <code>NULL</code>，表明不是锁重入的释放，同时还要通过 CAS 原子操作将<strong>锁记录</strong>中的 <code>Displaced Mark Word</code> 值还原到对象头中的 <code>Mark Word</code> ，即将 <code>Mark Word</code> 还原为<strong>无锁状态</strong>（unlocked, unbiasable）。</li>
</ul>
<p><strong>重量级锁（Heavyweight Lock）</strong>，也叫<strong>重量级管程（Heavyweight Monitor）、膨胀锁（Inflated Lock）或胖锁（Fat Lock）</strong>，实现原理：</p>
<ul>
<li><strong>使用场景</strong>：有竞争（contended）</li>
<li><strong>升级膨胀</strong>：从轻量级锁升级到重量级锁时，通过 CAS 原子操作在对象头中的 <code>Mark Word</code> 字段中写入<strong>指向 Monitor 对象的指针</strong>。CAS 原子操作成功后，<code>Mark Word</code> 状态变为<strong>重量级锁定状态</strong>（heavyweight locked）。</li>
<li><strong>降级收缩</strong>：虚拟机会在 <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#safepoint">safepoint</a> 点会扫描全部 Monitor，找出全部 idle 状态的 Monitor，并将这些 Monitor 关联的锁对象还原为<strong>无锁状态</strong>（unlocked, unbiasable），即将在 Monitor 中保存的 <code>Displaced Mark Word</code> 还原到对象头中的 <code>Mark Word</code>。idle 状态的 Monitor 的持有锁的线程、锁竞争等待队列、等待队列等全部字段都为空。</li>
<li><strong>加锁和解锁实现</strong>：管程底层由 <code>ObjectMonitor</code> 类实现，内部维护持有锁的线程、锁重入计数器、锁竞争等待队列、条件变量等待队列等字段。管程内部的加锁和解锁实现的完整阐述参见下文。</li>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk8.html?s=UseHeavyMonitors">UseHeavyMonitors</a>，是否只使用重量级锁，默认 false，开启后禁用偏向和轻量锁 。</li>
</ul>
<p><strong>hashcode 与偏向锁定状态的冲突</strong>：偏向锁复用了对象头的 <code>Mark Word</code> 字段，但是与轻量级锁和重量级锁不同，偏向锁没有额外维护 <code>Displaced Mark Word</code>，所以 hashcode 与偏向状态无法共存，当需要计算对象的  <code>identity hash code</code> 时，会撤销偏向锁，并升级为重量级锁。调用 <code>java.lang.Object.hashCode()</code> 或 <code>java.lang.System.identityHashCode(Object)</code> 会触发 <code>identity hash code</code> 的计算，需要读取对象头的 <code>Mark Word</code> 中的 hash 值。如果计算对象的 hashcode 值调用的是被覆盖后的 <code>hashCode()</code> 方法，则不会读取 <code>Mark Word</code> 中的 hash 值，可以继续使用偏向锁。相关实现源码解析（参见 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L601">synchronizer.cpp</a>）：</p>
<ul>
<li>调用 <code>java.lang.Object.hashCode()</code> 或 <code>java.lang.System.identityHashCode(Object)</code> 计算对象的 hashcode，在 JVM 层实现都会先调用 <code>JVM_IHashCode(..)</code> 函数，然后再调用 <code>ObjectSynchronizer::FastHashCode(..)</code> 函数，该函数会返回存储在对象头的 <code>Mark Word</code> 中的 hash 值。如果对象处于偏向锁定状态，会撤销偏向锁，并升级为重量级 Monitor，然后再返回在维护在 Monitor 中的 <code>Displaced Mark Word</code> 字段内的 hash 值。</li>
</ul>
<p>三种锁定技术下的 <code>Mark Word</code> 字段的状态流转，如下图所示<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>：</p>
<p><img src="media/java-mark-word-state-transitions.gif" alt="Mark Word 字段的状态流转"></p>
<p>三种锁定技术下的 <code>Mark Word</code> 和 <code>Lock Record</code> 字段值，如下图所示<sup class="footnote-ref"><a href="#fn6" id="fnref6:1">[6:1]</a></sup><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>：</p>
<p><img src="media/java-mark-word-biased-lock.png" alt="偏向锁的 Mark Word 和 Lock Record"></p>
<p><img src="media/java-mark-word-lightweight-lock.png" alt="轻量级锁的 Mark Word 和 Lock Record"></p>
<p><img src="media/java-mark-word-heavyweight-lock.png" alt="重量级锁的 Mark Word、Lock Record 和 ObjectMonitor"></p>
<p><strong>相关实现源码</strong>：</p>
<ul>
<li>对象头的 <code>Mark Word</code> 字段对应的实现类是 <code>markOopDesc</code> 和 <code>markOop</code> 类，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/oops/markOop.hpp">markOop.hpp</a>
<ul>
<li><code>markOop</code> 类是 <code>markOopDesc</code> 的指针类，定义是 <code>typedef class markOopDesc* markOop;</code></li>
</ul>
</li>
<li>线程栈上锁记录对应的实现类是 <code>BasicObjectLock</code>类，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/basicLock.hpp">basicLock.hpp</a>。
<ul>
<li>在锁记录上维护两个字段。第一个字段，被称为 <code>Displaced Mark Word</code>，或叫 <code>Displaced Header</code>，包含原始的对象头的 <code>Mark Word</code> 字段（记录 <code>hash</code> 和 <code>age</code> 信息），字段定义源码 <code>BasicLock _lock</code>。第二个字段，是指向持有锁对象的指针，字段定义源码 <code>oop _obj</code>。</li>
<li><code>BasicLock</code> 类的 <code>void set_displaced_header(markOop header)</code> 方法，用于修改锁记录的 <code>Mark Word</code> 字段值。</li>
</ul>
</li>
<li><strong>synchronized 加锁的实现源码</strong>：
<ul>
<li><strong>字节码指令</strong>：<code>monitorenter</code></li>
<li><strong>JVM 层实现源码入口</strong>：
<ul>
<li><code>TemplateTable::monitorenter()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorenter)</code>。虚拟机实现两种解释器，模板解释器和字节码解释器，默认使用模板解释器，但是字节码解释器代码可读性更高，模板解释器参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3596">templateTable_x86_64.cpp</a>，字节码解释器参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1686">bytecodeInterpreter.cpp</a></li>
<li>实现上，先尝试<strong>偏向锁</strong>，若失败再升级为<strong>轻量级锁</strong>，若加<strong>轻量级锁</strong>失败，再膨胀为<strong>重量级锁</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>synchronized 解锁的实现源码</strong>：
<ul>
<li><strong>字节码指令</strong>：<code>monitorexit</code></li>
<li><strong>JVM 层实现源码入口</strong>：
<ul>
<li><code>TemplateTable::monitorexit()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorexit)</code>，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3690">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1720">bytecodeInterpreter.cpp</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重量级-Monitor-的实现">重量级 Monitor 的实现</h2>
<p>Hotspot 虚拟机的重量级 Monitor 实现的最核心类是 <code>ObjectMonitor</code>，<code>ObjectMonitor</code> 类定义的部分核心字段（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.hpp#L77">objectMonitor.hpp</a> 和 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L185">objectMonitor.cpp</a>）：</p>
<ul>
<li><code>header</code>：持有锁对象的对象头中的原始 <code>Mark Word</code>，即 <code>Displaced Mark Word</code>。
<ul>
<li>字段定义：<code>volatile markOop _header;</code></li>
</ul>
</li>
<li><code>object</code>：指向持有锁对象的指针。
<ul>
<li>字段定义：<code>void* volatile _object;</code></li>
</ul>
</li>
<li><code>owner</code>：持有锁的线程。
<ul>
<li>字段定义：<code>void * volatile _owner;</code></li>
</ul>
</li>
<li><code>succ</code>：继承人（successor）线程，或叫假定继承人（heir presumptive）线程。
<ul>
<li>字段定义：<code>Thread * volatile _succ;</code></li>
</ul>
</li>
<li><code>cxq</code>：“contention queue”的缩写，即锁竞争等待队列，或叫锁竞争队列。
<ul>
<li>字段定义：<code>ObjectWaiter * volatile _cxq;</code></li>
</ul>
</li>
<li><code>EntryList</code>：锁竞争等待队列。
<ul>
<li>字段定义：<code>ObjectWaiter * volatile _EntryList;</code></li>
</ul>
</li>
<li><code>WaitSet</code>：条件变量的等待（waiting）队列。
<ul>
<li>字段定义：<code>ObjectWaiter * volatile _WaitSet;</code></li>
</ul>
</li>
<li><code>recursions</code>：锁重入计数器。
<ul>
<li>字段定义：<code>volatile intptr_t  _recursions;</code></li>
</ul>
</li>
</ul>
<p><code>ObjectWaiter</code> 类，内部维护 <code>Thread* _thread</code> 字段，作用为线程的代理，同时内部维护 <code>ObjectWaiter * _next</code> 和 <code>ObjectWaiter * _prev</code> 字段，用于构造链表结构。锁竞争等待队列 <code>cxq</code>、<code>EntryList</code> 和条件变量的等待队列 <code>WaitSet</code>，都是节点类型为 <code>ObjectWaiter</code> 的链表。<code>cxq</code> 是单向链表，多线程并发执行入队（enqueue）操作，单线程执行出队（dequeue）操作。<code>WaitSet</code> 和 <code>EntryList</code> 是双向链表，单线程执行入队和出队操作。</p>
<p>区分两个锁竞争等待队列 <code>cxq</code> 和 <code>EntryList</code> 的原因是，为了优化<strong>出队</strong>（dequeue）操作的时间。多个线程并发入队到 <code>cxq</code> 队列，而只有持有锁的线程可以在 <code>cxq</code> 队列上执行出队列操作。只有持有锁的线程可以访问和修改 <code>EntryList</code> 队列，在 <code>EntryList</code> 队列上的操作都是无锁的（lock-free）。参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L234">objectMonitor.cpp</a> 的注释的解释：</p>
<blockquote>
<p>We use two distinct lists to improve the odds of a constant-time dequeue operation after acquisition (in the ::enter() epilog) and to reduce heat on the list ends.”</p>
</blockquote>
<p>Monitor 的底层实现，如下图所示。图中线程 A 持有锁，线程 B、线程 C、线程 D，竞争锁失败，在竞争等待队列中阻塞等待。如果线程 A 释放锁，默认策略下，线程 D 会被选为继承人线程。唤醒后的继承人线程，尝试竞争锁，若成功，移出锁等待队列（dequeue），若失败，调用 <code>park()</code> 阻塞自己。</p>
<p><img src="media/java-heavyweight-monitor-internals.png" alt="Java 重量级 Monitor 的底层实现（默认策略）"></p>
<p><strong>Monitor 加锁的 JVM 层实现源码解析</strong>：</p>
<ul>
<li>(1) 调用 <code>TemplateTable::monitorenter()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorenter)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3596">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1686">bytecodeInterpreter.cpp</a>）
<ul>
<li>先尝试<strong>偏向锁</strong>，若失败再升级为<strong>轻量级锁</strong>，若加<strong>轻量级锁</strong>失败，再膨胀为<strong>重量级锁</strong>。</li>
</ul>
</li>
<li>(2) 依次调用 <code>InterpreterRuntime::monitorenter(..)</code>、<code>ObjectSynchronizer::fast_enter(..)</code>、<code>ObjectSynchronizer::slow_enter(..)</code>，再调用 <code>ObjectSynchronizer::inflate(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L166">synchronizer.cpp</a>）
<ul>
<li>在 <code>inflate(..)</code> 函数内部，执行将轻量级锁膨胀为重量级锁的逻辑，函数内部构造 <code>ObjectMonitor</code> 对象并返回。</li>
</ul>
</li>
<li>(3) 调用 <code>ObjectMonitor::enter(..)</code>，再调用 <code>ObjectMonitor::EnterI(..)</code>，执行<strong>重量级锁的加锁逻辑</strong>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L479">objectMonitor.cpp</a>）
<ul>
<li>加锁的互斥操作，通过 CAS 原子操作将 <code>ObjectMonitor</code> 对象的 <code>_owner</code> 字段从 <code>null</code> 修改为当前线程（<code>Self</code>），若失败则<strong>自适应自旋</strong>（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#adaptiveSpinning">adaptive spinning</a>）重试。关于“自适应自旋”的解释参见下文。
<ul>
<li>相关源码：<code>Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL);</code></li>
</ul>
</li>
<li>若自旋竞争锁失败，将线程加到 <code>ObjectMonitor</code> 对象的 <code>cxq</code> <strong>锁竞争等待队列的队头</strong>，并 <code>ParkEvent::park()</code> 阻塞当前线程。</li>
</ul>
</li>
</ul>
<p><strong>Monitor 解锁的 JVM 层实现源码解析</strong>：</p>
<ul>
<li>(1) 调用 <code>TemplateTable::monitorexit()</code> 或 <code>BytecodeInterpreter</code> 的 <code>CASE(_monitorexit)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp#L3690">templateTable_x86_64.cpp</a> 或 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L1720">bytecodeInterpreter.cpp</a>）</li>
<li>(2) 调用 <code>InterpreterRuntime::monitorexit(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/interpreter/interpreterRuntime.cpp#L586">interpreterRuntime.cpp</a>）</li>
<li>(3) 调用 <code>ObjectSynchronizer::fast_exit()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L183">synchronizer.cpp</a>）
<ul>
<li>释放<strong>轻量级锁</strong>，通过 CAS 原子操作将<strong>锁记录</strong>中的 <code>Displaced Mark Word</code>值还原到对象头中的 <code>Mark Word</code> ，即将 <code>Mark Word</code> 还原为<strong>无锁状态</strong>。</li>
</ul>
</li>
<li>(4) 调用 <code>ObjectMonitor::exit(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L933">objectMonitor.cpp</a>）
<ul>
<li>释放<strong>重量级锁</strong>，将 <code>ObjectMonitor</code> 对象的 <code>owner</code> 字段设置为 <code>null</code>
<ul>
<li>相关源码：<code>OrderAccess::release_store_ptr (&amp;_owner, NULL);</code></li>
</ul>
</li>
<li><strong>默认的锁竞争等待队列出队策略是</strong>，唤醒在 <code>EntryList</code> <strong>锁竞争等待队列</strong>的队头的线程，如果 <code>EntryList</code> 为空，则将 <code>cxq</code> 中的节点全部移到 <code>EntryList</code> 中，然后再去 <code>ParkEvent::unpark()</code> 唤醒 <code>EntryList</code> 的队头的线程。被 <code>ParkEvent::unpark()</code> 唤醒的线程，被称为继承人（successor）线程，successor 线程会去尝试竞争锁。锁竞争等待队列出队策略，底层由 <code>Knob_QMode</code> 字段控制，策略依次为：
<ul>
<li><strong>出队策略 0</strong>：若 <code>EntryList</code> 非空，取 <code>EntryList</code> 队头线程并唤醒；若 <code>EntryList</code> 空，先将 <code>cxq</code> 全部移到 <code>EntryList</code>，再取 <code>EntryList</code> 队头线程并唤醒（<strong>默认策略</strong>）</li>
<li><strong>出队策略 1</strong>：若 <code>EntryList</code> 非空，取 <code>EntryList</code> 队头线程并唤醒；若 <code>EntryList</code> 空，先将<strong>反转后的</strong> <code>cxq</code> 全部移到 <code>EntryList</code>，再取 <code>EntryList</code> 队头线程并唤醒</li>
<li><strong>出队策略 2</strong>：直接取 <code>cxq</code> 队头线程并唤醒</li>
<li><strong>出队策略 3</strong>：先将 <code>cxq</code> 全部移到 <code>EntryList</code> 尾部，再取 <code>EntryList</code> 队头线程并唤醒</li>
<li><strong>出队策略 4</strong>：先将 <code>cxq</code> 全部移到 <code>EntryList</code> 头部，再取 <code>EntryList</code> 队头线程并唤醒</li>
</ul>
</li>
<li>唤醒后的继承人线程，尝试竞争锁。若竞争锁成功，调用 <code>ObjectMonitor::UnlinkAfterAcquire</code> 移出锁等待队列（dequeue）。若竞争锁失败，再次调用 <code>ParkEvent::park()</code> 阻塞自己。
<ul>
<li>相关源码：<code>ObjectMonitor::EnterI(..)</code>，<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L612">objectMonitor.cpp</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>重量级锁的降级收缩（deflation）的实现源码</strong>：
<ul>
<li>调用 <code>ObjectSynchronizer::deflate_idle_monitors()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L1498">synchronizer.cpp</a>）</li>
<li>降级某个 Monitor 调用 <code>ObjectSynchronizer::deflate_monitor(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L1422">synchronizer.cpp</a>）</li>
</ul>
</li>
<li><strong>公平性</strong>：线程的出队次序并不遵循 FIFO 方式，后等待的线程被先唤醒，所以线程抢占锁是<strong>非公平</strong>的，线程出队策略类似与电梯扫描（elevator-scan），线程按次序加入 <code>cxq</code> 队列，类似于在电梯外排队，将 <code>cxq</code> 队列全部移到 <code>EntryList</code> 队列，类似于进电梯。</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--">wait</a>()、java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-">wait</a>(long timeout) 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：在其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法前，导致当前线程等待。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L515">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::wait(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L376">synchronizer.cpp</a>）</li>
<li>(2) 调用 <code>ObjectMonitor::wait(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1440">objectMonitor.cpp</a>）
<ul>
<li>将当前线程加入 <code>WaitSet</code> <strong>条件变量等待队列的队尾</strong>，然后调用 <code>ObjectMonitor::exit(..)</code> 释放锁，并 <code>ParkEvent::park()</code> 阻塞自己</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--">notify</a>() 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：唤醒在此对象监视器上等待的单个线程。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorNotify(JNIEnv* env, jobject handle)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L526">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::notify(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L407">synchronizer.cpp</a>）</li>
<li>(2) 调用 <code>ObjectMonitor::notify(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1663">objectMonitor.cpp</a>）
<ul>
<li>将<code>WaitSet</code> 条件变量等待队列的队头的线程选为<strong>被通知线程</strong>（notifyee），然后根据<strong>移动策略</strong>将被通知线程移到 <code>cxq</code> 或 <code>EntryList</code> 锁竞争等待队列，默认策略是插入到 <code>cxq</code> 到队头。notifyee 线程的移动策略，底层由 <code>Knob_MoveNotifyee</code> 字段控制，策略依次为：
<ul>
<li><strong>移动策略 0</strong>：将被通知线程加到 <code>EntryList</code> 的队头</li>
<li><strong>移动策略 1</strong>：将被通知线程加到 <code>EntryList</code> 的队尾</li>
<li><strong>移动策略 2</strong>：将被通知线程加到 <code>cxq</code> 的队头（<strong>默认策略</strong>）</li>
<li><strong>移动策略 3</strong>：将被通知线程加到 <code>cxq</code> 的队尾</li>
</ul>
</li>
<li><strong>附注</strong>：JDK 1.6 之前的版本，<code>notify</code> 的实现逻辑不是将被通知线程（notifyee）移到锁竞争等待队列，而是直接唤醒 notifyee 线程。JDK 1.6 优化的原因是，由于 Java 实现的是 Mesa 风格的管程，当前持有锁的线程在调用 <code>notify</code> 后，并不会释放锁，不会阻塞自己，而是继续执行，所以<strong>被唤醒的 notifyee 线程并不能立即获取锁，而总是因为获取锁失败而被阻塞</strong>，唤醒 notifyee 线程是无效的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Object.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--">notifyAll</a>() 实现原理</strong>：</p>
<ul>
<li><strong>功能描述</strong>：唤醒在此对象监视器上等待的所有线程。</li>
<li><strong>JVM 入口函数</strong>：<code>JVM_MonitorNotifyAll(JNIEnv* env, jobject handle)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/native/java/lang/Object.c#L42">Object.c</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/jvm.cpp#L533">jvm.cpp</a>）</li>
<li><strong>JVM 层实现源码解析</strong>：
<ul>
<li>(1) 调用 <code>ObjectSynchronizer::notifyall(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/synchronizer.cpp#L421">synchronizer.cpp</a>）</li>
<li>(2) 调用 <code>ObjectMonitor::notifyAll(..)</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1782">objectMonitor.cpp</a>）
<ul>
<li>循环将全部 <code>WaitSet</code> 条件变量等待队列的线程移到锁竞争等待队列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="自适应互斥锁">自适应互斥锁</h2>
<p>线程在竞争互斥锁（mutex）失败后的<strong>等待策略</strong>（waiting policy）分为两种：<strong>自旋</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Busy_waiting">spinning</a>）和<strong>阻塞</strong>（blocking）。</p>
<ul>
<li><strong>自旋</strong>（spinning），或叫<strong>自旋等待</strong>（spin-waiting）或<strong>忙等待</strong>（busy waiting）：线程会循环反复测试是否可以获取锁，会一直在 CPU 上运行。在抢占式调度器的操作系统下（目前<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheduling_%28computing%29#Summary">主流操作系统</a>都是抢占式的），在时间片结束后，调度器会将 CPU 调度给其他线程。线程也可以主动<strong>让出</strong>（yield）CPU，在类 Unix 系统下调用 <code>sched_yield()</code> 函数。一些旧的自旋等待的实现会在循环中调用 <code>sched_yield()</code>，不过在 Linux 下不推荐在自旋循环中调用 <code>sched_yield()</code><sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>。自旋线程的线程状态一直处于 <code>running</code> 或 <code>runnable</code> 状态（<code>runnable</code> 状态，也被叫做 <code>ready</code> 状态）。</li>
<li><strong>阻塞</strong>（blocking），或叫<strong>睡眠等待</strong>（sleep-waiting）或<strong>基于调度器阻塞</strong>（scheduler-based blocking）：线程会主动睡眠（阻塞）自己，请求调度器<strong>取消调度</strong>（deschedule）当前线程，让出 CPU 资源給另外一个线程。线程状态将一直处于 <code>sleeping</code> 状态（也叫 <code>waiting</code> 状态），直到被唤醒，被唤醒后状态为 <code>runnable</code>。</li>
</ul>
<p>阻塞线程相对耗时较大，至少需要执行两次线程上下文切换。自旋会浪费 CPU 资源，所以自旋等待的时间应该尽量短，自旋时间最好小于完成两次上下文切换的耗时。单次请求锁的 CAS 原子操作消耗的 CPU 时钟周期数大概是 15 ~ 30，而单次线程上下文切换的总消耗的 CPU 时钟周期数大概是 10,000 ~ 1,000,000，消耗的 CPU 时钟周期数相差约 100 ~ 10000 倍<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>。</p>
<p>自旋和阻塞策略存在各自缺点，所以目前很多操作系统内核的互斥锁实现采用<strong>混合策略</strong>，即“spin-then-block”的等待策略，实现的互斥锁称为<strong>自适应互斥锁</strong>（adaptive mutex）。目前 Solaris、Mac OS X、Linux 和 FreeBSD 内核实现的互斥锁，默认都是“adaptive mutex”。另外，pthread 线程库也支持创建<strong>自适应类型的 mutex</strong>。</p>
<p>操作系统内核和 pthread 线程库的自适应互斥锁的历史演进：</p>
<ul>
<li>1992.06，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Oracle_Solaris#Version_history">Solaris</a> 2.0 发布，内核实现的 mutex 默认是“adaptive mutex”<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>。</li>
<li>2000.07，glibc 2.2 版本的 pthread 线程库开始支持创建自适应类型的 mutex，相关类型参数是 <code>PTHREAD_MUTEX_ADAPTIVE_NP</code>（参见 <a target="_blank" rel="noopener" href="https://github.com/bminor/glibc/blob/a88b96f496c0214424db1219d21ce669fbc102a0/linuxthreads/ChangeLog">commit</a>）。不过，默认 mutex 类型是 <code>PTHREAD_MUTEX_NORMAL</code>，等待策略是立即阻塞而不是先自旋。</li>
<li>2007.10，FreeBSD 的 pthread 线程库开始支持自适应类型的 mutex，实现 glibc 的 <code>PTHREAD_MUTEX_ADAPTIVE_NP</code> 类型的 mutex（参见 <a target="_blank" rel="noopener" href="https://github.com/freebsd/freebsd-src/commit/2017a7cdfe8f1a0e38b76e8e8871fe90df07b8f7">commit</a>、<a target="_blank" rel="noopener" href="https://github.com/freebsd/freebsd-src/commit/7416cdabcd0c1dd626ff5b7edfcedf11967ff39f">commit</a>）。FreeBSD 的 pthread 线程库，默认 mutex 类型是 <code>PTHREAD_MUTEX_ERRORCHECK</code>，等待策略是立即阻塞而不是先自旋。</li>
<li>2009.03，Linux 2.6.29 内核发布，内核的 mutex 实现“adaptive spinning”（参见 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/0d66bf6d3514b35eb6897629059443132992dbd7">commit</a>），类似于 Solaris 的 adaptive mutex。</li>
<li>2009.11，FreeBSD 8.0 发布，从 FreeBSD 8.0 开始内核实现的 mutex 默认是“adaptive mutex”，实现类似于 Solaris。</li>
</ul>
<p>Solaris 实现的自适应互斥锁的自旋策略是<sup class="footnote-ref"><a href="#fn21" id="fnref21:1">[21:1]</a></sup><sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>：当线程试图去获取一个锁且锁已经被占有时，内核检查当前占有该锁的线程的状态。如果锁的持有者正在某一处理器上运行，申请线程就会旋转；如果锁的持有者当前没有运行，申请线程就会阻塞。Solaris 的自旋次数的配置参数是 <code>LIBTHREAD_ADAPTIVE_SPIN</code>，默认值 1000。Linux 和 FreeBSD 实现的自旋策略与 Solaris 类似（参见 FreeBSD locking <a target="_blank" rel="noopener" href="https://man.freebsd.org/cgi/man.cgi?query=locking&amp;manpath=FreeBSD+10.0-RELEASE">man</a>）。</p>
<p>glibc 的 pthread 实现的自适应互斥锁的自旋策略是<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>：每个自适应 mutex 的自旋次数，基于之前的自旋次数在 0 ~ 100 之间动态调整。最大的自旋次数可配置，配置参数是 <code>glibc.pthread.mutex_spin_count</code>，默认值 100（参见 glibc <a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/manual/html_node/POSIX-Thread-Tunables.html">doc</a>）。</p>
<p>FreeBSD 实现的 pthread 线程库的自适应互斥锁的自旋策略是：先执行固定配置次数的自旋循环，然后执行调用 yield 的自旋循环，最后再睡眠等待。自旋次数的配置参数是 <code>LIBPTHREAD_SPINLOOPS</code>，默认值 2000；调用 yield 的自旋循环，默认不开启，调用 yield 的自旋次数的配置参数是 <code>LIBPTHREAD_YIELDLOOPS</code>，默认值 0（参见 FreeBSD libthr <a target="_blank" rel="noopener" href="https://man.freebsd.org/cgi/man.cgi?query=libthr&amp;manpath=FreeBSD+11.0-RELEASE">man</a>）。</p>
<p>HotSpot 的 Monitor 内部的互斥锁实现的历史演进：</p>
<ul>
<li>2000.05，J2SE 1.3 发布，并同时发布 HotSpot 2.0，从这版本的 HotSpot 开始，Monitor 内部的互斥锁（mutex）实现的锁等待策略是“spin-then-block”，即先自旋重试再阻塞，参见 <a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-4256394">JDK-4256394</a>。自旋策略是<strong>固定自旋</strong>（fixed spinning），按固定配置的次数自旋（默认 10 次）。
<ul>
<li><strong>JVM 参数选项</strong>：-XX:+<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk6.html?s=UseSpinning">UseSpinning</a>，是否自旋，默认关闭；-XX:<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk6.html?s=PreBlockSpin">PreBlockSpin</a>，阻塞前的自旋次数，默认值 10。Java 6 开始，旧的 -XX:+UseSpinning 和 -XX:PreBlockSpin 等自旋 JVM 参数选项不再有效，Java 7 发布后，相关参数被删除。</li>
</ul>
</li>
<li>2006.12，Java 6 发布，HotSpot 的 Monitor 内部的互斥锁实现的锁等待策略改为“adaptive spin-then-block”，自旋策略改为<strong>自适应自旋</strong>（<a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html#adaptiveSpinning">adaptive spinning</a>），自旋次数在 0 ~ 5000 之间动态调整。每个 Monitor 各自独立维护动态自旋次数，当前的自旋次数根据最近的自旋获得锁的成功/失败率动态调整，如果最近的自旋成功率高，说明当前的自旋也很有可能成功，则尝试更多次数的自旋。若成功率低，则减少自旋次数。最大的自旋次数是 5000。
<ul>
<li>底层实现函数为 <code>ObjectMonitor::TrySpin_VaryDuration(..)</code>，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1905">objectMonitor.cpp</a>。</li>
</ul>
</li>
</ul>
<h2 id="park-unpark-同步原语">park-unpark 同步原语</h2>
<p>HotSpot 的 Monitor 同步子系统的实现，除了用于阻塞和唤醒线程的依赖操作系统平台相关的 <strong>park-unpark 抽象</strong>外，尽量避免使用操作系统原生的同步原语（synchronization primitive）。总体上，Monitor 的实现底层只依赖于 <strong>park-unpark 抽象</strong>和<strong>原子操作</strong>。park-unpark 抽象，由 JVM 的 <code>ParkEvent</code> 和 <code>PlatformEvent</code> 类实现，<code>ParkEvent</code> 是 <code>PlatformEvent</code> 的子类，<code>ParkEvent</code> 与操作系统平台无关，<code>PlatformEvent</code> 与操作系统平台相关。<code>ParkEvent</code> 类的实现，参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/park.hpp">park.hpp</a> 和 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/park.cpp">park.cpp</a>。<code>PlatformEvent**</code> 类的实现概括来说：</p>
<ul>
<li><strong>类 Unix 系统</strong>：基于 pthread 的 mutex 互斥锁和条件变量实现。Linux 系统的线程同步底层基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Futex">futex</a> 系统调用，Solaris 系统的线程同步底层基于 <code>lwp_park</code>、<code>lwp_unpark</code> 系统调用。</li>
<li><strong>Windows 系统</strong>：基于 Windows 的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/sync/event-objects">Event 对象</a>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_%28synchronization_primitive%29">wiki</a>）实现。</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.cpp#L264">objectMonitor.cpp</a> 代码注释</strong>：</p>
<blockquote>
<p>The monitor synchronization subsystem avoids the use of native synchronization primitives except for the narrow platform-specific park-unpark abstraction. See the comments in os_solaris.cpp regarding the semantics of park-unpark. Put another way, this monitor implementation depends only on atomic operations and park-unpark.</p>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L5938">os_solaris.cpp</a> 代码注释</strong>：</p>
<blockquote>
<p><strong>ObjectMonitor park-unpark infrastructure</strong><br>
We implement Solaris and Linux PlatformEvents with the obvious condvar-mutex-flag triple. Another alternative that works quite well is pipes: Each PlatformEvent consists of a pipe-pair. The thread associated with the PlatformEvent calls park(), which reads from the input end of the pipe. Unpark() writes into the other end of the pipe. The write-side of the pipe must be set NDELAY. Unfortunately pipes consume a large # of handles. Native solaris lwp_park() and lwp_unpark() work nicely, too. Using pipes for the 1st few threads might be workable, however.</p>
</blockquote>
<p><strong>park-unpark 同步原语的具体实现</strong>：</p>
<ul>
<li><strong>阻塞线程</strong>：调用 <code>ParkEvent::park()</code> 或 <code>ParkEvent::park(jlong millis)</code>，实际调用与操作系统相关的父类实现的 <code>os::PlatformEvent::park()</code> 或 <code>os::PlatformEvent::park(jlong millis)</code>
<ul>
<li><strong>类 Unix 系统</strong>：通过调用 POSIX 函数 <code>pthread_cond_wait</code> 或 <code>pthread_cond_timedwait</code>（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html">man</a>） 阻塞线程，等待条件是事件数大于等于 0，在阻塞线程前先调用 <code>pthread_mutex_lock</code> 获取 mutex 互斥锁（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5862">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/bsd/vm/os_bsd.cpp#L4426">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L6092">os_solaris.cpp</a>）</li>
<li><strong>Windows 系统</strong>：通过调用函数 <code>WaitForSingleObject</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">doc</a>）阻塞线程（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L4904">os_windows.cpp</a>）</li>
</ul>
</li>
<li><strong>唤醒线程</strong>：调用 <code>ParkEvent::unpark()</code>，实际调用与操作系统相关的父类实现的 <code>os::PlatformEvent::unpark()</code>
<ul>
<li><strong>类 Unix 系统</strong>：将等待条件的事件数设置为 1，然后通过调用 POSIX 函数 <code>pthread_cond_signal</code> 唤醒线程，在唤醒线程前先调用 <code>pthread_mutex_lock</code> 获取 mutex 互斥锁（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/linux/vm/os_linux.cpp#L5963">os_linux.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/bsd/vm/os_bsd.cpp#L4426">os_bsd.cpp</a>、<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/solaris/vm/os_solaris.cpp#L6136">os_solaris.cpp</a>）</li>
<li><strong>Windows 系统</strong>：通过调用函数 <code>SetEvent</code>（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">doc</a>）唤醒线程（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/os/windows/vm/os_windows.cpp#L4949">os_windows.cpp</a>）</li>
</ul>
</li>
</ul>
<p>JDK 1.5 开始引入的 <code>java.util.concurrent</code> 包下包含 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html">LockSupport</a> 类，[LockSupport] 类提供 <code>LockSupport.park()</code> 和 <code>LockSupport.unpark(..)</code> 等静态方法，将 HotSpot 虚拟机的 park-unpark 同步原语暴露到 JDK 层。具体实现上：</p>
<ul>
<li><code>LockSupport.park()</code> 方法底层调用 <code>sun.misc.Unsafe.park()</code>，<code>Unsafe.park()</code> 在 JVM 层的调用 <code>unsafe.cpp</code> 下的 <code>Unsafe_Park()</code>，最后调用 <code>ParkEvent::park()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/unsafe.cpp#L1206">unsafe.cpp</a>）</li>
<li><code>LockSupport.unpark()</code> 方法底层调用 <code>sun.misc.Unsafe.unpark()</code>，<code>Unsafe.unpark()</code> 在 JVM 层的调用 <code>unsafe.cpp</code> 下的 <code>Unsafe_Unpark()</code>，最后调用 <code>ParkEvent::unpark()</code>（参见源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/prims/unsafe.cpp#L1232">unsafe.cpp</a>）。</li>
</ul>
<p>JUC 包下的核心类，比如 <code>AbstractQueuedSynchronizer</code> (AQS)，底层的线程阻塞和唤醒都基于 <code>LockSupport</code> 实现。</p>
<h1 id="基于-ReentrantLock-线程同步">基于 ReentrantLock 线程同步</h1>
<p>JDK 1.5 开始（2004.04 发布）引入 <code>java.util.concurrent</code> 包，简称 j.u.c 包或 JUC 包。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>synchronized 同步</strong></th>
<th><strong>ReentrantLock 同步</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>支持时间</strong></td>
<td>最早版本的 Java（1995.05）</td>
<td>JDK 1.5 开始（2004.04）</td>
</tr>
<tr>
<td><strong>实现层级</strong></td>
<td>JVM 层，Java 语法级内置</td>
<td>JDK 层，基于 JDK 标准库的 AQS 框架</td>
</tr>
<tr>
<td><strong>加解锁方式</strong></td>
<td>隐式，加解锁与语句绑定</td>
<td>显式，加解锁显示调用 lock 和 unlock 方法</td>
</tr>
<tr>
<td><strong>条件变量</strong></td>
<td>关联单个隐式的条件变量</td>
<td>关联多个显式定义的条件变量</td>
</tr>
<tr>
<td><strong>锁等待策略</strong></td>
<td>自适应自旋后阻塞</td>
<td>立即阻塞（继承人线程除外）</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>非公平</td>
<td>支持非公平（默认）和公平</td>
</tr>
<tr>
<td><strong>优缺点</strong></td>
<td>更易用</td>
<td>功能更全面，支持超时、tryLock()、中断、公平锁</td>
</tr>
</tbody>
</table>
<p>基于 ReentrantLock 和 Condition 的管程的底层实现，如下图所示。图中线程 A 持有锁，线程 B、线程 C、线程 D，竞争锁失败，在竞争等待队列中阻塞等待。如果线程 A 释放锁，线程 B 会被选为继承人线程。唤醒后的继承人线程，<strong>自旋</strong>竞争锁，竞争锁成功后，移出锁等待队列（dequeue）。</p>
<p><img src="media/java-aqs-monitor-internals.png" alt="基于 ReentrantLock 和 Condition 的 Monitor 的底层实现"></p>
<h1 id="参考资料">参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>HotSpot Runtime Overview <a target="_blank" rel="noopener" href="https://openjdk.org/groups/hotspot/docs/RuntimeOverview.html">https://openjdk.org/groups/hotspot/docs/RuntimeOverview.html</a>（概括性介绍 HotSpot，内容包括 Synchronization、Thread Management 等） <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>2008-04 Synchronization and Object Locking <a target="_blank" rel="noopener" href="https://wiki.openjdk.org/display/HotSpot/Synchronization">https://wiki.openjdk.org/display/HotSpot/Synchronization</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>2005-10 Dave Dice: Synchronization (with a focus on J2SE) (slides, 89p) <a target="_blank" rel="noopener" href="https://web.archive.org/web/0/https://blogs.oracle.com/dave/resource/synchronization-public2.pdf">https://web.archive.org/web/0/https://blogs.oracle.com/dave/resource/synchronization-public2.pdf</a> <a target="_blank" rel="noopener" href="https://speakerdeck.com/xy/synchronization-public2">https://speakerdeck.com/xy/synchronization-public2</a>（该 slides 是在 Hotspot 源码注释中被推荐阅读的 slides，作者是 Sun 公司的 Hotspot 工程师，是 Hotspot 同步子系统的核心实现者之一） <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>2006-08 Dave Dice: Synchronization in Java SE 6 (HotSpot) (slides, 15p) <a target="_blank" rel="noopener" href="https://web.archive.org/web/0/http://blogs.oracle.com/dave/resource/MustangSync.pdf">https://web.archive.org/web/0/http://blogs.oracle.com/dave/resource/MustangSync.pdf</a> <a target="_blank" rel="noopener" href="https://speakerdeck.com/xy/mustang-sync">https://speakerdeck.com/xy/mustang-sync</a>（该 slides 是在 Hotspot 源码注释中被推荐阅读的 slides） <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>2006-08 Dave Dice: Lets say you're interested in using HotSpot as a vehicle for synchronization research ... <a target="_blank" rel="noopener" href="https://web.archive.org/web/0/http://blogs.sun.com/dave/entry/lets_say_you_re_interested">https://web.archive.org/web/0/http://blogs.sun.com/dave/entry/lets_say_you_re_interested</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>2015-10 David Buck: HotSpot Synchronization: A Peek Under the Hood (JavaOne 2015, slides, 100p) <a target="_blank" rel="noopener" href="https://www.slideshare.net/DavidBuck7/hotspot-synchronization-a-peek-under-the-hood-javaone-2015-con7570">https://www.slideshare.net/DavidBuck7/hotspot-synchronization-a-peek-under-the-hood-javaone-2015-con7570</a> <a href="#fnref6" class="footnote-backref">↩︎</a> <a href="#fnref6:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>2015-06 Doug Lea: The Design and Engineering of Concurrency Libraries (slides, 91p) <a target="_blank" rel="noopener" href="https://speakerdeck.com/xy/doug-lea-concurrency-libraries">https://speakerdeck.com/xy/doug-lea-concurrency-libraries</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>程序设计语言：实践之路，Michael L. Scott，第3版2009，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10802357/">豆瓣</a>：第12章 并发 <a href="#fnref8" class="footnote-backref">↩︎</a> <a href="#fnref8:1" class="footnote-backref">↩︎</a> <a href="#fnref8:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>操作系统导论，Arpaci-Dusseau，2018，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/33463930/">豆瓣</a>：第2部分 并发 <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>2011，Michael L. Scott: <strong>Synchronization</strong>. Encyclopedia of Parallel Computing 2011: 1989-1996，<a target="_blank" rel="noopener" href="https://dblp.org/rec/reference/parallel/Scott11.html">dblp</a>、<a target="_blank" rel="noopener" href="https://doi.org/10.1007/978-0-387-09766-4_252">doi</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>2011，Danny Hendler: <strong>Non-Blocking Algorithms</strong>. Encyclopedia of Parallel Computing 2011: 1321-1329，<a target="_blank" rel="noopener" href="https://dblp.org/rec/reference/parallel/Hendler11.html">dblp</a>、<a target="_blank" rel="noopener" href="https://doi.org/10.1007/978-0-387-09766-4_185">doi</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>多处理器编程的艺术，Maurice Herlihy &amp; Nir Shavit，第2版2021，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35913539/">豆瓣</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Shared-Memory Synchronization, Michael L. Scott, 2013，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/25732314/">豆瓣</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>1998，David F. Bacon, etc: <strong>Thin Locks: Featherweight Synchronization for Java</strong>. PLDI 1998: 258-268，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/pldi/BaconKMS98.html">dblp</a>，<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Thin-locks%3A-featherweight-synchronization-for-Java-Bacon-Konuru/07ab0964c6afca7fec1d1a00df9375de2ae26e1e">semanticscholar</a>：作者来自 IBM 研究院，提出瘦锁（Thin Lock）技术 <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>1999，Ole Agesen, etc: <strong>An Efficient Meta-Lock for Implementing Ubiquitous Synchronization</strong>. OOPSLA 1999: 207-222，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/AgesenDGKRW99.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/An-efficient-meta-lock-for-implementing-ubiquitous-Agesen-Detlefs/add4082ea2d5eded2f75a6a3f5b7f622a1f8542a">semanticscholar</a>：作者来自 Sun 公司 <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>2006，Kenneth B. Russell, David Detlefs: <strong>Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing</strong>. OOPSLA 2006: 263-272：<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/RussellD06.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Eliminating-synchronization-related-atomic-with-and-Russell-Detlefs/356a2d9859520c9161d67828d45e758a24ecce20">semanticscholar</a>、<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf">slides</a>：作者来自 Sun 公司，主要阐述 Java 6 的 HotSpot 虚拟机实现的偏向锁，同时也介绍了轻量级锁的实现 <a href="#fnref16" class="footnote-backref">↩︎</a> <a href="#fnref16:1" class="footnote-backref">↩︎</a> <a href="#fnref16:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>2002，Kiyokuni Kawachiya, etc: <strong>Lock Reservation: Java Locks can Mostly do without Atomic Operations</strong>. OOPSLA 2002: 130-141，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/oopsla/KawachiyaKO02.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/reservation%3A-Java-locks-can-mostly-do-without/884749059cae01a003a4f0d9011df3d4ab7dd166">semanticscholar</a>：作者来自 IBM 研究院，提出锁保留（Lock Reservation）技术 <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>2014，Marcus Larsson: <strong>Evaluating and improving biased locking in the HotSpot virtual machine</strong>. KTH Master Thesis，<a target="_blank" rel="noopener" href="http://www.diva-portal.org/smash/get/diva2:754541/FULLTEXT01.pdf">pdf</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>2003-05 The right way to yield <a target="_blank" rel="noopener" href="https://lwn.net/Articles/31462/">https://lwn.net/Articles/31462/</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>2016-09 Infographics: Operation Costs in CPU Clock Cycles <a target="_blank" rel="noopener" href="http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/">http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Joseph R. Eykholt, etc: <strong>Beyond Multiprocessing: Multithreading the SunOS Kernel</strong>. USENIX Summer 1992，<a target="_blank" rel="noopener" href="https://dblp.org/rec/conf/usenix/EykholtKBFSSVWW92.html">dblp</a>、<a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Beyond-Multiprocessing%3A-Multithreading-the-SunOS-Eykholt-Kleiman/c087671a641adbbcb01cb6b59d38a9a43e6da4b5">semanticscholar</a>：介绍 Solaris 2.0 内核的多线程技术 <a href="#fnref21" class="footnote-backref">↩︎</a> <a href="#fnref21:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Solaris 内核结构（Solaris Internals），Richard McDougall &amp; Jim Mauro，第2版2006，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/2161545/">豆瓣</a>：第17章 锁和同步，17.5 互斥锁 <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>What is PTHREAD_MUTEX_ADAPTIVE_NP <a target="_blank" rel="noopener" href="https://stackoverflow.com/q/19863734/689699">https://stackoverflow.com/q/19863734/689699</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2024/01/rocketmq-kafka-sharding-replication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/rocketmq-kafka-sharding-replication/" class="post-title-link" itemprop="url">RocketMQ 和 Kafka 的数据分片和复制策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-18 20:36:00" itemprop="dateCreated datePublished" datetime="2024-01-18T20:36:00+08:00">2024-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2024/01/rocketmq-kafka-sharding-replication/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/01/rocketmq-kafka-sharding-replication/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了提升系统的<strong>可扩展性</strong>（scalability），分布式数据库或分布式存储系统通常支持数据<strong>分区</strong>（partitioning）或<strong>分片</strong>（sharding），即将完整的数据拆分存放在多个服务器节点上，拆分后的部分数据称为“partition”或“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">shard</a>”。数据被拆分后多个服务器节点能分摊负载压力，从而提升系统性能。“分区”和分片”，这两个术语，在很多情况下不区分，可以混用。如果严格区分的话，<strong>分片</strong>拆分的数据分布在多个服务器节点上，而<strong>分区</strong>拆分的数据在单个服务器节点。另外，<strong>复制</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Replication_%28computing%29">replication</a>）也典型的分布式技术，多个数据副本能实现读请求的负载均衡，提升系统性能。同时复制也提供了冗余容错的能力，提升系统的<strong>可用性</strong>（availability）。本文关注消息中间件的消息存储系统，解析并对比 RocketMQ 和 Kafka 的消息数据的分片和复制的具体实现策略。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/01/rocketmq-kafka-sharding-replication/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2023/12/website-scalability-reliability-resilience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/website-scalability-reliability-resilience/" class="post-title-link" itemprop="url">大型网站的稳定性、可靠性和韧性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-25 10:36:00" itemprop="dateCreated datePublished" datetime="2023-12-25T10:36:00+08:00">2023-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2023/12/website-scalability-reliability-resilience/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/12/website-scalability-reliability-resilience/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了应对负载的增长，提升系统性能，目前大型网站普遍都是分布式架构，采用微服务架构风格。分布式系统的最重要的架构特性是<strong>伸缩性</strong>（scalability），伸缩性的系统具备应对增长的工作负载的能力。关于性能和伸缩性，可以参阅笔者的文章《<a href="https://nullwy.me/2023/12/website-performance-scalability/">大型网站的性能和可伸缩性</a>》。相对于采用单体架构的系统，分布式系统中有大量的服务器及设备，各服务之间存在错综复杂的依赖关系，存在更多的不确定性。整个系统的故障率会随服务节点的增加而呈指数级增加，单一节点问题可能会被无限放大，日常运行过程中一定会伴随故障发生。所以构建分布式系统需要关注的另外一个重要架构特性是<strong>稳定性</strong>（stability）。有关减少系统故障以及快速从故障中恢复的工程实践，国内通常称为“稳定性建设”，而国外类似的工程实践更多称为“站点可靠性工程”（SRE, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Site_reliability_engineering">Site reliability engineering</a>）。稳定性（stability）、可靠性（reliability）、韧性（resilience）、可用性（availability）等架构特性，相似并且相关，虽然严格区分的话，含义并不相同，但是很多时候在探讨这些架构特性时往往涵盖的是类似的内容。本文的内容主要是总结稳定性、可靠性、韧性这些架构特性的内涵，以及如何建设分布式系统的这些特性。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/12/website-scalability-reliability-resilience/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2023/12/website-performance-scalability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/website-performance-scalability/" class="post-title-link" itemprop="url">大型网站的性能和可伸缩性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-08 21:08:00" itemprop="dateCreated datePublished" datetime="2023-12-08T21:08:00+08:00">2023-12-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2023/12/website-performance-scalability/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/12/website-performance-scalability/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>互联网网站在初期用户量和访问量一般都很小，往往只需要采用最简单的技术架构就能对外提供稳定服务。最简单的架构通常采用的是单机应用服务器、单机数据库服务器这样的单体架构。成功的互联网网站，比如电商平台，流量、用户量、交易量等核心指标是呈指数增长的，所以就需要提升网站系统的性能，来应对更大的负载。通过向系统中增加资源来提升系统性能的能力，被称为可伸缩性（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scalability">scalability</a>）。为了提升系统的可伸缩性，典型的大型网站，比如 eBay、Amazon 和淘宝等，几乎都经历过从单体架构向分布式架构演进的过程。本文主要关注大型网站或 Web 服务这类系统，解释系统的性能和可伸缩性相关的核心概念，并介绍系统的性能指标、系统的扩展策略和分布式架构风格，同时也总结分析典型大型网站的可扩展性架构演进案例，案例包括 eBay、Amazon、淘宝等。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/12/website-performance-scalability/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2023/12/popular-websites-tech-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/popular-websites-tech-stack/" class="post-title-link" itemprop="url">流行互联网网站技术栈整理（万字长文）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-03 23:37:00" itemprop="dateCreated datePublished" datetime="2023-12-03T23:37:00+08:00">2023-12-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2023/12/popular-websites-tech-stack/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/12/popular-websites-tech-stack/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文整理总结主要的流行互联网网站技术栈，以及这些网站的技术栈和架构的历史演进过程。涉及的网站大部分都是当前或曾经访问量或月活用户量 Top 的网站（参见 Similarweb 网站的统计<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，或访问量 Top 10 网站的历史演变<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，或 wiki 整理的至少 1 亿月活用户量的社交平台<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>）。国内网站或 APP 涵盖了主流<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的阿里、腾讯、百度、美团、字节、京东等大厂的互联网产品。整理的技术栈主要是流行网站的服务端业务系统的技术栈，包括编程语言、数据库、RPC 框架等，同时也简单整理了大数据技术栈，前端和客户端技术栈等不涉及。除了对大部分流行网站的技术栈做系统性梳理外，本文还挑选部分有代表性的网站，对这些网站的技术栈和架构的历史演进做详细解析。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/12/popular-websites-tech-stack/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2023/11/amazon-architecture-evolution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/amazon-architecture-evolution/" class="post-title-link" itemprop="url">亚马逊网站架构演进</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-20 12:45:00" itemprop="dateCreated datePublished" datetime="2023-11-20T12:45:00+08:00">2023-11-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2023/11/amazon-architecture-evolution/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/11/amazon-architecture-evolution/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SOA-与微服务">SOA 与微服务</h1>
<p>Amazon，1994 年创立，早期网站是单服务、单数据库的单体架构的系统<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，全部代码由 C++ 编写，编译成单个二进制文件，整个代码仓库被命名为 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Obidos_(software)">Obidos</a>。Obidos 是底层是一个 Web 页面渲染引擎，是一个框架，业务逻辑基于这个框架开发，Obidos 渲染引擎和业务逻辑共同组成整个代码仓库。随着时间的推移，Obidos 变得越来越复杂，编译 Obidos 整个代码库耗时 12 小时，开发调试效率低下<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>。另外，全部业务逻辑在单个二进制文件中，导致紧耦合，新功能特性无法快速发布上线。1995 年，Amazon 网站的技术架构，如下图所示<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/amazon-architecture-evolution/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2023/10/reliability-engineering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/reliability-engineering/" class="post-title-link" itemprop="url">可靠性工程概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-19 12:43:00" itemprop="dateCreated datePublished" datetime="2023-10-19T12:43:00+08:00">2023-10-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2023/10/reliability-engineering/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/10/reliability-engineering/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了应对负载的增长，目前大型网站普遍都采用分布式架构。相对于采用单体架构的系统，分布式系统中有大量的服务器及设备，各模块之间存在错综复杂的依赖关系，存在更多的不确定性。整个系统的故障率会随设备的增加而呈指数级增加，单一节点问题可能会被无限放大，日常运行过程中一定会伴随故障发生。所以，可靠性开始成为大型网站关注的最重要的质量属性之一，并因此发展出了站点可靠性工程（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Site_reliability_engineering">Site reliability engineering</a>，SRE）。站点可靠性工程，是从可靠性工程发展而来的，从可靠性工程中借鉴了概念和成果。本文溯本求源，内容主要是总结概括，可靠性工程的历史演进和核心概念，软件可靠性工程的核心概念，以及可靠性设计的方法。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/10/reliability-engineering/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2023/07/io-multiplexing-network-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/io-multiplexing-network-server/" class="post-title-link" itemprop="url">I/O 多路复用与网络服务器并发策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-26 00:44:00" itemprop="dateCreated datePublished" datetime="2023-07-26T00:44:00+08:00">2023-07-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2023/07/io-multiplexing-network-server/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/07/io-multiplexing-network-server/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前主流的网络服务器，网络 I/O 相关的底层最核心的技术都是 I/O 多路复用（I/O Multiplexing），比如 Apache HTTP Server、Nginx、Redis 等。本文尝试解释各种 I/O 模型，包括解释什么是 I/O 多路复用，同时也总结 I/O 多路复用底层的系统调用 select、poll、kqueue 和 epoll 的演进和区别，并编写了使用这些函数的示例代码。另外，本文还总结了各种基于 I/O 多路复用实现的网络服务器的并发策略的三种模式，包括对 Apache HTTP Server、Nginx 和 Redis 等网络服务器的并发策略的具体案例的解析。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/07/io-multiplexing-network-server/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2023/07/innodb-locking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/innodb-locking/" class="post-title-link" itemprop="url">InnoDB 的并发控制：锁与 MVCC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-10 21:20:00" itemprop="dateCreated datePublished" datetime="2023-07-10T21:20:00+08:00">2023-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2023/07/innodb-locking/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/07/innodb-locking/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前主流数据库事务的并发控制实现，如 MySQL InnoDB、PostgreSQL、Oracle，都使用两阶段封锁 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Two-phase_locking">2PL</a> 与 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a> 技术，但具体实现细节上存在差异。InnoDB 是在以封锁技术为主体的情况下，用 MVCC 技术辅助实现读-写、写-读操作的并发。PostgreSQL 的并发控制技术是以 MVCC 技术为主，封锁技术为辅。本文主要关注 InnoDB 事务的并发控制实现。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/07/innodb-locking/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2020/05/kong-gateway/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/kong-gateway/" class="post-title-link" itemprop="url">微服务 API 网关 Kong 实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 15:22:41" itemprop="dateCreated datePublished" datetime="2020-05-30T15:22:41+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2020/05/kong-gateway/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/kong-gateway/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kong-简介">Kong 简介</h1>
<p>Kong 是云原生、高效、可扩展、分布式的微服务抽象层，被称为 API 网关，或者 API 中间件。Kong 在 2015 年 4 月由 Mashape 公司开源，基于 OpenResty 和 Apache Cassandra/PostgreSQL 构建，提供易于使用的 RESTful API 来操作和配置 API 系统<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/kong-gateway/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2019/06/mysql-5.7-json/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/mysql-5.7-json/" class="post-title-link" itemprop="url">MySQL 5.7 的 JSON 类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-25 03:18:31" itemprop="dateCreated datePublished" datetime="2019-06-25T03:18:31+08:00">2019-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2019/06/mysql-5.7-json/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/mysql-5.7-json/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2015 年 8 月，MySQL 5.7.8 开始提供对 JSON 的原生支持<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。MySQL 对 JSON 的支持可以说是千呼万唤始出来。2009 年开始 NoSQL 逐渐流行起来，相继出现了键值对数据库、文档数据库、列族数据库、图数据库等各类 NoSQL，解决经典关系型数据库无法解决的痛点。其中，对灵活存储半结构化数据的需求，使得类似 MongoDB 这类文档数据库涌现出来。各大主流关系型数据库也在响应趋势，开始支持半结构化数据。早在 2012 年，PostgreSQL 9.2 就已经添加了 JSON 数据类型<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。Oracle 也在 2014 年 7 月发布 12c Release 1 后开始支持 JSON<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。Facebook 在 MySQL 5.7 没发布之前，对 5.6 版本的 MySQL 添加了存储 JSON 功能，这个特性被 Facebook 命名为 DocStore (Document Database for MySQL at Facebook)<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。另外，SQL 标准组织行动也很快，在 2014 年 3 月已经完成了 SQL/JSON 标准草案（SQL/JSON Proposals）<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。完整的草案在 2016 年 12 月正式被采纳为标准，即 SQL:2016。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/06/mysql-5.7-json/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2019/01/elastic-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/elastic-stack/" class="post-title-link" itemprop="url">Elastic Stack 日志分析平台搭建笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-14 14:58:20" itemprop="dateCreated datePublished" datetime="2019-01-14T14:58:20+08:00">2019-01-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2019/01/elastic-stack/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/elastic-stack/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Elastic Stack（旧称 ELK Stack）是最受欢迎的开源日志平台 [ <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/solutions/logging">ref</a> ]。Elastic Stack 由 Elasticsearch、Logstash、Kibana 和 Beats 四个组件组成：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/beats">Beats</a>，是轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/logstash">Logstash</a>，集中、转换和存储数据，是动态数据收集管道，拥有可扩展的插件生态系统，能够与 Elasticsearch 产生强大的协同作用。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/elasticsearch">Elasticsearch</a>，搜索、分析和存储您的数据，是基于 JSON 的分布式搜索和分析引擎，专为实现水平扩展、高可靠性和管理便捷性而设计。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/kibana">Kibana</a>，实现数据可视化，导览 Elastic Stack。能够以图表的形式呈现数据，并且具有可扩展的用户界面，供您全方位配置和管理 Elastic Stack。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/01/elastic-stack/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2018/10/java-agent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/java-agent/" class="post-title-link" itemprop="url">Java Agent 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-04 23:26:20" itemprop="dateCreated datePublished" datetime="2018-10-04T23:26:20+08:00">2018-10-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2018/10/java-agent/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/java-agent/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java 从 1.5 开始提供了 <code>java.lang.instrument</code>（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/instrumentation/">doc</a>）包，该包为检测（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instrumentation_%28computer_programming%29">instrument</a>） Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 <code>java.lang.instrument</code> 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测。关于如何使用 <code>java.lang.instrument</code> 包，可以参考 javadoc 的包描述（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">en</a>, <a target="_blank" rel="noopener" href="http://www.cjsdn.net/doc/jdk60/java/lang/instrument/package-summary.html">zh</a>）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/10/java-agent/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2018/06/mysql-binlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/mysql-binlog/" class="post-title-link" itemprop="url">MySQL binlog：格式、增量恢复、闪回、Java 解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-18 15:09:51" itemprop="dateCreated datePublished" datetime="2018-06-18T15:09:51+08:00">2018-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2018/06/mysql-binlog/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/06/mysql-binlog/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MySQL 的 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/binary-log.html">binlog</a> 日志文件，记录了数据库表的全部修改操作。本文简单整理 MySQL binlog 相关知识，以及如何使用 binlog 恢复或闪回数据库数据。</p>
<h1 id="STATEMENT-格式的-binlog">STATEMENT 格式的 binlog</h1>
<p>要想开启 binlog，需要在启动 MySQL 时传入 --<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#option_mysqld_log-bin">log-bin</a> 参数。或者也可以在 MySQL 配置文件 <code>/etc/my.cnf</code>，设置 <code>log_bin</code> 开启 binlog。MySQL 5.7 开始，开启 binlog 后，<code>--server-id</code> 参数也必须指定，否则 MySQL 服务器会启动失败。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/06/mysql-binlog/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2018/01/stack-frame-calling-convention/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/stack-frame-calling-convention/" class="post-title-link" itemprop="url">栈帧与调用惯例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-29 17:09:51" itemprop="dateCreated datePublished" datetime="2018-01-29T17:09:51+08:00">2018-01-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2018/01/stack-frame-calling-convention/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/stack-frame-calling-convention/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="栈与栈帧">栈与栈帧</h1>
<p>要想知道函数是怎么被调用的，需要了解栈帧和调用惯例相关知识。<a target="_blank" rel="noopener" href="https://book.douban.com/subject/3652388/">俞甲子2009</a> 的“<strong>第10章 内存: 栈与堆</strong>”对相关概念有很好的介绍。本文是对相关知识的学习笔记。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/01/stack-frame-calling-convention/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2018/01/java-ffi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/java-ffi/" class="post-title-link" itemprop="url">Java 外部函数接口：JNI, JNA, JNR</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-24 16:09:51" itemprop="dateCreated datePublished" datetime="2018-01-24T16:09:51+08:00">2018-01-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2018/01/java-ffi/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/java-ffi/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="遇到的问题">遇到的问题</h1>
<p>前段时间开发的时候，遇到一个问题，就是如何用 Java 实现 <code>chdir</code>？网上搜索一番，发现了 <code>JNR-POSIX</code> 项目 [ <a target="_blank" rel="noopener" href="https://stackoverflow.com/q/840190">stackoverflow</a> ]。俗话说，好记性不如烂笔头。现在将涉及到的相关知识点总结成笔记。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/01/java-ffi/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2017/11/zookeeper-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/zookeeper-note/" class="post-title-link" itemprop="url">ZooKeeper 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-23 15:52:51" itemprop="dateCreated datePublished" datetime="2017-11-23T15:52:51+08:00">2017-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2017/11/zookeeper-note/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/11/zookeeper-note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ZooKeeper-介绍">ZooKeeper 介绍</h1>
<p>ZooKeeper（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Apache_ZooKeeper">wiki</a>，<a target="_blank" rel="noopener" href="http://zookeeper.apache.org/">home</a>，<a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper">github</a>） 是用于分布式应用的开源的分布式协调服务。通过暴露简单的原语，分布式应用能在之上构建更高层的服务，如同步、配置管理和组成员管理等。在设计上易于编程开发，并且数据模型使用了熟知的文件系统目录树结构 [ <a target="_blank" rel="noopener" href="http://zookeeper.apache.org/doc/current/zookeeperOver.html">doc</a> ]。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/11/zookeeper-note/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2017/05/java-method-parameter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/java-method-parameter/" class="post-title-link" itemprop="url">Java 运行时获取方法参数名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-02 15:09:51" itemprop="dateCreated datePublished" datetime="2017-05-02T15:09:51+08:00">2017-05-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2017/05/java-method-parameter/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/java-method-parameter/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文整理 Java 运行时获取方法参数名的两种方法，Java 8 的最新的方法和 Java 8 之前的方法。</p>
<h1 id="Java-8-的新特性">Java 8 的新特性</h1>
<p>翻阅 Java 8 的<a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/jdk8/features">新特性</a>，可以看到有这么一条“<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/118">JEP 118</a>: Access to Parameter Names at Runtime”。这个特性就是为了能运行时获取参数名新加的。这个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JDK_Enhancement_Proposal">JEP</a> 只是功能增强的提案，并没有最终实现的 JDK 相关的 API 的介绍。查看“<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/reflection/enhancements.html">Enhancements to the Reflection API</a>” 会看到如下介绍：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/05/java-method-parameter/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nullwy.me/2017/04/javac-api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://static.nullwy.me/avatar.png">
      <meta itemprop="name" content="nullwy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullwy's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/javac-api/" class="post-title-link" itemprop="url">Java 编译器 javac 及 Lombok 实现原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-20 11:53:53" itemprop="dateCreated datePublished" datetime="2017-04-20T11:53:53+08:00">2017-04-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    <i class="far fa-comment"></i>
    <a title="disqus" href="/2017/04/javac-api/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/04/javac-api/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>javac</code> 是 Java 代码的编译器<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，初学 Java 的时候就应该接触过。本文整理一些 <code>javac</code> 相关的高级用法。Lombok 库，大家平常一直在使用，但可能并不知道实现原理解析，其实 Lombok 实现上依赖的是 Java 编译器的注解处理 API（<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=269">JSR-296</a>）<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，本文同时尝试解析 Lombok 的实现原理。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/04/javac-api/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nullwy"
      src="https://static.nullwy.me/avatar.png">
  <p class="site-author-name" itemprop="name">nullwy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yulewei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yulewei" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yulewei@gmail.com" title="E-Mail → mailto:yulewei@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://segmentfault.com/u/nullwy" title="SegmentFault → https:&#x2F;&#x2F;segmentfault.com&#x2F;u&#x2F;nullwy" rel="noopener" target="_blank"><i class="fa fa-globe fa-fw"></i>SegmentFault</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/yulewei/" title="豆瓣 → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yulewei&#x2F;" rel="noopener" target="_blank"><i class="fa fa-globe fa-fw"></i>豆瓣</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/3670612013220988" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;3670612013220988" rel="noopener" target="_blank"><i class="fa fa-globe fa-fw"></i>掘金</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian">
    备案号：<a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备17005717号 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nullwy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">380k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:46</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      总访客量
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    总访问量
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yulewei.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
